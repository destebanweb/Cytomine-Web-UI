{"version":3,"file":"index.js","sources":["src/component/feature/feature.vue?rollup-plugin-vue=script.js","src/component/feature/feature.vue","src/component/feature/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport Feature from 'ol/Feature'\nimport { Observable } from 'rxjs'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { distinctUntilChanged, map as mapObs, mergeAll, throttleTime } from 'rxjs/operators'\nimport uuid from 'uuid/v4'\nimport geometryContainer from '../../mixin/geometry-container'\nimport olCmp from '../../mixin/ol-cmp'\nimport projTransforms from '../../mixin/proj-transforms'\nimport stylesContainer from '../../mixin/styles-container'\nimport useMapCmp from '../../mixin/use-map-cmp'\nimport { findPointOnSurface } from '../../ol-ext/geom'\nimport observableFromOlEvent from '../../rx-ext/from-ol-event'\nimport { hasFeature, hasMap } from '../../util/assert'\nimport { isEqual, plainProps } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\n\n/**\n * @vueProps\n */\nconst props = /** @lends module:feature/feature# */{\n  /**\n   * Feature identifier.\n   * @type {string|number}\n   * @default UUID\n   * @vueSync\n   */\n  id: {\n    type: [String, Number],\n    default: () => uuid(),\n  },\n  /**\n   * All feature properties.\n   * @type {Object}\n   * @default {}\n   * @vueSync\n   */\n  properties: {\n    type: Object,\n    default: () => Object.create(null),\n  },\n}\n\n/**\n * @vueComputed\n */\nconst computed = /** @lends module:feature/feature# */{\n  /**\n   * **GeoJSON** encoded geometry.\n   * @type {Object|undefined}\n   */\n  geometry () {\n    if (this.rev && this.resolvedDataProjection && this.$geometry) {\n      return this.writeGeometryInDataProj(this.$geometry)\n    }\n  },\n  /**\n   * @return {number[]|undefined}\n   */\n  point () {\n    if (this.pointViewProj && this.resolvedDataProjection) {\n      return this.pointToDataProj(this.pointViewProj)\n    }\n  },\n  geometryViewProj () {\n    if (this.rev && this.resolvedDataProjection && this.$geometry) {\n      return this.writeGeometryInViewProj(this.$geometry)\n    }\n  },\n  pointViewProj () {\n    if (this.rev && this.$geometry) {\n      return findPointOnSurface(this.$geometry)\n    }\n  },\n}\n\n/**\n * @vueMethods\n */\nconst methods = /** @lends module:feature/feature# */{\n  /**\n   * Create feature without inner style applying, feature level style\n   * will be applied in the layer level style function.\n   * @return {Feature}\n   * @protected\n   */\n  createOlObject () {\n    let feature = new Feature(this.properties)\n    feature.setId(this.id)\n    feature.setGeometry(this.$geometry)\n\n    return feature\n  },\n  /**\n   * @return {{\n   *     getGeometry: function(): (Geometry|undefined),\n   *     setGeometry: function((Geometry|undefined)): void\n   *   }|Feature|undefined}\n   * @protected\n   */\n  getGeometryTarget () {\n    return this.$feature\n  },\n  /**\n   * @return {Object}\n   * @protected\n   */\n  getServices () {\n    const vm = this\n\n    return mergeDescriptors(\n      this::olCmp.methods.getServices(),\n      this::geometryContainer.methods.getServices(),\n      this::stylesContainer.methods.getServices(),\n      {\n        get feature () { return vm.$feature },\n      },\n    )\n  },\n  /**\n   * @return {Feature|undefined}\n   * @protected\n   */\n  getStyleTarget () {\n    return this.$feature\n  },\n  /**\n   * Checks if feature lies at `pixel`.\n   * @param {number[]} pixel\n   * @return {boolean}\n   */\n  isAtPixel (pixel) {\n    hasMap(this)\n\n    return this.$map.forEachFeatureAtPixel(\n      pixel,\n      f => f === this.$feature,\n      { layerFilter: l => l === this.$layer },\n    )\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  mount () {\n    this.$featuresContainer && this.$featuresContainer.addFeature(this)\n    this.subscribeAll()\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  unmount () {\n    this.unsubscribeAll()\n    this.$featuresContainer && this.$featuresContainer.removeFeature(this)\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  subscribeAll () {\n    this::subscribeToFeatureChanges()\n  },\n}\n\nconst watch = {\n  /**\n   * @param {string|number} value\n   */\n  id (value) {\n    if (this.$feature && value !== this.$feature.getId()) {\n      this.$feature.setId(value)\n    }\n  },\n  /**\n   * @param {Object} value\n   */\n  properties (value) {\n    value = plainProps(value)\n    if (this.$feature && !isEqual(value, plainProps(this.$feature.getProperties()))) {\n      this.$feature.setProperties(plainProps(value))\n    }\n  },\n}\n\n/**\n * A vector object for geographic features with a geometry and other attribute properties,\n * similar to the features in vector file formats like **GeoJSON**.\n *\n * @title vl-feature\n * @alias module:feature/feature\n * @vueProto\n *\n * @vueSlot default [scoped] Default **scoped** slot with current feature state: `id`, `properties`, GeoJSON `geometry`.\n */\nexport default {\n  name: 'vl-feature',\n  mixins: [olCmp, useMapCmp, geometryContainer, stylesContainer, projTransforms],\n  props,\n  computed,\n  methods,\n  watch,\n  created () {\n    Object.defineProperties(this, /** @lends module:feature/feature# */{\n      /**\n       * Reference to `ol.Feature` instance.\n       * @type {Feature|undefined}\n       */\n      $feature: {\n        enumerable: true,\n        get: () => this.$olObject,\n      },\n      /**\n       * Reference to parent `Layer` instance.\n       * @type {Layer|undefined}\n       */\n      $layer: {\n        enumerable: true,\n        get: () => this.$services && this.$services.layer,\n      },\n      /**\n       * Reference to `ol.Map` instance.\n       * @type {Map|undefined}\n       */\n      $map: {\n        enumerable: true,\n        get: () => this.$services && this.$services.map,\n      },\n      /**\n       * Reference to `ol.View` instance.\n       * @type {View|undefined}\n       */\n      $view: {\n        enumerable: true,\n        get: () => this.$services && this.$services.view,\n      },\n      /**\n       * Reference to `featuresContainer`.\n       * @type {Object|undefined}\n       */\n      $featuresContainer: {\n        enumerable: true,\n        get: () => this.$services && this.$services.featuresContainer,\n      },\n    })\n  },\n}\n\n/**\n * @return {void}\n * @private\n */\nfunction subscribeToFeatureChanges () {\n  hasFeature(this)\n\n  const getPropValue = prop => this.$feature.get(prop)\n  const ft = 100\n  // all plain properties\n  const propChanges = observableFromOlEvent(\n    this.$feature,\n    'propertychange',\n    ({ key }) => ({ prop: key, value: getPropValue(key) }),\n  ).pipe(\n    throttleTime(ft),\n    distinctUntilChanged(isEqual),\n  )\n  // id, style and other generic changes\n  const changes = observableFromOlEvent(\n    this.$feature,\n    'change',\n  ).pipe(\n    mapObs(() => Observable.create(obs => {\n      if (this.$feature.getId() !== this.id) {\n        obs.next({ prop: 'id', value: this.$feature.getId() })\n      }\n      // todo style?\n    })),\n    mergeAll(),\n    throttleTime(ft),\n    distinctUntilChanged(isEqual),\n  )\n  // all changes\n  const allChanges = mergeObs(propChanges, changes)\n\n  this.subscribeTo(allChanges, ({ prop, value }) => {\n    ++this.rev\n\n    if (prop === 'id') {\n      this.$emit(`update:${prop}`, value)\n    } else if (prop !== this.$feature.getGeometryName()) {\n      this.$emit('update:properties', Object.assign({}, this.properties, { [prop]: value }))\n    }\n  })\n}\n","<template>\n  <i :id=\"[$options.name, id].join('-')\" :class=\"[$options.name]\" style=\"display: none !important;\">\n    <slot :id=\"id\" :properties=\"properties\" :geometry=\"geometry\" :point=\"point\"/>\n  </i>\n</template>\n\n<script>\n  import Feature from 'ol/Feature'\n  import { Observable } from 'rxjs'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { distinctUntilChanged, map as mapObs, mergeAll, throttleTime } from 'rxjs/operators'\n  import uuid from 'uuid/v4'\n  import geometryContainer from '../../mixin/geometry-container'\n  import olCmp from '../../mixin/ol-cmp'\n  import projTransforms from '../../mixin/proj-transforms'\n  import stylesContainer from '../../mixin/styles-container'\n  import useMapCmp from '../../mixin/use-map-cmp'\n  import { findPointOnSurface } from '../../ol-ext/geom'\n  import observableFromOlEvent from '../../rx-ext/from-ol-event'\n  import { hasFeature, hasMap } from '../../util/assert'\n  import { isEqual, plainProps } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n\n  /**\n   * @vueProps\n   */\n  const props = /** @lends module:feature/feature# */{\n    /**\n     * Feature identifier.\n     * @type {string|number}\n     * @default UUID\n     * @vueSync\n     */\n    id: {\n      type: [String, Number],\n      default: () => uuid(),\n    },\n    /**\n     * All feature properties.\n     * @type {Object}\n     * @default {}\n     * @vueSync\n     */\n    properties: {\n      type: Object,\n      default: () => Object.create(null),\n    },\n  }\n\n  /**\n   * @vueComputed\n   */\n  const computed = /** @lends module:feature/feature# */{\n    /**\n     * **GeoJSON** encoded geometry.\n     * @type {Object|undefined}\n     */\n    geometry () {\n      if (this.rev && this.resolvedDataProjection && this.$geometry) {\n        return this.writeGeometryInDataProj(this.$geometry)\n      }\n    },\n    /**\n     * @return {number[]|undefined}\n     */\n    point () {\n      if (this.pointViewProj && this.resolvedDataProjection) {\n        return this.pointToDataProj(this.pointViewProj)\n      }\n    },\n    geometryViewProj () {\n      if (this.rev && this.resolvedDataProjection && this.$geometry) {\n        return this.writeGeometryInViewProj(this.$geometry)\n      }\n    },\n    pointViewProj () {\n      if (this.rev && this.$geometry) {\n        return findPointOnSurface(this.$geometry)\n      }\n    },\n  }\n\n  /**\n   * @vueMethods\n   */\n  const methods = /** @lends module:feature/feature# */{\n    /**\n     * Create feature without inner style applying, feature level style\n     * will be applied in the layer level style function.\n     * @return {Feature}\n     * @protected\n     */\n    createOlObject () {\n      let feature = new Feature(this.properties)\n      feature.setId(this.id)\n      feature.setGeometry(this.$geometry)\n\n      return feature\n    },\n    /**\n     * @return {{\n     *     getGeometry: function(): (Geometry|undefined),\n     *     setGeometry: function((Geometry|undefined)): void\n     *   }|Feature|undefined}\n     * @protected\n     */\n    getGeometryTarget () {\n      return this.$feature\n    },\n    /**\n     * @return {Object}\n     * @protected\n     */\n    getServices () {\n      const vm = this\n\n      return mergeDescriptors(\n        this::olCmp.methods.getServices(),\n        this::geometryContainer.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n        {\n          get feature () { return vm.$feature },\n        },\n      )\n    },\n    /**\n     * @return {Feature|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$feature\n    },\n    /**\n     * Checks if feature lies at `pixel`.\n     * @param {number[]} pixel\n     * @return {boolean}\n     */\n    isAtPixel (pixel) {\n      hasMap(this)\n\n      return this.$map.forEachFeatureAtPixel(\n        pixel,\n        f => f === this.$feature,\n        { layerFilter: l => l === this.$layer },\n      )\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this.$featuresContainer && this.$featuresContainer.addFeature(this)\n      this.subscribeAll()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.unsubscribeAll()\n      this.$featuresContainer && this.$featuresContainer.removeFeature(this)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToFeatureChanges()\n    },\n  }\n\n  const watch = {\n    /**\n     * @param {string|number} value\n     */\n    id (value) {\n      if (this.$feature && value !== this.$feature.getId()) {\n        this.$feature.setId(value)\n      }\n    },\n    /**\n     * @param {Object} value\n     */\n    properties (value) {\n      value = plainProps(value)\n      if (this.$feature && !isEqual(value, plainProps(this.$feature.getProperties()))) {\n        this.$feature.setProperties(plainProps(value))\n      }\n    },\n  }\n\n  /**\n   * A vector object for geographic features with a geometry and other attribute properties,\n   * similar to the features in vector file formats like **GeoJSON**.\n   *\n   * @title vl-feature\n   * @alias module:feature/feature\n   * @vueProto\n   *\n   * @vueSlot default [scoped] Default **scoped** slot with current feature state: `id`, `properties`, GeoJSON `geometry`.\n   */\n  export default {\n    name: 'vl-feature',\n    mixins: [olCmp, useMapCmp, geometryContainer, stylesContainer, projTransforms],\n    props,\n    computed,\n    methods,\n    watch,\n    created () {\n      Object.defineProperties(this, /** @lends module:feature/feature# */{\n        /**\n         * Reference to `ol.Feature` instance.\n         * @type {Feature|undefined}\n         */\n        $feature: {\n          enumerable: true,\n          get: () => this.$olObject,\n        },\n        /**\n         * Reference to parent `Layer` instance.\n         * @type {Layer|undefined}\n         */\n        $layer: {\n          enumerable: true,\n          get: () => this.$services && this.$services.layer,\n        },\n        /**\n         * Reference to `ol.Map` instance.\n         * @type {Map|undefined}\n         */\n        $map: {\n          enumerable: true,\n          get: () => this.$services && this.$services.map,\n        },\n        /**\n         * Reference to `ol.View` instance.\n         * @type {View|undefined}\n         */\n        $view: {\n          enumerable: true,\n          get: () => this.$services && this.$services.view,\n        },\n        /**\n         * Reference to `featuresContainer`.\n         * @type {Object|undefined}\n         */\n        $featuresContainer: {\n          enumerable: true,\n          get: () => this.$services && this.$services.featuresContainer,\n        },\n      })\n    },\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  function subscribeToFeatureChanges () {\n    hasFeature(this)\n\n    const getPropValue = prop => this.$feature.get(prop)\n    const ft = 100\n    // all plain properties\n    const propChanges = observableFromOlEvent(\n      this.$feature,\n      'propertychange',\n      ({ key }) => ({ prop: key, value: getPropValue(key) }),\n    ).pipe(\n      throttleTime(ft),\n      distinctUntilChanged(isEqual),\n    )\n    // id, style and other generic changes\n    const changes = observableFromOlEvent(\n      this.$feature,\n      'change',\n    ).pipe(\n      mapObs(() => Observable.create(obs => {\n        if (this.$feature.getId() !== this.id) {\n          obs.next({ prop: 'id', value: this.$feature.getId() })\n        }\n        // todo style?\n      })),\n      mergeAll(),\n      throttleTime(ft),\n      distinctUntilChanged(isEqual),\n    )\n    // all changes\n    const allChanges = mergeObs(propChanges, changes)\n\n    this.subscribeTo(allChanges, ({ prop, value }) => {\n      ++this.rev\n\n      if (prop === 'id') {\n        this.$emit(`update:${prop}`, value)\n      } else if (prop !== this.$feature.getGeometryName()) {\n        this.$emit('update:properties', Object.assign({}, this.properties, { [prop]: value }))\n      }\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Feature from './feature.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Feature, options)\n\n  Vue.component(Feature.name, Feature)\n}\n\nexport default plugin\n\nexport {\n  Feature,\n  plugin as install,\n}\n"],"names":["props","id","type","String","Number","default","uuid","properties","Object","computed","geometry","rev","resolvedDataProjection","$geometry","writeGeometryInDataProj","point","pointViewProj","pointToDataProj","geometryViewProj","writeGeometryInViewProj","findPointOnSurface","methods","createOlObject","feature","Feature","setId","setGeometry","getGeometryTarget","$feature","getServices","vm","mergeDescriptors","olCmp","geometryContainer","stylesContainer","getStyleTarget","isAtPixel","pixel","hasMap","$map","forEachFeatureAtPixel","f","layerFilter","l","$layer","mount","$featuresContainer","addFeature","subscribeAll","unmount","unsubscribeAll","removeFeature","subscribeToFeatureChanges","watch","value","getId","plainProps","isEqual","getProperties","setProperties","name","mixins","useMapCmp","projTransforms","created","enumerable","get","$olObject","$services","layer","map","$view","view","featuresContainer","hasFeature","getPropValue","prop","ft","propChanges","observableFromOlEvent","key","pipe","throttleTime","distinctUntilChanged","changes","mapObs","Observable","create","obs","next","mergeAll","allChanges","mergeObs","subscribeTo","$emit","getGeometryName","plugin","Vue","options","installed","pick","component"],"mappings":"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"}