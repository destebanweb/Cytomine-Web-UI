/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.4
 * @license MIT
 * @copyright (c) 2017-2019, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import { merge } from 'rxjs/_esm5/internal/observable/merge';
import { debounceTime } from 'rxjs/_esm5/internal/operators/debounceTime';
import { tap } from 'rxjs/_esm5/internal/operators/tap';
import { SourceCollectionAdapter } from '../ol-ext/collection';
import observableFromOlEvent from '../rx-ext/from-ol-event';
import { hasSource } from '../util/assert';
import mergeDescriptors from '../util/multi-merge-descriptors';
import featuresContainer from './features-container';
import projTransforms from './proj-transforms';
import source from './source';

var props = {
  useSpatialIndex: {
    type: Boolean,
    default: true
  }
};
var computed = {
  featuresViewProj: function featuresViewProj() {
    if (this.rev && this.resolvedDataProjection && this.$source) {
      return this.getFeatures().map(this.writeFeatureInViewProj.bind(this));
    }

    return [];
  }
};
var methods = {
  /**
   * @return {void}
   */
  clear: function clear() {
    featuresContainer.methods.clearFeatures.call(this);
  },

  /**
   * @return {SourceCollectionAdapter}
   * @protected
   */
  getFeaturesTarget: function getFeaturesTarget() {
    if (this._featuresTarget == null && this.$source) {
      this._featuresTarget = new SourceCollectionAdapter(this.$source);
    }

    return this._featuresTarget;
  },

  /**
   * @return {Object}
   * @protected
   */
  getServices: function getServices() {
    return mergeDescriptors(source.methods.getServices.call(this), featuresContainer.methods.getServices.call(this));
  },

  /**
   * @return {Promise}
   * @protected
   */
  init: function init() {
    return source.methods.init.call(this);
  },

  /**
   * @return {void|Promise<void>}
   * @protected
   */
  deinit: function deinit() {
    return source.methods.deinit.call(this);
  },

  /**
   * @return {void}
   * @protected
   */
  mount: function mount() {
    source.methods.mount.call(this);
  },

  /**
   * @return {void}
   * @protected
   */
  unmount: function unmount() {
    this.clear();
    source.methods.unmount.call(this);
  },

  /**
   * @return {void}
   * @protected
   */
  subscribeAll: function subscribeAll() {
    subscribeToSourceChanges.call(this);
  },

  /**
   * @param feature
   * @return {ReadonlyArray<any>}
   * @protected
   */
  writeFeatureInDataProj: function writeFeatureInDataProj(feature) {
    return projTransforms.methods.writeFeatureInDataProj.call(this, feature);
  },

  /**
   * @param feature
   * @return {ReadonlyArray<any>}
   * @protected
   */
  writeGeometryInViewProj: function writeGeometryInViewProj(feature) {
    return projTransforms.methods.writeFeatureInViewProj.call(this, feature);
  }
};
var vectorSource = {
  mixins: [source, featuresContainer, projTransforms],
  props: props,
  computed: computed,
  methods: methods,
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        class: this.$options.name
      };
    }
  }
};

function subscribeToSourceChanges() {
  var _this = this;

  hasSource(this);
  var add = observableFromOlEvent(this.$source, 'addfeature').pipe(tap(function (_ref) {
    var feature = _ref.feature;

    _this.addFeature(feature);
  }));
  var remove = observableFromOlEvent(this.$source, 'removefeature').pipe(tap(function (_ref2) {
    var feature = _ref2.feature;

    _this.removeFeature(feature);
  }));
  var changeFeature = observableFromOlEvent(this.$source, 'changefeature');
  var events = merge(add, remove, changeFeature);
  this.subscribeTo(events, function (evt) {
    ++_this.rev;

    _this.$emit(evt.type, evt);
  }); // emit event to allow `sync` modifier

  this.subscribeTo(events.pipe(debounceTime(100)), function () {
    _this.$emit('update:features', _this.getFeatures().map(_this.writeFeatureInDataProj.bind(_this)));
  });
}

export default vectorSource;
