/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.4
 * @license MIT
 * @copyright (c) 2017-2019, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import _objectSpread from '@babel/runtime-corejs2/helpers/esm/objectSpread';
import _JSON$stringify from '@babel/runtime-corejs2/core-js/json/stringify';
import _typeof from '@babel/runtime-corejs2/helpers/esm/typeof';
import { reduce } from '../util/minilo';

var _cleanExtParams = function cleanExtParams(params) {
  return reduce(params, function (params, value, key) {
    var filterKeys = ['FORMAT', 'F', 'LAYERS', 'LAYERDEFS', 'DYNAMICLAYERS', 'DPI', 'TRANSPARENT', 'TIME', 'LAYERTIMEOPTIONS', 'GDBVERSION', 'MAPSCALE', 'ROTATION', 'DATUMTRANSFORMATIONS', 'MAPRANGEVALUES', 'LAYERRANGEVALUES', 'LAYERPARAMETERVALUES', 'HISTORICMOMENT'];
    key = key.toUpperCase();

    if (filterKeys.includes(key)) {
      return params;
    }

    params[key] = value;
    return params;
  }, {});
};

var serialize = function serialize(value) {
  if (value == null) return value;
  return _typeof(value) === 'object' ? _JSON$stringify(value) : value;
};

var props = {
  /**
   * Extra WMS request parameters
   */
  extParams: Object,
  format: {
    type: String,
    default: 'PNG32'
  },
  layers: String,
  layerDefs: [Object, String],
  dynamicLayers: [Object, String],
  dpi: Number,
  transparent: {
    type: Boolean,
    default: true
  },
  time: String,
  layerTimeOptions: [Object, String],
  gdbVersion: String,
  mapScale: String,
  rotation: Number,
  datumTransformations: [Array, String],
  mapRangeValues: [Array, String],
  layerRangeValues: [Array, String],
  layerParameterValues: [Array, String],
  historicMoment: Number
};
var computed = {
  cleanExtParams: function cleanExtParams() {
    return this.extParams ? _cleanExtParams(this.extParams) : undefined;
  },
  allParams: function allParams() {
    return _objectSpread({}, this.cleanExtParams, {
      LAYERS: this.layers,
      FORMAT: this.format,
      LAYERDEFS: serialize(this.layerDefs),
      DYNAMICLAYERS: serialize(this.dynamicLayers),
      DPI: this.dpi,
      TRANSPARENT: this.transparent,
      TIME: serialize(this.time),
      LAYERTIMEOPTIONS: serialize(this.layerTimeOptions),
      GDBVERSION: this.gdbVersion,
      MAPSCALE: this.mapScale,
      ROTATION: this.rotation,
      DATUMTRANSFORMATIONS: serialize(this.datumTransformations),
      MAPRANGEVALUES: serialize(this.mapRangeValues),
      LAYERRANGEVALUES: serialize(this.layerRangeValues),
      LAYERPARAMETERVALUES: serialize(this.layerParameterValues),
      HISTORICMOMENT: serialize(this.historicMoment)
    });
  }
};
var methods = {};
var watch = {
  layers: function layers(LAYERS) {
    this.$source && this.$source.updateParams({
      LAYERS: LAYERS
    });
  },
  format: function format(FORMAT) {
    this.$source && this.$source.updateParams({
      FORMAT: FORMAT
    });
  },
  layerDefs: function layerDefs(LAYERDEFS) {
    this.$source && this.$source.updateParams({
      LAYERDEFS: serialize(LAYERDEFS)
    });
  },
  dynamicLayers: function dynamicLayers(DYNAMICLAYERS) {
    this.$source && this.$source.updateParams({
      DYNAMICLAYERS: serialize(DYNAMICLAYERS)
    });
  },
  dpi: function dpi(DPI) {
    this.$source && this.$source.updateParams({
      DPI: DPI
    });
  },
  transparent: function transparent(TRANSPARENT) {
    this.$source && this.$source.updateParams({
      TRANSPARENT: TRANSPARENT
    });
  },
  time: function time(TIME) {
    this.$source && this.$source.updateParams({
      TIME: serialize(TIME)
    });
  },
  layerTimeOptions: function layerTimeOptions(LAYERTIMEOPTIONS) {
    this.$source && this.$source.updateParams({
      LAYERTIMEOPTIONS: serialize(LAYERTIMEOPTIONS)
    });
  },
  gdbVersion: function gdbVersion(GDBVERSION) {
    this.$source && this.$source.updateParams({
      GDBVERSION: GDBVERSION
    });
  },
  mapScale: function mapScale(MAPSCALE) {
    this.$source && this.$source.updateParams({
      MAPSCALE: MAPSCALE
    });
  },
  rotation: function rotation(ROTATION) {
    this.$source && this.$source.updateParams({
      ROTATION: ROTATION
    });
  },
  datumTransformations: function datumTransformations(DATUMTRANSFORMATIONS) {
    this.$source && this.$source.updateParams({
      DATUMTRANSFORMATIONS: serialize(DATUMTRANSFORMATIONS)
    });
  },
  mapRangeValues: function mapRangeValues(MAPRANGEVALUES) {
    this.$source && this.$source.updateParams({
      MAPRANGEVALUES: serialize(MAPRANGEVALUES)
    });
  },
  layerRangeValues: function layerRangeValues(LAYERRANGEVALUES) {
    this.$source && this.$source.updateParams({
      LAYERRANGEVALUES: serialize(LAYERRANGEVALUES)
    });
  },
  layerParameterValues: function layerParameterValues(LAYERPARAMETERVALUES) {
    this.$source && this.$source.updateParams({
      LAYERPARAMETERVALUES: serialize(LAYERPARAMETERVALUES)
    });
  },
  historicMoment: function historicMoment(HISTORICMOMENT) {
    this.$source && this.$source.updateParams({
      HISTORICMOMENT: HISTORICMOMENT
    });
  },
  extParams: function extParams(value) {
    this.$source && this.$source.updateParams(value ? _cleanExtParams(value) : undefined);
  }
};
var arcgisSource = {
  props: props,
  computed: computed,
  methods: methods,
  watch: watch
};

export default arcgisSource;
