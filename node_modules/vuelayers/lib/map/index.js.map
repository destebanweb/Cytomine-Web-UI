{"version":3,"file":"index.js","sources":["src/component/map/map.vue?rollup-plugin-vue=script.js","src/component/map/map.vue","src/component/map/view.vue?rollup-plugin-vue=script.js","src/component/map/view.vue","src/component/map/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport { defaults as createDefaultControls } from 'ol/control'\nimport { defaults as createDefaultInteractions } from 'ol/interaction'\nimport VectorLayer from 'ol/layer/Vector'\nimport Collection from 'ol/Collection'\nimport Map from 'ol/Map'\nimport WebGLMap from 'ol/WebGLMap'\nimport VectorSource from 'ol/source/Vector'\nimport View from 'ol/View'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { distinctUntilChanged, map as mapObs, throttleTime } from 'rxjs/operators'\nimport Vue from 'vue'\nimport { olCmp, overlaysContainer, layersContainer, interactionsContainer, featuresContainer } from '../../mixin'\nimport projTransforms from '../../mixin/proj-transforms'\nimport { RENDERER_TYPE, getFeatureId, IndexedCollectionAdapter } from '../../ol-ext'\nimport { observableFromOlEvent } from '../../rx-ext'\nimport { hasMap, hasView } from '../../util/assert'\nimport { isEqual } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\nconst props = {\n  /**\n   * Options for default controls added to the map by default. Set to `false` to disable all map controls. Object\n   * value is used to configure controls.\n   * @type {Object|boolean}\n   * @todo remove when vl-control-* components will be ready\n   */\n  controls: {\n    type: [Object, Boolean],\n    default: true,\n  },\n  /**\n   * The element to listen to keyboard events on. For example, if this option is set to `document` the keyboard\n   * interactions will always trigger. If this option is not specified, the element the library listens to keyboard\n   * events on is the component root element.\n   * @type {string|Element|Document}\n   */\n  keyboardEventTarget: [String, Element, Document],\n  /**\n   * When set to `true`, tiles will be loaded during animations.\n   * @type {boolean}\n   */\n  loadTilesWhileAnimating: {\n    type: Boolean,\n    default: false,\n  },\n  /**\n   * When set to `true`, tiles will be loaded while interacting with the map.\n   * @type {boolean}\n   */\n  loadTilesWhileInteracting: {\n    type: Boolean,\n    default: false,\n  },\n  /**\n   * The minimum distance in pixels the cursor must move to be detected as a map move event instead of a click.\n   * Increasing this value can make it easier to click on the map.\n   * @type {Number}\n   */\n  moveTolerance: {\n    type: Number,\n    default: 1,\n  },\n  /**\n   * The ratio between physical pixels and device-independent pixels (dips) on the device.\n   * @type {number}\n   */\n  pixelRatio: {\n    type: Number,\n    default: () => window.devicePixelRatio || 1,\n  },\n  /**\n   * Renderer. By default, **Canvas** and **WebGL** renderers are tested for support in that order,\n   * and the first supported used. **Note** that the **Canvas** renderer fully supports vector data,\n   * but **WebGL** can only render **Point** geometries.\n   * @type {string|string[]}\n   * @default ['canvas', 'webgl']\n   */\n  renderer: {\n    type: String,\n    default: RENDERER_TYPE.CANVAS,\n    validator: value => Object.values(RENDERER_TYPE).includes(value),\n  },\n  /**\n   * Root element `tabindex` attribute value. Value should be provided to allow keyboard events on map.\n   * @type {number|string}\n   */\n  tabindex: [String, Number],\n  /**\n   * Projection for input/output coordinates in plain data.\n   * @type {string}\n   */\n  dataProjection: String,\n  wrapX: {\n    type: Boolean,\n    default: true,\n  },\n}\n\nconst computed = {\n  mapCtor () {\n    switch (this.renderer) {\n      case RENDERER_TYPE.WEBGL:\n        return WebGLMap\n      case RENDERER_TYPE.CANVAS:\n      default:\n        return Map\n    }\n  },\n}\n\nconst methods = {\n  /**\n   * @return {Map}\n   * @protected\n   */\n  createOlObject () {\n    /* eslint-disable-next-line new-cap */\n    const map = new this.mapCtor({\n      loadTilesWhileAnimating: this.loadTilesWhileAnimating,\n      loadTilesWhileInteracting: this.loadTilesWhileInteracting,\n      pixelRatio: this.pixelRatio,\n      moveTolerance: this.moveTolerance,\n      keyboardEventTarget: this.keyboardEventTarget,\n      controls: this._controls,\n      interactions: this._interactions,\n      layers: this._layers,\n      overlays: this._overlays,\n      view: this._view,\n    })\n    map.set('dataProjection', this.dataProjection)\n    this._defaultOverlay.setMap(map)\n\n    return map\n  },\n  /**\n   * @return {IndexedCollectionAdapter}\n   * @protected\n   */\n  getLayersTarget () {\n    hasMap(this)\n\n    if (this._layersTarget == null) {\n      this._layersTarget = new IndexedCollectionAdapter(\n        this.$map.getLayers(),\n        layer => layer.get('id'),\n      )\n    }\n\n    return this._layersTarget\n  },\n  /**\n   * @return {IndexedCollectionAdapter}\n   * @protected\n   */\n  getInteractionsTarget () {\n    hasMap(this)\n\n    if (this._interactionsTarget == null) {\n      this._interactionsTarget = new IndexedCollectionAdapter(\n        this.$map.getInteractions(),\n        interaction => interaction.get('id'),\n      )\n    }\n\n    return this._interactionsTarget\n  },\n  /**\n   * @return {function}\n   * @protected\n   */\n  getDefaultInteractionsSorter () {\n    // sort interactions by priority in asc order\n    // the higher the priority, the earlier the interaction handles the event\n    return (a, b) => {\n      let ap = a.get('priority') || 0\n      let bp = b.get('priority') || 0\n      return ap === bp ? 0 : ap - bp\n    }\n  },\n  /**\n   * @return {SourceCollectionAdapter}\n   * @protected\n   */\n  getFeaturesTarget () {\n    if (this._featuresTarget == null) {\n      this._featuresTarget = new IndexedCollectionAdapter(\n        this._defaultOverlayFeatures,\n        feature => getFeatureId(feature)\n      )\n    }\n\n    return this._featuresTarget\n  },\n  /**\n   * @return {IndexedCollectionAdapter}\n   * @protected\n   */\n  getOverlaysTarget () {\n    hasMap(this)\n\n    if (this._overlaysTarget == null) {\n      this._overlaysTarget = new IndexedCollectionAdapter(\n        this.$map.getOverlays(),\n        overlay => overlay.getId(),\n      )\n    }\n\n    return this._overlaysTarget\n  },\n  /**\n   * @param {number[]} pixel\n   * @return {number[]} Coordinates in the map view projection.\n   */\n  getCoordinateFromPixel (pixel) {\n    hasMap(this)\n\n    let coordinate = this.$map.getCoordinateFromPixel(pixel)\n    return this.pointToDataProj(coordinate)\n  },\n  /**\n   * @returns {Object}\n   * @protected\n   */\n  getServices () {\n    const vm = this\n\n    return mergeDescriptors(\n      this::olCmp.methods.getServices(),\n      this::layersContainer.methods.getServices(),\n      this::interactionsContainer.methods.getServices(),\n      this::overlaysContainer.methods.getServices(),\n      this::featuresContainer.methods.getServices(),\n      {\n        get map () { return vm.$map },\n        get view () { return vm.$view },\n        get viewContainer () { return vm },\n      },\n    )\n  },\n  /**\n   * Triggers focus on map container.\n   * @return {void}\n   */\n  focus () {\n    this.$el.focus()\n  },\n  /**\n   * @param {number[]} pixel\n   * @param {function((Feature), ?Layer): *} callback\n   * @param {Object} [opts]\n   * @return {*|undefined}\n   */\n  forEachFeatureAtPixel (pixel, callback, opts = {}) {\n    hasMap(this)\n    return this.$map.forEachFeatureAtPixel(pixel, callback, opts)\n  },\n  /**\n   * @param {number[]} pixel\n   * @param {function(Layer, ?(number[]|Uint8Array)): *} callback\n   * @param {function(Layer): boolean} [layerFilter]\n   * @return {*|undefined}\n   */\n  forEachLayerAtPixel (pixel, callback, layerFilter) {\n    hasMap(this)\n    return this.$map.forEachLayerAtPixel(pixel, callback, undefined, layerFilter)\n  },\n  /**\n   * @param {View|Vue|undefined} view\n   * @return {void}\n   * @protected\n   */\n  setView (view) {\n    view = view instanceof Vue ? view.$view : view\n    view || (view = new View())\n\n    if (view !== this._view) {\n      this._view = view\n    }\n    if (this.$map && view !== this.$map.getView()) {\n      this.$map.setView(view)\n    }\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  mount () {\n    hasMap(this)\n    this.$map.setTarget(this.$el)\n    this.subscribeAll()\n    this.updateSize()\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  unmount () {\n    hasMap(this)\n\n    this.clearLayers()\n    this.clearInteractions()\n    this.clearOverlays()\n\n    this.unsubscribeAll()\n    this.$map.setTarget(undefined)\n  },\n  /**\n   * Updates map size and re-renders map.\n   * @return {Promise}\n   */\n  refresh () {\n    this.updateSize()\n\n    return this.render()\n      .then(() => this::olCmp.methods.refresh())\n  },\n  /**\n   * @return {Promise}\n   */\n  render () {\n    return new Promise(resolve => {\n      hasMap(this)\n      this.$map.once('postrender', () => resolve())\n      this.$map.render()\n    })\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  subscribeAll () {\n    this::subscribeToMapEvents()\n  },\n  /**\n   * Updates map size.\n   * @return {void}\n   */\n  updateSize () {\n    hasMap(this)\n    this.$map.updateSize()\n  },\n}\n\nconst watch = {\n  ...makeWatchers([\n    'keyboardEventTarget',\n    'loadTilesWhileAnimating',\n    'loadTilesWhileInteracting',\n    'moveTolerance',\n    'pixelRatio',\n    'renderer',\n  ], () => olCmp.methods.scheduleRecreate),\n  controls (value) {\n    if (value === false) {\n      this._controls.clear()\n      return\n    }\n\n    value = typeof value === 'object' ? value : undefined\n    this._controls.clear()\n    this._controls.extend(createDefaultControls(value).getArray())\n  },\n  wrapX (value) {\n    if (this._defaultOverlay != null) {\n      let source = new VectorSource({\n        features: this._defaultOverlayFeatures,\n        wrapX: value,\n      })\n      this._defaultOverlay.setSource(source)\n    }\n  },\n  dataProjection (value) {\n    if (this.$map) {\n      this.$map.set('dataProjection', value)\n      this.scheduleRefresh()\n    }\n  },\n}\n\n/**\n * Container for **layers**, **interactions**, **controls** and **overlays**. It responsible for viewport\n * rendering and low level interaction events.\n *\n * @title vl-map\n * @alias module:map/map\n * @vueProto\n *\n * @fires module:map/map#click\n * @fires module:map/map#dblclick\n * @fires module:map/map#singleclick\n * @fires module:map/map#pointerdrag\n * @fires module:map/map#pointermove\n * @fires module:map/map#movestart\n * @fires module:map/map#moveend\n * @fires module:map/map#postrender\n * @fires module:map/map#precompose\n * @fires module:map/map#postcompose\n *\n * @vueSlot default Default slot for all child components.\n */\nexport default {\n  name: 'vl-map',\n  mixins: [\n    olCmp,\n    layersContainer,\n    interactionsContainer,\n    overlaysContainer,\n    featuresContainer,\n    projTransforms,\n  ],\n  props,\n  computed,\n  methods,\n  watch,\n  created () {\n    this._view = new View()\n    this._controls = this.controls !== false\n      ? createDefaultControls(typeof this.controls === 'object' ? this.controls : undefined)\n      : new Collection()\n    this._interactions = createDefaultInteractions()\n    this._layers = new Collection()\n    this._overlays = new Collection()\n    // prepare default overlay\n    this._defaultOverlayFeatures = new Collection()\n    this._defaultOverlay = new VectorLayer({\n      source: new VectorSource({\n        features: this._defaultOverlayFeatures,\n        wrapX: this.wrapX,\n      }),\n    })\n\n    Object.defineProperties(this, /** @lends module:map/map# */{\n      /**\n       * OpenLayers map instance.\n       * @type {Map|undefined}\n       */\n      $map: {\n        enumerable: true,\n        get: () => this.$olObject,\n      },\n      /**\n       * OpenLayers view instance.\n       * @type {View|undefined}\n       */\n      $view: {\n        enumerable: true,\n        get: () => this._view,\n      },\n    })\n  },\n}\n\n/**\n * Subscribe to OL map events.\n *\n * @return {void}\n * @private\n */\nfunction subscribeToMapEvents () {\n  hasMap(this)\n  hasView(this)\n\n  const ft = 100\n  // pointer\n  const pointerEvents = mergeObs(\n    observableFromOlEvent(this.$map, [\n      'click',\n      'dblclick',\n      'singleclick',\n    ]),\n    observableFromOlEvent(this.$map, [\n      'pointerdrag',\n      'pointermove',\n    ]).pipe(\n      throttleTime(ft),\n      distinctUntilChanged((a, b) => isEqual(a.coordinate, b.coordinate)),\n    ),\n  ).pipe(\n    mapObs(evt => ({\n      ...evt,\n      coordinate: this.pointToDataProj(evt.coordinate),\n    })),\n  )\n  // other\n  const otherEvents = observableFromOlEvent(this.$map, [\n    'movestart',\n    'moveend',\n    'postrender',\n    'rendercomplete',\n    'precompose',\n    'postcompose',\n  ])\n\n  const events = mergeObs(pointerEvents, otherEvents)\n\n  this.subscribeTo(events, evt => this.$emit(evt.type, evt))\n}\n\n/**\n * A click with no dragging. A double click will fire two of this.\n * @event module:map/map#click\n * @type {MapBrowserEvent}\n */\n/**\n * A true double click, with no dragging.\n * @event module:map/map#dblclick\n * @type {MapBrowserEvent}\n */\n","<template>\n  <div :class=\"[$options.name]\" :tabindex=\"tabindex\">\n    <slot/>\n  </div>\n</template>\n\n<script>\n  import { defaults as createDefaultControls } from 'ol/control'\n  import { defaults as createDefaultInteractions } from 'ol/interaction'\n  import VectorLayer from 'ol/layer/Vector'\n  import Collection from 'ol/Collection'\n  import Map from 'ol/Map'\n  import WebGLMap from 'ol/WebGLMap'\n  import VectorSource from 'ol/source/Vector'\n  import View from 'ol/View'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { distinctUntilChanged, map as mapObs, throttleTime } from 'rxjs/operators'\n  import Vue from 'vue'\n  import { olCmp, overlaysContainer, layersContainer, interactionsContainer, featuresContainer } from '../../mixin'\n  import projTransforms from '../../mixin/proj-transforms'\n  import { RENDERER_TYPE, getFeatureId, IndexedCollectionAdapter } from '../../ol-ext'\n  import { observableFromOlEvent } from '../../rx-ext'\n  import { hasMap, hasView } from '../../util/assert'\n  import { isEqual } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  const props = {\n    /**\n     * Options for default controls added to the map by default. Set to `false` to disable all map controls. Object\n     * value is used to configure controls.\n     * @type {Object|boolean}\n     * @todo remove when vl-control-* components will be ready\n     */\n    controls: {\n      type: [Object, Boolean],\n      default: true,\n    },\n    /**\n     * The element to listen to keyboard events on. For example, if this option is set to `document` the keyboard\n     * interactions will always trigger. If this option is not specified, the element the library listens to keyboard\n     * events on is the component root element.\n     * @type {string|Element|Document}\n     */\n    keyboardEventTarget: [String, Element, Document],\n    /**\n     * When set to `true`, tiles will be loaded during animations.\n     * @type {boolean}\n     */\n    loadTilesWhileAnimating: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * When set to `true`, tiles will be loaded while interacting with the map.\n     * @type {boolean}\n     */\n    loadTilesWhileInteracting: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * The minimum distance in pixels the cursor must move to be detected as a map move event instead of a click.\n     * Increasing this value can make it easier to click on the map.\n     * @type {Number}\n     */\n    moveTolerance: {\n      type: Number,\n      default: 1,\n    },\n    /**\n     * The ratio between physical pixels and device-independent pixels (dips) on the device.\n     * @type {number}\n     */\n    pixelRatio: {\n      type: Number,\n      default: () => window.devicePixelRatio || 1,\n    },\n    /**\n     * Renderer. By default, **Canvas** and **WebGL** renderers are tested for support in that order,\n     * and the first supported used. **Note** that the **Canvas** renderer fully supports vector data,\n     * but **WebGL** can only render **Point** geometries.\n     * @type {string|string[]}\n     * @default ['canvas', 'webgl']\n     */\n    renderer: {\n      type: String,\n      default: RENDERER_TYPE.CANVAS,\n      validator: value => Object.values(RENDERER_TYPE).includes(value),\n    },\n    /**\n     * Root element `tabindex` attribute value. Value should be provided to allow keyboard events on map.\n     * @type {number|string}\n     */\n    tabindex: [String, Number],\n    /**\n     * Projection for input/output coordinates in plain data.\n     * @type {string}\n     */\n    dataProjection: String,\n    wrapX: {\n      type: Boolean,\n      default: true,\n    },\n  }\n\n  const computed = {\n    mapCtor () {\n      switch (this.renderer) {\n        case RENDERER_TYPE.WEBGL:\n          return WebGLMap\n        case RENDERER_TYPE.CANVAS:\n        default:\n          return Map\n      }\n    },\n  }\n\n  const methods = {\n    /**\n     * @return {Map}\n     * @protected\n     */\n    createOlObject () {\n      /* eslint-disable-next-line new-cap */\n      const map = new this.mapCtor({\n        loadTilesWhileAnimating: this.loadTilesWhileAnimating,\n        loadTilesWhileInteracting: this.loadTilesWhileInteracting,\n        pixelRatio: this.pixelRatio,\n        moveTolerance: this.moveTolerance,\n        keyboardEventTarget: this.keyboardEventTarget,\n        controls: this._controls,\n        interactions: this._interactions,\n        layers: this._layers,\n        overlays: this._overlays,\n        view: this._view,\n      })\n      map.set('dataProjection', this.dataProjection)\n      this._defaultOverlay.setMap(map)\n\n      return map\n    },\n    /**\n     * @return {IndexedCollectionAdapter}\n     * @protected\n     */\n    getLayersTarget () {\n      hasMap(this)\n\n      if (this._layersTarget == null) {\n        this._layersTarget = new IndexedCollectionAdapter(\n          this.$map.getLayers(),\n          layer => layer.get('id'),\n        )\n      }\n\n      return this._layersTarget\n    },\n    /**\n     * @return {IndexedCollectionAdapter}\n     * @protected\n     */\n    getInteractionsTarget () {\n      hasMap(this)\n\n      if (this._interactionsTarget == null) {\n        this._interactionsTarget = new IndexedCollectionAdapter(\n          this.$map.getInteractions(),\n          interaction => interaction.get('id'),\n        )\n      }\n\n      return this._interactionsTarget\n    },\n    /**\n     * @return {function}\n     * @protected\n     */\n    getDefaultInteractionsSorter () {\n      // sort interactions by priority in asc order\n      // the higher the priority, the earlier the interaction handles the event\n      return (a, b) => {\n        let ap = a.get('priority') || 0\n        let bp = b.get('priority') || 0\n        return ap === bp ? 0 : ap - bp\n      }\n    },\n    /**\n     * @return {SourceCollectionAdapter}\n     * @protected\n     */\n    getFeaturesTarget () {\n      if (this._featuresTarget == null) {\n        this._featuresTarget = new IndexedCollectionAdapter(\n          this._defaultOverlayFeatures,\n          feature => getFeatureId(feature)\n        )\n      }\n\n      return this._featuresTarget\n    },\n    /**\n     * @return {IndexedCollectionAdapter}\n     * @protected\n     */\n    getOverlaysTarget () {\n      hasMap(this)\n\n      if (this._overlaysTarget == null) {\n        this._overlaysTarget = new IndexedCollectionAdapter(\n          this.$map.getOverlays(),\n          overlay => overlay.getId(),\n        )\n      }\n\n      return this._overlaysTarget\n    },\n    /**\n     * @param {number[]} pixel\n     * @return {number[]} Coordinates in the map view projection.\n     */\n    getCoordinateFromPixel (pixel) {\n      hasMap(this)\n\n      let coordinate = this.$map.getCoordinateFromPixel(pixel)\n      return this.pointToDataProj(coordinate)\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      const vm = this\n\n      return mergeDescriptors(\n        this::olCmp.methods.getServices(),\n        this::layersContainer.methods.getServices(),\n        this::interactionsContainer.methods.getServices(),\n        this::overlaysContainer.methods.getServices(),\n        this::featuresContainer.methods.getServices(),\n        {\n          get map () { return vm.$map },\n          get view () { return vm.$view },\n          get viewContainer () { return vm },\n        },\n      )\n    },\n    /**\n     * Triggers focus on map container.\n     * @return {void}\n     */\n    focus () {\n      this.$el.focus()\n    },\n    /**\n     * @param {number[]} pixel\n     * @param {function((Feature), ?Layer): *} callback\n     * @param {Object} [opts]\n     * @return {*|undefined}\n     */\n    forEachFeatureAtPixel (pixel, callback, opts = {}) {\n      hasMap(this)\n      return this.$map.forEachFeatureAtPixel(pixel, callback, opts)\n    },\n    /**\n     * @param {number[]} pixel\n     * @param {function(Layer, ?(number[]|Uint8Array)): *} callback\n     * @param {function(Layer): boolean} [layerFilter]\n     * @return {*|undefined}\n     */\n    forEachLayerAtPixel (pixel, callback, layerFilter) {\n      hasMap(this)\n      return this.$map.forEachLayerAtPixel(pixel, callback, undefined, layerFilter)\n    },\n    /**\n     * @param {View|Vue|undefined} view\n     * @return {void}\n     * @protected\n     */\n    setView (view) {\n      view = view instanceof Vue ? view.$view : view\n      view || (view = new View())\n\n      if (view !== this._view) {\n        this._view = view\n      }\n      if (this.$map && view !== this.$map.getView()) {\n        this.$map.setView(view)\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      hasMap(this)\n      this.$map.setTarget(this.$el)\n      this.subscribeAll()\n      this.updateSize()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      hasMap(this)\n\n      this.clearLayers()\n      this.clearInteractions()\n      this.clearOverlays()\n\n      this.unsubscribeAll()\n      this.$map.setTarget(undefined)\n    },\n    /**\n     * Updates map size and re-renders map.\n     * @return {Promise}\n     */\n    refresh () {\n      this.updateSize()\n\n      return this.render()\n        .then(() => this::olCmp.methods.refresh())\n    },\n    /**\n     * @return {Promise}\n     */\n    render () {\n      return new Promise(resolve => {\n        hasMap(this)\n        this.$map.once('postrender', () => resolve())\n        this.$map.render()\n      })\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToMapEvents()\n    },\n    /**\n     * Updates map size.\n     * @return {void}\n     */\n    updateSize () {\n      hasMap(this)\n      this.$map.updateSize()\n    },\n  }\n\n  const watch = {\n    ...makeWatchers([\n      'keyboardEventTarget',\n      'loadTilesWhileAnimating',\n      'loadTilesWhileInteracting',\n      'moveTolerance',\n      'pixelRatio',\n      'renderer',\n    ], () => olCmp.methods.scheduleRecreate),\n    controls (value) {\n      if (value === false) {\n        this._controls.clear()\n        return\n      }\n\n      value = typeof value === 'object' ? value : undefined\n      this._controls.clear()\n      this._controls.extend(createDefaultControls(value).getArray())\n    },\n    wrapX (value) {\n      if (this._defaultOverlay != null) {\n        let source = new VectorSource({\n          features: this._defaultOverlayFeatures,\n          wrapX: value,\n        })\n        this._defaultOverlay.setSource(source)\n      }\n    },\n    dataProjection (value) {\n      if (this.$map) {\n        this.$map.set('dataProjection', value)\n        this.scheduleRefresh()\n      }\n    },\n  }\n\n  /**\n   * Container for **layers**, **interactions**, **controls** and **overlays**. It responsible for viewport\n   * rendering and low level interaction events.\n   *\n   * @title vl-map\n   * @alias module:map/map\n   * @vueProto\n   *\n   * @fires module:map/map#click\n   * @fires module:map/map#dblclick\n   * @fires module:map/map#singleclick\n   * @fires module:map/map#pointerdrag\n   * @fires module:map/map#pointermove\n   * @fires module:map/map#movestart\n   * @fires module:map/map#moveend\n   * @fires module:map/map#postrender\n   * @fires module:map/map#precompose\n   * @fires module:map/map#postcompose\n   *\n   * @vueSlot default Default slot for all child components.\n   */\n  export default {\n    name: 'vl-map',\n    mixins: [\n      olCmp,\n      layersContainer,\n      interactionsContainer,\n      overlaysContainer,\n      featuresContainer,\n      projTransforms,\n    ],\n    props,\n    computed,\n    methods,\n    watch,\n    created () {\n      this._view = new View()\n      this._controls = this.controls !== false\n        ? createDefaultControls(typeof this.controls === 'object' ? this.controls : undefined)\n        : new Collection()\n      this._interactions = createDefaultInteractions()\n      this._layers = new Collection()\n      this._overlays = new Collection()\n      // prepare default overlay\n      this._defaultOverlayFeatures = new Collection()\n      this._defaultOverlay = new VectorLayer({\n        source: new VectorSource({\n          features: this._defaultOverlayFeatures,\n          wrapX: this.wrapX,\n        }),\n      })\n\n      Object.defineProperties(this, /** @lends module:map/map# */{\n        /**\n         * OpenLayers map instance.\n         * @type {Map|undefined}\n         */\n        $map: {\n          enumerable: true,\n          get: () => this.$olObject,\n        },\n        /**\n         * OpenLayers view instance.\n         * @type {View|undefined}\n         */\n        $view: {\n          enumerable: true,\n          get: () => this._view,\n        },\n      })\n    },\n  }\n\n  /**\n   * Subscribe to OL map events.\n   *\n   * @return {void}\n   * @private\n   */\n  function subscribeToMapEvents () {\n    hasMap(this)\n    hasView(this)\n\n    const ft = 100\n    // pointer\n    const pointerEvents = mergeObs(\n      observableFromOlEvent(this.$map, [\n        'click',\n        'dblclick',\n        'singleclick',\n      ]),\n      observableFromOlEvent(this.$map, [\n        'pointerdrag',\n        'pointermove',\n      ]).pipe(\n        throttleTime(ft),\n        distinctUntilChanged((a, b) => isEqual(a.coordinate, b.coordinate)),\n      ),\n    ).pipe(\n      mapObs(evt => ({\n        ...evt,\n        coordinate: this.pointToDataProj(evt.coordinate),\n      })),\n    )\n    // other\n    const otherEvents = observableFromOlEvent(this.$map, [\n      'movestart',\n      'moveend',\n      'postrender',\n      'rendercomplete',\n      'precompose',\n      'postcompose',\n    ])\n\n    const events = mergeObs(pointerEvents, otherEvents)\n\n    this.subscribeTo(events, evt => this.$emit(evt.type, evt))\n  }\n\n  /**\n   * A click with no dragging. A double click will fire two of this.\n   * @event module:map/map#click\n   * @type {MapBrowserEvent}\n   */\n  /**\n   * A true double click, with no dragging.\n   * @event module:map/map#dblclick\n   * @type {MapBrowserEvent}\n   */\n</script>\n","//\n//\n//\n//\n//\n//\n\nimport View from 'ol/View'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { distinctUntilKeyChanged, map as mapObs } from 'rxjs/operators'\nimport Vue from 'vue'\nimport { olCmp, projTransforms } from '../../mixin'\nimport { EPSG_3857, MAX_ZOOM, MIN_ZOOM, ZOOM_FACTOR } from '../../ol-ext'\nimport { observableFromOlChangeEvent } from '../../rx-ext'\nimport { hasView } from '../../util/assert'\nimport { coalesce, isEqual, isFunction, isPlainObject, noop } from '../../util/minilo'\n\n/**\n * @vueProps\n */\nconst props = /** @lends module:map/view# */{\n  /**\n   * The center coordinate in the view projection.\n   * @type {number[]}\n   * @default [0, 0]\n   * @vueSync\n   */\n  center: {\n    type: Array,\n    default: () => [0, 0],\n    validator: value => value.length === 2,\n  },\n  constrainRotation: {\n    type: [Boolean, Number],\n    default: true,\n  },\n  enableRotation: {\n    type: Boolean,\n    default: true,\n  },\n  /**\n   * The extent that constrains the center defined in the view projection,\n   * in other words, center cannot be set outside this extent.\n   * @default undefined\n   */\n  extent: {\n    type: Array,\n    validator: value => value.length === 4,\n  },\n  maxResolution: Number,\n  minResolution: Number,\n  /**\n   * @default 28\n   */\n  maxZoom: {\n    type: Number,\n    default: MAX_ZOOM,\n  },\n  /**\n   * @default 0\n   */\n  minZoom: {\n    type: Number,\n    default: MIN_ZOOM,\n  },\n  /**\n   * @type {string}\n   * @default EPSG:3857\n   */\n  projection: {\n    type: String,\n    default: EPSG_3857,\n  },\n  resolution: Number,\n  resolutions: Array,\n  /**\n   * The initial rotation for the view in **radians** (positive rotation clockwise).\n   * @type {number}\n   * @vueSync\n   */\n  rotation: {\n    type: Number,\n    default: 0,\n  },\n  /**\n   * Zoom level used to calculate the resolution for the view as `int` value. Only used if `resolution` is not defined.\n   * @type {number}\n   * @default 0\n   * @vueSync\n   */\n  zoom: {\n    type: Number,\n    default: MIN_ZOOM,\n  },\n  /**\n   * @default 2\n   */\n  zoomFactor: {\n    type: Number,\n    default: ZOOM_FACTOR,\n  },\n}\n\n/**\n * @vueComputed\n */\nconst computed = /** @lends module:map/view# */{\n  viewZoom () {\n    if (this.rev && this.$view) {\n      return Math.round(this.$view.getZoom())\n    }\n\n    return this.zoom\n  },\n  viewRotation () {\n    if (this.rev && this.$view) {\n      return this.$view.getRotation()\n    }\n\n    return this.rotation\n  },\n  viewResolution () {\n    if (this.rev && this.$view) {\n      return this.$view.getResolution()\n    }\n\n    return this.resolution\n  },\n  viewCenter () {\n    if (this.rev && this.$view) {\n      return this.pointToDataProj(this.$view.getCenter())\n    }\n  },\n  viewCenterViewProj () {\n    if (this.rev && this.$view) {\n      return this.$view.getCenter()\n    }\n  },\n  /**\n   * @return {ProjectionLike}\n   */\n  resolvedDataProjection () {\n    // exclude this.projection from lookup to allow view rendering in projection\n    // that differs from data projection\n    return coalesce(\n      this.$viewContainer && this.$viewContainer.resolvedDataProjection,\n      this.$options.dataProjection,\n      this.viewProjection,\n    )\n  },\n}\n\n/**\n * @vueMethods\n */\nconst methods = /** @lends module:map/view# */{\n  /**\n   * @see {@link https://openlayers.org/en/latest/apidoc/ol.View.html#animate}\n   * @param {...(AnimationOptions|function(boolean))} args\n   * @return {Promise} Resolves when animation completes\n   */\n  animate (...args) {\n    hasView(this)\n\n    let cb = noop\n    if (isFunction(args[args.length - 1])) {\n      cb = args[args.length - 1]\n      args = args.slice(0, args.length - 1)\n    }\n    args.forEach(opts => {\n      if (!Array.isArray(opts.center)) return\n      opts.center = this.pointToViewProj(opts.center)\n    })\n\n    return new Promise(\n      resolve => this.$view.animate(...args, complete => {\n        cb(complete)\n        resolve(complete)\n      }),\n    )\n  },\n  /**\n   * @return {View}\n   * @protected\n   */\n  createOlObject () {\n    return new View({\n      center: this.pointToViewProj(this.center),\n      constrainRotation: this.constrainRotation,\n      enableRotation: this.enableRotation,\n      extent: this.extent ? this.extentToViewProj(this.extent) : undefined,\n      maxResolution: this.maxResolution,\n      minResolution: this.minResolution,\n      maxZoom: this.maxZoom,\n      minZoom: this.minZoom,\n      projection: this.projection,\n      resolution: this.resolution,\n      resolutions: this.resolutions,\n      rotation: this.rotation,\n      zoom: this.zoom,\n      zoomFactor: this.zoomFactor,\n    })\n  },\n  /**\n   * @see {@link https://openlayers.org/en/latest/apidoc/ol.View.html#fit}\n   * @param {Object|Extent|Geometry|Vue} geometryOrExtent\n   * @param {FitOptions} [options]\n   * @return {Promise} Resolves when view changes\n   */\n  fit (geometryOrExtent, options = {}) {\n    hasView(this)\n\n    // transform from GeoJSON, vl-feature to ol.Feature\n    if (isPlainObject(geometryOrExtent)) {\n      geometryOrExtent = this.readGeometryInDataProj(geometryOrExtent)\n    } else if (geometryOrExtent instanceof Vue) {\n      geometryOrExtent = geometryOrExtent.$geometry\n    }\n\n    let cb = options.callback || noop\n\n    return new Promise(resolve => {\n      this.$view.fit(geometryOrExtent, {\n        ...options,\n        callback: complete => {\n          cb(complete)\n          resolve(complete)\n        },\n      })\n    })\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  mount () {\n    this.$viewContainer && this.$viewContainer.setView(this)\n    this.subscribeAll()\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  unmount () {\n    this.unsubscribeAll()\n    this.$viewContainer && this.$viewContainer.setView(undefined)\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  subscribeAll () {\n    this::subscribeToViewChanges()\n  },\n}\n\nconst watch = {\n  center (value) {\n    value = this.pointToViewProj(value)\n    if (this.$view && !this.$view.getAnimating() && !isEqual(value, this.viewCenterViewProj)) {\n      this.$view.setCenter(value)\n    }\n  },\n  resolution (value) {\n    if (this.$view && !this.$view.getAnimating() && value !== this.viewResolution) {\n      this.$view.setResolution(value)\n    }\n  },\n  zoom (value) {\n    value = Math.round(value)\n    if (this.$view && !this.$view.getAnimating() && value !== this.viewZoom) {\n      this.$view.setZoom(value)\n    }\n  },\n  rotation (value) {\n    if (this.$view && !this.$view.getAnimating() && value !== this.viewRotation) {\n      this.$view.setRotation(value)\n    }\n  },\n  minZoom (value) {\n    if (this.$view && value !== this.$view.getMinZoom()) {\n      this.$view.setMinZoom(value)\n    }\n  },\n  maxZoom (value) {\n    if (this.$view && value !== this.$view.getMaxZoom()) {\n      this.$view.setMaxZoom(value)\n    }\n  },\n  resolvedDataProjection () {\n    if (this.$view) {\n      this.$view.setCenter(this.pointToViewProj(this.center))\n    }\n  },\n}\n\n/**\n * Represents a simple **2D view** of the map. This is the component to act upon to change the **center**,\n * **resolution**, and **rotation** of the map.\n *\n * @title View `vl-view` component\n * @alias module:map/view\n * @vueProto\n *\n * @vueSlot default [scoped] Default scoped slot with current state: center, zoom, rotation & etc.\n */\nexport default {\n  name: 'vl-view',\n  mixins: [olCmp, projTransforms],\n  props,\n  computed,\n  methods,\n  watch,\n  stubVNode: {\n    empty () {\n      return this.$options.name\n    },\n  },\n  /**\n   * @this module:map/view\n   */\n  created () {\n    Object.defineProperties(this, /** @lends module:map/view# */{\n      /**\n       * @type {View|undefined}\n       */\n      $view: {\n        enumerable: true,\n        get: () => this.$olObject,\n      },\n      $viewContainer: {\n        enumerable: true,\n        get: () => this.$services && this.$services.viewContainer,\n      },\n    })\n  },\n}\n\n/**\n * Subscribe to OpenLayers significant events\n * @return {void}\n * @private\n */\nfunction subscribeToViewChanges () {\n  hasView(this)\n\n  const ft = 1000 / 60\n  const resolution = observableFromOlChangeEvent(this.$view, 'resolution', true, ft)\n  const zoom = resolution.pipe(\n    mapObs(() => ({\n      prop: 'zoom',\n      value: Math.round(this.$view.getZoom()),\n    })),\n    distinctUntilKeyChanged('value'),\n  )\n\n  const changes = mergeObs(\n    observableFromOlChangeEvent(this.$view, 'center', true, ft, () => this.pointToDataProj(this.$view.getCenter())),\n    observableFromOlChangeEvent(this.$view, 'rotation', true, ft),\n    resolution,\n    zoom,\n  )\n\n  this.subscribeTo(changes, ({ prop, value }) => {\n    ++this.rev\n    this.$emit(`update:${prop}`, value)\n  })\n}\n","<template>\n  <i :class=\"[$options.name]\" style=\"display: none !important;\">\n    <slot :center=\"viewCenter\" :zoom=\"viewZoom\" :resolution=\"viewResolution\" :rotation=\"viewRotation\"/>\n  </i>\n</template>\n\n<script>\n  import View from 'ol/View'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { distinctUntilKeyChanged, map as mapObs } from 'rxjs/operators'\n  import Vue from 'vue'\n  import { olCmp, projTransforms } from '../../mixin'\n  import { EPSG_3857, MAX_ZOOM, MIN_ZOOM, ZOOM_FACTOR } from '../../ol-ext'\n  import { observableFromOlChangeEvent } from '../../rx-ext'\n  import { hasView } from '../../util/assert'\n  import { coalesce, isEqual, isFunction, isPlainObject, noop } from '../../util/minilo'\n\n  /**\n   * @vueProps\n   */\n  const props = /** @lends module:map/view# */{\n    /**\n     * The center coordinate in the view projection.\n     * @type {number[]}\n     * @default [0, 0]\n     * @vueSync\n     */\n    center: {\n      type: Array,\n      default: () => [0, 0],\n      validator: value => value.length === 2,\n    },\n    constrainRotation: {\n      type: [Boolean, Number],\n      default: true,\n    },\n    enableRotation: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * The extent that constrains the center defined in the view projection,\n     * in other words, center cannot be set outside this extent.\n     * @default undefined\n     */\n    extent: {\n      type: Array,\n      validator: value => value.length === 4,\n    },\n    maxResolution: Number,\n    minResolution: Number,\n    /**\n     * @default 28\n     */\n    maxZoom: {\n      type: Number,\n      default: MAX_ZOOM,\n    },\n    /**\n     * @default 0\n     */\n    minZoom: {\n      type: Number,\n      default: MIN_ZOOM,\n    },\n    /**\n     * @type {string}\n     * @default EPSG:3857\n     */\n    projection: {\n      type: String,\n      default: EPSG_3857,\n    },\n    resolution: Number,\n    resolutions: Array,\n    /**\n     * The initial rotation for the view in **radians** (positive rotation clockwise).\n     * @type {number}\n     * @vueSync\n     */\n    rotation: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * Zoom level used to calculate the resolution for the view as `int` value. Only used if `resolution` is not defined.\n     * @type {number}\n     * @default 0\n     * @vueSync\n     */\n    zoom: {\n      type: Number,\n      default: MIN_ZOOM,\n    },\n    /**\n     * @default 2\n     */\n    zoomFactor: {\n      type: Number,\n      default: ZOOM_FACTOR,\n    },\n  }\n\n  /**\n   * @vueComputed\n   */\n  const computed = /** @lends module:map/view# */{\n    viewZoom () {\n      if (this.rev && this.$view) {\n        return Math.round(this.$view.getZoom())\n      }\n\n      return this.zoom\n    },\n    viewRotation () {\n      if (this.rev && this.$view) {\n        return this.$view.getRotation()\n      }\n\n      return this.rotation\n    },\n    viewResolution () {\n      if (this.rev && this.$view) {\n        return this.$view.getResolution()\n      }\n\n      return this.resolution\n    },\n    viewCenter () {\n      if (this.rev && this.$view) {\n        return this.pointToDataProj(this.$view.getCenter())\n      }\n    },\n    viewCenterViewProj () {\n      if (this.rev && this.$view) {\n        return this.$view.getCenter()\n      }\n    },\n    /**\n     * @return {ProjectionLike}\n     */\n    resolvedDataProjection () {\n      // exclude this.projection from lookup to allow view rendering in projection\n      // that differs from data projection\n      return coalesce(\n        this.$viewContainer && this.$viewContainer.resolvedDataProjection,\n        this.$options.dataProjection,\n        this.viewProjection,\n      )\n    },\n  }\n\n  /**\n   * @vueMethods\n   */\n  const methods = /** @lends module:map/view# */{\n    /**\n     * @see {@link https://openlayers.org/en/latest/apidoc/ol.View.html#animate}\n     * @param {...(AnimationOptions|function(boolean))} args\n     * @return {Promise} Resolves when animation completes\n     */\n    animate (...args) {\n      hasView(this)\n\n      let cb = noop\n      if (isFunction(args[args.length - 1])) {\n        cb = args[args.length - 1]\n        args = args.slice(0, args.length - 1)\n      }\n      args.forEach(opts => {\n        if (!Array.isArray(opts.center)) return\n        opts.center = this.pointToViewProj(opts.center)\n      })\n\n      return new Promise(\n        resolve => this.$view.animate(...args, complete => {\n          cb(complete)\n          resolve(complete)\n        }),\n      )\n    },\n    /**\n     * @return {View}\n     * @protected\n     */\n    createOlObject () {\n      return new View({\n        center: this.pointToViewProj(this.center),\n        constrainRotation: this.constrainRotation,\n        enableRotation: this.enableRotation,\n        extent: this.extent ? this.extentToViewProj(this.extent) : undefined,\n        maxResolution: this.maxResolution,\n        minResolution: this.minResolution,\n        maxZoom: this.maxZoom,\n        minZoom: this.minZoom,\n        projection: this.projection,\n        resolution: this.resolution,\n        resolutions: this.resolutions,\n        rotation: this.rotation,\n        zoom: this.zoom,\n        zoomFactor: this.zoomFactor,\n      })\n    },\n    /**\n     * @see {@link https://openlayers.org/en/latest/apidoc/ol.View.html#fit}\n     * @param {Object|Extent|Geometry|Vue} geometryOrExtent\n     * @param {FitOptions} [options]\n     * @return {Promise} Resolves when view changes\n     */\n    fit (geometryOrExtent, options = {}) {\n      hasView(this)\n\n      // transform from GeoJSON, vl-feature to ol.Feature\n      if (isPlainObject(geometryOrExtent)) {\n        geometryOrExtent = this.readGeometryInDataProj(geometryOrExtent)\n      } else if (geometryOrExtent instanceof Vue) {\n        geometryOrExtent = geometryOrExtent.$geometry\n      }\n\n      let cb = options.callback || noop\n\n      return new Promise(resolve => {\n        this.$view.fit(geometryOrExtent, {\n          ...options,\n          callback: complete => {\n            cb(complete)\n            resolve(complete)\n          },\n        })\n      })\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this.$viewContainer && this.$viewContainer.setView(this)\n      this.subscribeAll()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.unsubscribeAll()\n      this.$viewContainer && this.$viewContainer.setView(undefined)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToViewChanges()\n    },\n  }\n\n  const watch = {\n    center (value) {\n      value = this.pointToViewProj(value)\n      if (this.$view && !this.$view.getAnimating() && !isEqual(value, this.viewCenterViewProj)) {\n        this.$view.setCenter(value)\n      }\n    },\n    resolution (value) {\n      if (this.$view && !this.$view.getAnimating() && value !== this.viewResolution) {\n        this.$view.setResolution(value)\n      }\n    },\n    zoom (value) {\n      value = Math.round(value)\n      if (this.$view && !this.$view.getAnimating() && value !== this.viewZoom) {\n        this.$view.setZoom(value)\n      }\n    },\n    rotation (value) {\n      if (this.$view && !this.$view.getAnimating() && value !== this.viewRotation) {\n        this.$view.setRotation(value)\n      }\n    },\n    minZoom (value) {\n      if (this.$view && value !== this.$view.getMinZoom()) {\n        this.$view.setMinZoom(value)\n      }\n    },\n    maxZoom (value) {\n      if (this.$view && value !== this.$view.getMaxZoom()) {\n        this.$view.setMaxZoom(value)\n      }\n    },\n    resolvedDataProjection () {\n      if (this.$view) {\n        this.$view.setCenter(this.pointToViewProj(this.center))\n      }\n    },\n  }\n\n  /**\n   * Represents a simple **2D view** of the map. This is the component to act upon to change the **center**,\n   * **resolution**, and **rotation** of the map.\n   *\n   * @title View `vl-view` component\n   * @alias module:map/view\n   * @vueProto\n   *\n   * @vueSlot default [scoped] Default scoped slot with current state: center, zoom, rotation & etc.\n   */\n  export default {\n    name: 'vl-view',\n    mixins: [olCmp, projTransforms],\n    props,\n    computed,\n    methods,\n    watch,\n    stubVNode: {\n      empty () {\n        return this.$options.name\n      },\n    },\n    /**\n     * @this module:map/view\n     */\n    created () {\n      Object.defineProperties(this, /** @lends module:map/view# */{\n        /**\n         * @type {View|undefined}\n         */\n        $view: {\n          enumerable: true,\n          get: () => this.$olObject,\n        },\n        $viewContainer: {\n          enumerable: true,\n          get: () => this.$services && this.$services.viewContainer,\n        },\n      })\n    },\n  }\n\n  /**\n   * Subscribe to OpenLayers significant events\n   * @return {void}\n   * @private\n   */\n  function subscribeToViewChanges () {\n    hasView(this)\n\n    const ft = 1000 / 60\n    const resolution = observableFromOlChangeEvent(this.$view, 'resolution', true, ft)\n    const zoom = resolution.pipe(\n      mapObs(() => ({\n        prop: 'zoom',\n        value: Math.round(this.$view.getZoom()),\n      })),\n      distinctUntilKeyChanged('value'),\n    )\n\n    const changes = mergeObs(\n      observableFromOlChangeEvent(this.$view, 'center', true, ft, () => this.pointToDataProj(this.$view.getCenter())),\n      observableFromOlChangeEvent(this.$view, 'rotation', true, ft),\n      resolution,\n      zoom,\n    )\n\n    this.subscribeTo(changes, ({ prop, value }) => {\n      ++this.rev\n      this.$emit(`update:${prop}`, value)\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Map from './map.vue'\nimport View from './view.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Map, options)\n  Object.assign(View, options)\n\n  Vue.component(Map.name, Map)\n  Vue.component(View.name, View)\n}\n\nexport default plugin\n\nexport {\n  Map,\n  View,\n  plugin as install,\n}\n"],"names":["props","controls","type","Object","Boolean","default","keyboardEventTarget","String","Element","Document","loadTilesWhileAnimating","loadTilesWhileInteracting","moveTolerance","Number","pixelRatio","window","devicePixelRatio","renderer","RENDERER_TYPE","CANVAS","validator","value","includes","tabindex","dataProjection","wrapX","computed","mapCtor","WEBGL","WebGLMap","Map","methods","createOlObject","map","_controls","interactions","_interactions","layers","_layers","overlays","_overlays","view","_view","set","_defaultOverlay","setMap","getLayersTarget","hasMap","_layersTarget","IndexedCollectionAdapter","$map","getLayers","layer","get","getInteractionsTarget","_interactionsTarget","getInteractions","interaction","getDefaultInteractionsSorter","a","b","ap","bp","getFeaturesTarget","_featuresTarget","_defaultOverlayFeatures","feature","getFeatureId","getOverlaysTarget","_overlaysTarget","getOverlays","overlay","getId","getCoordinateFromPixel","pixel","coordinate","pointToDataProj","getServices","vm","mergeDescriptors","olCmp","layersContainer","interactionsContainer","overlaysContainer","featuresContainer","$view","viewContainer","focus","$el","forEachFeatureAtPixel","callback","opts","forEachLayerAtPixel","layerFilter","undefined","setView","Vue","View","getView","mount","setTarget","subscribeAll","updateSize","unmount","clearLayers","clearInteractions","clearOverlays","unsubscribeAll","refresh","render","then","resolve","once","subscribeToMapEvents","watch","makeWatchers","scheduleRecreate","clear","extend","createDefaultControls","getArray","source","VectorSource","features","setSource","scheduleRefresh","name","mixins","projTransforms","created","Collection","createDefaultInteractions","VectorLayer","enumerable","$olObject","hasView","ft","pointerEvents","mergeObs","observableFromOlEvent","pipe","throttleTime","distinctUntilChanged","isEqual","mapObs","evt","otherEvents","events","subscribeTo","$emit","center","Array","length","constrainRotation","enableRotation","extent","maxResolution","minResolution","maxZoom","MAX_ZOOM","minZoom","MIN_ZOOM","projection","EPSG_3857","resolution","resolutions","rotation","zoom","zoomFactor","ZOOM_FACTOR","viewZoom","rev","Math","round","getZoom","viewRotation","getRotation","viewResolution","getResolution","viewCenter","getCenter","viewCenterViewProj","resolvedDataProjection","coalesce","$viewContainer","$options","viewProjection","animate","args","cb","noop","isFunction","slice","forEach","pointToViewProj","complete","extentToViewProj","fit","geometryOrExtent","options","isPlainObject","readGeometryInDataProj","$geometry","subscribeToViewChanges","getAnimating","setCenter","setResolution","setZoom","setRotation","getMinZoom","setMinZoom","getMaxZoom","setMaxZoom","stubVNode","empty","$services","observableFromOlChangeEvent","prop","distinctUntilKeyChanged","changes","plugin","installed","pick","component"],"mappings":"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"}