{"version":3,"file":"index.js","sources":["src/component/select-interaction/interaction.vue?rollup-plugin-vue=script.js","src/component/select-interaction/interaction.vue","src/component/select-interaction/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport { never, shiftKeyOnly, singleClick } from 'ol/events/condition'\nimport Feature from 'ol/Feature'\nimport SelectInteraction from 'ol/interaction/Select'\nimport Vue from 'vue'\nimport interaction from '../../mixin/interaction'\nimport projTransforms from '../../mixin/proj-transforms'\nimport stylesContainer from '../../mixin/styles-container'\nimport { getFeatureId } from '../../ol-ext/feature'\nimport { createStyle, defaultEditStyle } from '../../ol-ext/style'\nimport observableFromOlEvent from '../../rx-ext/from-ol-event'\nimport { hasInteraction, hasMap } from '../../util/assert'\nimport { constant, difference, forEach, isFunction, mapValues, stubArray } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\n/**\n * @vueProps\n */\nconst props = {\n  /**\n   * A function that takes an `ol.Feature` and an `ol.layer.Layer` and returns `true` if the feature may be selected or `false` otherwise.\n   * @type {function|undefined}\n   */\n  filter: {\n    type: Function,\n    default: constant(true),\n  },\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position will be checked for features.\n   * This only works for the canvas renderer and not for WebGL.\n   * @type {number}\n   */\n  hitTolerance: {\n    type: Number,\n    default: 0,\n  },\n  /**\n   * A boolean that determines if the default behaviour should select only single features or all (overlapping)\n   * features at the clicked map position.\n   * @type {boolean}\n   */\n  multi: {\n    type: Boolean,\n    default: false,\n  },\n  /**\n   * Selected features as array of GeoJSON features with coordinates in the map view projection.\n   * @type {string[]|number[]|Object[]}\n   */\n  features: {\n    type: Array,\n    default: stubArray,\n  },\n  /**\n   * Wrap the world horizontally on the selection overlay.\n   * @type {boolean}\n   */\n  wrapX: {\n    type: Boolean,\n    default: true,\n  },\n  /**\n   * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should\n   * be handled. By default, this is `ol.events.condition.never`. Use this if you want to use different events\n   * for `add` and `remove` instead of `toggle`.\n   * @type {function|undefined}\n   */\n  addCondition: {\n    type: Function,\n    default: never,\n  },\n  /**\n   * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n   * This is the event for the selected features as a whole. By default, this is `ol.events.condition.singleClick`.\n   * Clicking on a feature selects that feature and removes any that were in the selection. Clicking outside any feature\n   * removes all from the selection.\n   * @type {function|undefined}\n   */\n  condition: {\n    type: Function,\n    default: singleClick,\n  },\n  /**\n   * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n   * By default, this is `ol.events.condition.never`. Use this if you want to use different events for `add` and `remove`\n   * instead of `toggle`.\n   * @type {function|undefined}\n   */\n  removeCondition: {\n    type: Function,\n    default: never,\n  },\n  /**\n   * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n   * This is in addition to the `condition` event. By default, `ol.events.condition.shiftKeyOnly`, i.e. pressing `shift`\n   * as well as the `condition` event, adds that feature to the current selection if it is not currently selected,\n   * and removes it if it is.\n   * @type {function|undefined}\n   */\n  toggleCondition: {\n    type: Function,\n    default: shiftKeyOnly,\n  },\n}\n\n/**\n * @vueComputed\n */\nconst computed = {}\n\n/**\n * @vueMethods\n */\nconst methods = {\n  /**\n   * @return {Select}\n   * @protected\n   */\n  createInteraction () {\n    return new SelectInteraction({\n      multi: this.multi,\n      wrapX: this.wrapX,\n      filter: this.filter,\n      style: this.createStyleFunc(),\n      addCondition: this.addCondition,\n      condition: this.condition,\n      removeCondition: this.removeCondition,\n      toggleCondition: this.toggleCondition,\n    })\n  },\n  /**\n   * @return {function(feature: Feature): Style}\n   * @protected\n   */\n  getDefaultStyles () {\n    const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n    return function __selectDefaultStyleFunc (feature) {\n      if (feature.getGeometry()) {\n        return defaultStyles[feature.getGeometry().getType()]\n      }\n    }\n  },\n  /**\n   * @return {Feature[]}\n   */\n  getFeatures () {\n    return (this.$interaction && this.$interaction.getFeatures().getArray()) || []\n  },\n  /**\n   * @returns {Object}\n   * @protected\n   */\n  getServices () {\n    return mergeDescriptors(\n      this::interaction.methods.getServices(),\n      this::stylesContainer.methods.getServices(),\n    )\n  },\n  /**\n   * @return {Interaction|undefined}\n   * @protected\n   */\n  getStyleTarget () {\n    return this.$interaction\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  mount () {\n    this::interaction.methods.mount()\n    this.features.forEach(this.select)\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  unmount () {\n    this.unselectAll()\n    this::interaction.methods.unmount()\n  },\n  /**\n   * @param {Object|Vue|Feature|string|number} feature\n   * @return {void}\n   * @throws {Error}\n   */\n  select (feature) {\n    hasMap(this)\n    hasInteraction(this)\n\n    let id = getFeatureId(feature)\n    if (!id) {\n      throw new Error('Undefined feature id')\n    }\n    if (feature instanceof Vue) {\n      feature = feature.$feature\n    }\n\n    const selectedIds = this.$features.map(getFeatureId)\n    if (selectedIds.includes(id)) return\n\n    if (!(feature instanceof Feature)) {\n      feature = undefined\n      forEach(this.$map.getLayers().getArray(), layer => {\n        const source = layer.getSource()\n\n        if (source && isFunction(source.getFeatureById)) {\n          feature = source.getFeatureById(id)\n        }\n\n        return !feature\n      })\n    }\n\n    feature && this.$interaction.getFeatures().push(feature)\n  },\n  /**\n   * @param {Object|Vue|Feature|string|number} feature\n   * @return {void}\n   */\n  unselect (feature) {\n    hasInteraction(this)\n\n    let id = getFeatureId(feature)\n    if (!id) {\n      throw new Error('Undefined feature id')\n    }\n    if (feature instanceof Vue) {\n      feature = feature.$feature\n    }\n\n    const selectedIds = this.$features.map(getFeatureId)\n    const idx = selectedIds.findIndex(x => x === id)\n\n    if (idx !== -1) {\n      this.$interaction.getFeatures().removeAt(idx)\n    }\n  },\n  /**\n   * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n   * @return {void}\n   * @protected\n   */\n  setStyle (styles) {\n    if (styles !== this._styles) {\n      this._styles = styles\n      this.scheduleRefresh()\n    }\n  },\n  /**\n   * @return {Promise}\n   */\n  refresh () {\n    return Promise.all([\n      new Promise(resolve => {\n        if (this.$interaction) {\n          const featuresCollection = this.$interaction.getFeatures()\n          featuresCollection.once('change', () => resolve())\n          featuresCollection.changed()\n        } else {\n          resolve()\n        }\n      }),\n      this::interaction.methods.refresh(),\n    ])\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  subscribeAll () {\n    this::subscribeToInteractionChanges()\n  },\n  /**\n   * Removes all features from selection.\n   * @return {void}\n   */\n  unselectAll () {\n    hasInteraction(this)\n    this.$interaction.getFeatures().clear()\n  },\n}\n\nconst watch = {\n  ...makeWatchers([\n    'filter',\n    'hitTolerance',\n    'multi',\n    'wrapX',\n    'addCondition',\n    'condition',\n    'removeCondition',\n    'toggleCondition',\n  ], () => function () { this.scheduleRecreate() }),\n  features (value) {\n    if (!this.$interaction) return\n\n    let diffById = (a, b) => getFeatureId(a) === getFeatureId(b)\n    let forSelect = difference(value, this.$features, diffById)\n    let forUnselect = difference(this.$features, value, diffById)\n\n    forSelect.forEach(this.select)\n    forUnselect.forEach(this.unselect)\n  },\n}\n\n/**\n * @vueProto\n * @alias module:select-interaction/interaction\n * @title vl-interaction-select\n */\nexport default {\n  name: 'vl-interaction-select',\n  mixins: [interaction, stylesContainer, projTransforms],\n  props,\n  computed,\n  methods,\n  watch,\n  stubVNode: {\n    empty: false,\n    attrs () {\n      return {\n        class: this.$options.name,\n      }\n    },\n  },\n  created () {\n    Object.defineProperties(this, {\n      $features: {\n        enumerable: true,\n        get: this.getFeatures,\n      },\n    })\n  },\n}\n\n/**\n * @return {void}\n * @private\n */\nfunction subscribeToInteractionChanges () {\n  hasInteraction(this)\n\n  const events = observableFromOlEvent(this.$interaction, 'select')\n\n  this.subscribeTo(\n    events,\n    ({ selected, deselected, mapBrowserEvent }) => {\n      ++this.rev\n\n      deselected.forEach(feature => this.$emit('unselect', { feature, mapBrowserEvent }))\n      selected.forEach(feature => this.$emit('select', { feature, mapBrowserEvent }))\n      this.$emit('update:features', this.$features.map(::this.writeFeatureInDataProj))\n    },\n  )\n}\n","<template>\n  <i :class=\"[$options.name]\" style=\"display: none !important;\">\n    <slot :features=\"features\"/>\n  </i>\n</template>\n\n<script>\n  import { never, shiftKeyOnly, singleClick } from 'ol/events/condition'\n  import Feature from 'ol/Feature'\n  import SelectInteraction from 'ol/interaction/Select'\n  import Vue from 'vue'\n  import interaction from '../../mixin/interaction'\n  import projTransforms from '../../mixin/proj-transforms'\n  import stylesContainer from '../../mixin/styles-container'\n  import { getFeatureId } from '../../ol-ext/feature'\n  import { createStyle, defaultEditStyle } from '../../ol-ext/style'\n  import observableFromOlEvent from '../../rx-ext/from-ol-event'\n  import { hasInteraction, hasMap } from '../../util/assert'\n  import { constant, difference, forEach, isFunction, mapValues, stubArray } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  /**\n   * @vueProps\n   */\n  const props = {\n    /**\n     * A function that takes an `ol.Feature` and an `ol.layer.Layer` and returns `true` if the feature may be selected or `false` otherwise.\n     * @type {function|undefined}\n     */\n    filter: {\n      type: Function,\n      default: constant(true),\n    },\n    /**\n     * Hit-detection tolerance. Pixels inside the radius around the given position will be checked for features.\n     * This only works for the canvas renderer and not for WebGL.\n     * @type {number}\n     */\n    hitTolerance: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * A boolean that determines if the default behaviour should select only single features or all (overlapping)\n     * features at the clicked map position.\n     * @type {boolean}\n     */\n    multi: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * Selected features as array of GeoJSON features with coordinates in the map view projection.\n     * @type {string[]|number[]|Object[]}\n     */\n    features: {\n      type: Array,\n      default: stubArray,\n    },\n    /**\n     * Wrap the world horizontally on the selection overlay.\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: true,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should\n     * be handled. By default, this is `ol.events.condition.never`. Use this if you want to use different events\n     * for `add` and `remove` instead of `toggle`.\n     * @type {function|undefined}\n     */\n    addCondition: {\n      type: Function,\n      default: never,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * This is the event for the selected features as a whole. By default, this is `ol.events.condition.singleClick`.\n     * Clicking on a feature selects that feature and removes any that were in the selection. Clicking outside any feature\n     * removes all from the selection.\n     * @type {function|undefined}\n     */\n    condition: {\n      type: Function,\n      default: singleClick,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * By default, this is `ol.events.condition.never`. Use this if you want to use different events for `add` and `remove`\n     * instead of `toggle`.\n     * @type {function|undefined}\n     */\n    removeCondition: {\n      type: Function,\n      default: never,\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * This is in addition to the `condition` event. By default, `ol.events.condition.shiftKeyOnly`, i.e. pressing `shift`\n     * as well as the `condition` event, adds that feature to the current selection if it is not currently selected,\n     * and removes it if it is.\n     * @type {function|undefined}\n     */\n    toggleCondition: {\n      type: Function,\n      default: shiftKeyOnly,\n    },\n  }\n\n  /**\n   * @vueComputed\n   */\n  const computed = {}\n\n  /**\n   * @vueMethods\n   */\n  const methods = {\n    /**\n     * @return {Select}\n     * @protected\n     */\n    createInteraction () {\n      return new SelectInteraction({\n        multi: this.multi,\n        wrapX: this.wrapX,\n        filter: this.filter,\n        style: this.createStyleFunc(),\n        addCondition: this.addCondition,\n        condition: this.condition,\n        removeCondition: this.removeCondition,\n        toggleCondition: this.toggleCondition,\n      })\n    },\n    /**\n     * @return {function(feature: Feature): Style}\n     * @protected\n     */\n    getDefaultStyles () {\n      const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n      return function __selectDefaultStyleFunc (feature) {\n        if (feature.getGeometry()) {\n          return defaultStyles[feature.getGeometry().getType()]\n        }\n      }\n    },\n    /**\n     * @return {Feature[]}\n     */\n    getFeatures () {\n      return (this.$interaction && this.$interaction.getFeatures().getArray()) || []\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      return mergeDescriptors(\n        this::interaction.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n      )\n    },\n    /**\n     * @return {Interaction|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$interaction\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::interaction.methods.mount()\n      this.features.forEach(this.select)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.unselectAll()\n      this::interaction.methods.unmount()\n    },\n    /**\n     * @param {Object|Vue|Feature|string|number} feature\n     * @return {void}\n     * @throws {Error}\n     */\n    select (feature) {\n      hasMap(this)\n      hasInteraction(this)\n\n      let id = getFeatureId(feature)\n      if (!id) {\n        throw new Error('Undefined feature id')\n      }\n      if (feature instanceof Vue) {\n        feature = feature.$feature\n      }\n\n      const selectedIds = this.$features.map(getFeatureId)\n      if (selectedIds.includes(id)) return\n\n      if (!(feature instanceof Feature)) {\n        feature = undefined\n        forEach(this.$map.getLayers().getArray(), layer => {\n          const source = layer.getSource()\n\n          if (source && isFunction(source.getFeatureById)) {\n            feature = source.getFeatureById(id)\n          }\n\n          return !feature\n        })\n      }\n\n      feature && this.$interaction.getFeatures().push(feature)\n    },\n    /**\n     * @param {Object|Vue|Feature|string|number} feature\n     * @return {void}\n     */\n    unselect (feature) {\n      hasInteraction(this)\n\n      let id = getFeatureId(feature)\n      if (!id) {\n        throw new Error('Undefined feature id')\n      }\n      if (feature instanceof Vue) {\n        feature = feature.$feature\n      }\n\n      const selectedIds = this.$features.map(getFeatureId)\n      const idx = selectedIds.findIndex(x => x === id)\n\n      if (idx !== -1) {\n        this.$interaction.getFeatures().removeAt(idx)\n      }\n    },\n    /**\n     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n     * @return {void}\n     * @protected\n     */\n    setStyle (styles) {\n      if (styles !== this._styles) {\n        this._styles = styles\n        this.scheduleRefresh()\n      }\n    },\n    /**\n     * @return {Promise}\n     */\n    refresh () {\n      return Promise.all([\n        new Promise(resolve => {\n          if (this.$interaction) {\n            const featuresCollection = this.$interaction.getFeatures()\n            featuresCollection.once('change', () => resolve())\n            featuresCollection.changed()\n          } else {\n            resolve()\n          }\n        }),\n        this::interaction.methods.refresh(),\n      ])\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToInteractionChanges()\n    },\n    /**\n     * Removes all features from selection.\n     * @return {void}\n     */\n    unselectAll () {\n      hasInteraction(this)\n      this.$interaction.getFeatures().clear()\n    },\n  }\n\n  const watch = {\n    ...makeWatchers([\n      'filter',\n      'hitTolerance',\n      'multi',\n      'wrapX',\n      'addCondition',\n      'condition',\n      'removeCondition',\n      'toggleCondition',\n    ], () => function () { this.scheduleRecreate() }),\n    features (value) {\n      if (!this.$interaction) return\n\n      let diffById = (a, b) => getFeatureId(a) === getFeatureId(b)\n      let forSelect = difference(value, this.$features, diffById)\n      let forUnselect = difference(this.$features, value, diffById)\n\n      forSelect.forEach(this.select)\n      forUnselect.forEach(this.unselect)\n    },\n  }\n\n  /**\n   * @vueProto\n   * @alias module:select-interaction/interaction\n   * @title vl-interaction-select\n   */\n  export default {\n    name: 'vl-interaction-select',\n    mixins: [interaction, stylesContainer, projTransforms],\n    props,\n    computed,\n    methods,\n    watch,\n    stubVNode: {\n      empty: false,\n      attrs () {\n        return {\n          class: this.$options.name,\n        }\n      },\n    },\n    created () {\n      Object.defineProperties(this, {\n        $features: {\n          enumerable: true,\n          get: this.getFeatures,\n        },\n      })\n    },\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  function subscribeToInteractionChanges () {\n    hasInteraction(this)\n\n    const events = observableFromOlEvent(this.$interaction, 'select')\n\n    this.subscribeTo(\n      events,\n      ({ selected, deselected, mapBrowserEvent }) => {\n        ++this.rev\n\n        deselected.forEach(feature => this.$emit('unselect', { feature, mapBrowserEvent }))\n        selected.forEach(feature => this.$emit('select', { feature, mapBrowserEvent }))\n        this.$emit('update:features', this.$features.map(::this.writeFeatureInDataProj))\n      },\n    )\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Interaction from './interaction.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Interaction, options)\n\n  Vue.component(Interaction.name, Interaction)\n}\n\nexport default plugin\n\nexport {\n  Interaction,\n  plugin as install,\n}\n"],"names":["props","filter","type","Function","default","constant","hitTolerance","Number","multi","Boolean","features","Array","stubArray","wrapX","addCondition","never","condition","singleClick","removeCondition","toggleCondition","shiftKeyOnly","computed","methods","createInteraction","SelectInteraction","style","createStyleFunc","getDefaultStyles","defaultStyles","mapValues","defaultEditStyle","styles","map","createStyle","__selectDefaultStyleFunc","feature","getGeometry","getType","getFeatures","$interaction","getArray","getServices","mergeDescriptors","interaction","stylesContainer","getStyleTarget","mount","forEach","select","unmount","unselectAll","hasMap","hasInteraction","id","getFeatureId","Error","Vue","$feature","selectedIds","$features","includes","Feature","undefined","$map","getLayers","layer","source","getSource","isFunction","getFeatureById","push","unselect","idx","findIndex","x","removeAt","setStyle","_styles","scheduleRefresh","refresh","all","resolve","featuresCollection","once","changed","subscribeAll","subscribeToInteractionChanges","clear","watch","makeWatchers","scheduleRecreate","value","diffById","a","b","forSelect","difference","forUnselect","name","mixins","projTransforms","stubVNode","empty","attrs","class","$options","created","enumerable","get","events","observableFromOlEvent","subscribeTo","selected","deselected","mapBrowserEvent","rev","$emit","writeFeatureInDataProj","plugin","options","installed","pick","Interaction","component"],"mappings":"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"}