{"version":3,"file":"index.js","sources":["src/component/style-func/style.vue?rollup-plugin-vue=script.js","src/component/style-func/style.vue","src/component/style-func/index.js"],"sourcesContent":["\nimport style from '../../mixin/style'\nimport stylesContainer from '../../mixin/styles-container'\nimport { hasMap } from '../../util/assert'\nimport { warn } from '../../util/log'\nimport { isFunction, noop } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\n\n/**\n * Style function component for advanced styling.\n * Plays the role of both a style that mounts itself to style target component (vl-layer-vector, vl-feature & etc.)\n * and style target for inner style containers (vl-style-box) as fallback style.\n */\n\nconst props = {\n  /**\n   * @type {function(): function(feature: Feature): Style}\n   */\n  factory: {\n    type: Function,\n    required: true,\n  },\n}\n\nconst computed = {\n  styleFunc () {\n    let func = this.factory()\n    if (!isFunction(func)) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(`Factory returned a value not of Function type, fallback style will be used`)\n      }\n      func = noop\n    }\n\n    return func\n  },\n}\n\nconst methods = {\n  /**\n   * @return {function(feature: Feature): Style}\n   * @protected\n   */\n  createStyle () {\n    hasMap(this)\n    // user provided style function\n    const providedStyleFunc = this.styleFunc\n    // fallback style function made from inner style containers\n    const fallbackStyleFunc = this.createStyleFunc()\n\n    return function __styleFunc (feature, resolution) {\n      const styles = providedStyleFunc(feature, resolution)\n      // not empty or null style\n      if (\n        styles === null ||\n        (Array.isArray(styles) && styles.length)\n      ) {\n        return styles\n      }\n      return fallbackStyleFunc(feature, resolution)\n    }\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  mount () {\n    this.$stylesContainer && this.$stylesContainer.addStyle(this)\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  unmount () {\n    this.$stylesContainer && this.$stylesContainer.removeStyle(this)\n  },\n  /**\n   * @returns {Object}\n   * @protected\n   */\n  getServices () {\n    const vm = this\n\n    return mergeDescriptors(this::style.methods.getServices(), {\n      get stylesContainer () { return vm },\n    })\n  },\n  /**\n   * Overrides stylesContainer `setStyle` method\n   * @param {Array<{ style: Style, condition: (function|boolean|undefined) }>|function(feature: Feature): Style|Vue|undefined} styles\n   * @return {void}\n   */\n  setStyle (styles) {\n    if (styles !== this._styles) {\n      // simply save all inner styles and\n      // use them later in style function as fallback\n      this._styles = styles\n      this.scheduleRefresh()\n    }\n  },\n  /**\n   * @return {Promise}\n   */\n  refresh () {\n    // recreate style\n    return this.recreate()\n  },\n}\n\nconst watch = {\n  factory () {\n    this.scheduleRefresh()\n  },\n}\n\nexport default {\n  name: 'vl-style-func',\n  mixins: [style, stylesContainer],\n  props,\n  computed,\n  methods,\n  watch,\n  stubVNode: {\n    empty: false,\n    attrs () {\n      return {\n        class: this.$options.name,\n      }\n    },\n  },\n}\n","<script>\n  import style from '../../mixin/style'\n  import stylesContainer from '../../mixin/styles-container'\n  import { hasMap } from '../../util/assert'\n  import { warn } from '../../util/log'\n  import { isFunction, noop } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n\n  /**\n   * Style function component for advanced styling.\n   * Plays the role of both a style that mounts itself to style target component (vl-layer-vector, vl-feature & etc.)\n   * and style target for inner style containers (vl-style-box) as fallback style.\n   */\n\n  const props = {\n    /**\n     * @type {function(): function(feature: Feature): Style}\n     */\n    factory: {\n      type: Function,\n      required: true,\n    },\n  }\n\n  const computed = {\n    styleFunc () {\n      let func = this.factory()\n      if (!isFunction(func)) {\n        if (process.env.NODE_ENV !== 'production') {\n          warn(`Factory returned a value not of Function type, fallback style will be used`)\n        }\n        func = noop\n      }\n\n      return func\n    },\n  }\n\n  const methods = {\n    /**\n     * @return {function(feature: Feature): Style}\n     * @protected\n     */\n    createStyle () {\n      hasMap(this)\n      // user provided style function\n      const providedStyleFunc = this.styleFunc\n      // fallback style function made from inner style containers\n      const fallbackStyleFunc = this.createStyleFunc()\n\n      return function __styleFunc (feature, resolution) {\n        const styles = providedStyleFunc(feature, resolution)\n        // not empty or null style\n        if (\n          styles === null ||\n          (Array.isArray(styles) && styles.length)\n        ) {\n          return styles\n        }\n        return fallbackStyleFunc(feature, resolution)\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this.$stylesContainer && this.$stylesContainer.addStyle(this)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.$stylesContainer && this.$stylesContainer.removeStyle(this)\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      const vm = this\n\n      return mergeDescriptors(this::style.methods.getServices(), {\n        get stylesContainer () { return vm },\n      })\n    },\n    /**\n     * Overrides stylesContainer `setStyle` method\n     * @param {Array<{ style: Style, condition: (function|boolean|undefined) }>|function(feature: Feature): Style|Vue|undefined} styles\n     * @return {void}\n     */\n    setStyle (styles) {\n      if (styles !== this._styles) {\n        // simply save all inner styles and\n        // use them later in style function as fallback\n        this._styles = styles\n        this.scheduleRefresh()\n      }\n    },\n    /**\n     * @return {Promise}\n     */\n    refresh () {\n      // recreate style\n      return this.recreate()\n    },\n  }\n\n  const watch = {\n    factory () {\n      this.scheduleRefresh()\n    },\n  }\n\n  export default {\n    name: 'vl-style-func',\n    mixins: [style, stylesContainer],\n    props,\n    computed,\n    methods,\n    watch,\n    stubVNode: {\n      empty: false,\n      attrs () {\n        return {\n          class: this.$options.name,\n        }\n      },\n    },\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Style from './style.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Style, options)\n\n  Vue.component(Style.name, Style)\n}\n\nexport default plugin\n\nexport {\n  Style,\n  plugin as install,\n}\n"],"names":["props","factory","type","Function","required","computed","styleFunc","func","isFunction","process","env","NODE_ENV","warn","noop","methods","createStyle","hasMap","providedStyleFunc","fallbackStyleFunc","createStyleFunc","__styleFunc","feature","resolution","styles","length","mount","$stylesContainer","addStyle","unmount","removeStyle","getServices","vm","mergeDescriptors","style","stylesContainer","setStyle","_styles","scheduleRefresh","refresh","recreate","watch","name","mixins","stubVNode","empty","attrs","class","$options","plugin","Vue","options","installed","pick","Style","component"],"mappings":";;;;;;;;;;;;;;;;;;;AAQA;;;;;;AAMA,IAAMA,KAAK,GAAG;;;;EAIZC,OAAO,EAAE;IACPC,IAAI,EAAEC,QADC;IAEPC,QAAQ,EAAE;;CANd;AAUA,IAAMC,QAAQ,GAAG;EACfC,SADe,uBACF;QACPC,IAAI,GAAG,KAAKN,OAAL,EAAX;;QACI,CAACO,UAAU,CAACD,IAAD,CAAf,EAAuB;UACjBE,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;QACzCC,IAAI,8EAAJ;;;MAEFL,IAAI,GAAGM,IAAP;;;WAGKN,IAAP;;CAVJ;AAcA,IAAMO,OAAO,GAAG;;;;;EAKdC,WALc,yBAKC;IACbC,MAAM,CAAC,IAAD,CAAN,CADa;;QAGPC,iBAAiB,GAAG,KAAKX,SAA/B,CAHa;;QAKPY,iBAAiB,GAAG,KAAKC,eAAL,EAA1B;WAEO,SAASC,WAAT,CAAsBC,OAAtB,EAA+BC,UAA/B,EAA2C;UAC1CC,MAAM,GAAGN,iBAAiB,CAACI,OAAD,EAAUC,UAAV,CAAhC,CADgD;;UAI9CC,MAAM,KAAK,IAAX,IACC,eAAcA,MAAd,KAAyBA,MAAM,CAACC,MAFnC,EAGE;eACOD,MAAP;;;aAEKL,iBAAiB,CAACG,OAAD,EAAUC,UAAV,CAAxB;KATF;GAZY;;;;;;EA4BdG,KA5Bc,mBA4BL;SACFC,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBC,QAAtB,CAA+B,IAA/B,CAAzB;GA7BY;;;;;;EAmCdC,OAnCc,qBAmCH;SACJF,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBG,WAAtB,CAAkC,IAAlC,CAAzB;GApCY;;;;;;EA0CdC,WA1Cc,yBA0CC;QACPC,EAAE,GAAG,IAAX;WAEOC,gBAAgB,CAAOC,KAAK,CAACnB,OAAN,CAAcgB,WAApB,WAAD,EAAoC;UACrDI,eAAJ,GAAuB;eAASH,EAAP;;;KADJ,CAAvB;GA7CY;;;;;;;EAsDdI,QAtDc,oBAsDJZ,MAtDI,EAsDI;QACZA,MAAM,KAAK,KAAKa,OAApB,EAA6B;;;WAGtBA,OAAL,GAAeb,MAAf;WACKc,eAAL;;GA3DU;;;;;EAiEdC,OAjEc,qBAiEH;;WAEF,KAAKC,QAAL,EAAP;;CAnEJ;AAuEA,IAAMC,KAAK,GAAG;EACZvC,OADY,qBACD;SACJoC,eAAL;;CAFJ;AAMA,aAAe;EACbI,IAAI,EAAE,eADO;EAEbC,MAAM,EAAE,CAACT,KAAD,EAAQC,eAAR,CAFK;EAGblC,KAAK,EAALA,KAHa;EAIbK,QAAQ,EAARA,QAJa;EAKbS,OAAO,EAAPA,OALa;EAMb0B,KAAK,EAALA,KANa;EAObG,SAAS,EAAE;IACTC,KAAK,EAAE,KADE;IAETC,KAFS,mBAEA;aACA;QACLC,KAAK,EAAE,KAAKC,QAAL,CAAcN;OADvB;;;CAVN;;;AChHY,2BAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAZ,SAASO,MAAT,CAAiBC,GAAjB,EAAoC;MAAdC,OAAc,uEAAJ,EAAI;;MAC9BF,MAAM,CAACG,SAAX,EAAsB;;;;EAGtBH,MAAM,CAACG,SAAP,GAAmB,IAAnB;EAEAD,OAAO,GAAGE,IAAI,CAACF,OAAD,EAAU,gBAAV,CAAd;;iBACcG,KAAd,EAAqBH,OAArB;;EAEAD,GAAG,CAACK,SAAJ,CAAcD,KAAK,CAACZ,IAApB,EAA0BY,KAA1B;;;;;;"}