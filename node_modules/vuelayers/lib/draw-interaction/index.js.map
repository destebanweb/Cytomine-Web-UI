{"version":3,"file":"index.js","sources":["src/component/draw-interaction/interaction.vue?rollup-plugin-vue=script.js","src/component/draw-interaction/interaction.vue","src/component/draw-interaction/index.js"],"sourcesContent":["\nimport { noModifierKeys, shiftKeyOnly } from 'ol/events/condition'\nimport DrawInteraction from 'ol/interaction/Draw'\nimport { merge as mergeObs } from 'rxjs/observable'\nimport { map as mapObs } from 'rxjs/operators'\nimport interaction from '../../mixin/interaction'\nimport stylesContainer from '../../mixin/styles-container'\nimport { GEOMETRY_TYPE } from '../../ol-ext/consts'\nimport { initFeature } from '../../ol-ext/feature'\nimport { createStyle, defaultEditStyle } from '../../ol-ext/style'\nimport { isCollection, isVectorSource } from '../../ol-ext/util'\nimport observableFromOlEvent from '../../rx-ext/from-ol-event'\nimport { hasInteraction } from '../../util/assert'\nimport { camelCase, isFunction, mapValues, upperFirst } from '../../util/minilo'\nimport mergeDescriptors from '../../util/multi-merge-descriptors'\nimport { makeWatchers } from '../../util/vue-helpers'\n\nconst transformType = type => upperFirst(camelCase(type))\n/**\n * @vueProps\n */\nconst props = {\n  /**\n   * Target source or collection identifier from IdentityMap.\n   * @type {String}\n   */\n  source: {\n    type: String,\n    required: true,\n  },\n  /**\n   * The maximum distance in pixels between \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n   * actually add a point/vertex to the geometry being drawn. Default is 6 pixels. That value was chosen for the\n   * draw interaction to behave correctly on mouse as well as on touch devices.\n   * @type {number}\n   */\n  clickTolerance: {\n    type: Number,\n    default: 6,\n  },\n  /**\n   * Pixel distance for snapping to the drawing finish.\n   * @type {number}\n   */\n  snapTolerance: {\n    type: Number,\n    default: 12,\n  },\n  /**\n   * Drawing type ('Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').\n   * @type {string}\n   */\n  type: {\n    type: String,\n    required: true,\n    validator: value => Object.values(GEOMETRY_TYPE).includes(transformType(value)),\n  },\n  /**\n   * Stop click, singleclick, and doubleclick events from firing during drawing.\n   * @type {boolean}\n   */\n  stopClick: {\n    type: Boolean,\n    default: false,\n  },\n  /**\n   * The number of points that can be drawn before a polygon ring or line string is finished.\n   * @type {number|undefined}\n   */\n  maxPoints: Number,\n  /**\n   * The number of points that must be drawn before a polygon ring or line string can be finished.\n   * Default is `3` for polygon rings and `2` for line strings.\n   * @type {number|undefined}\n   */\n  minPoints: Number,\n  /**\n   * A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether the drawing can be finished.\n   * @type {function|undefined}\n   */\n  finishCondition: Function,\n  /**\n   * Function that is called when a geometry's coordinates are updated.\n   * @type {function|undefined}\n   */\n  geometryFunction: Function,\n  /**\n   * Name of the geometry attribute for newly created features.\n   * @type {string}\n   */\n  geometryName: {\n    type: String,\n    default: 'geometry',\n  },\n  /**\n   * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n   * By default `ol.events.condition.noModifierKeys`, i.e. a click, adds a vertex or deactivates freehand drawing.\n   * @type {function|undefined}\n   */\n  condition: {\n    type: Function,\n    default: noModifierKeys,\n  },\n  /**\n   * Operate in freehand mode for lines, polygons, and circles. This makes the interaction always operate in\n   * freehand mode and takes precedence over any `freehandCondition` option.\n   * @type {boolean}\n   */\n  freehand: {\n    type: Boolean,\n    default: false,\n  },\n  /**\n   * Condition that activates freehand drawing for lines and polygons. This function takes an `ol.MapBrowserEvent` and\n   * returns a boolean to indicate whether that event should be handled. The default is `ol.events.condition.shiftKeyOnly`,\n   * meaning that the Shift key activates freehand drawing.\n   * @type {function|undefined}\n   */\n  freehandCondition: {\n    type: Function,\n    default: shiftKeyOnly,\n  },\n  /**\n   * Wrap the world horizontally on the sketch overlay.\n   * @type {boolean}\n   */\n  wrapX: {\n    type: Boolean,\n    default: false,\n  },\n}\n\n/**\n * @vueMethods\n */\nconst methods = {\n  /**\n   * @return {Promise<Draw>}\n   * @protected\n   */\n  async createInteraction () {\n    let sourceIdent = this.makeIdent(this.source)\n    let source = await this.$identityMap.get(sourceIdent, this.$options.INSTANCE_PROMISE_POOL)\n\n    if (isFunction(source.getFeatures)) {\n      let features = source.getFeatures()\n      if (isCollection(features)) {\n        source = features\n      }\n    }\n\n    return new DrawInteraction({\n      source: isVectorSource(source) ? source : undefined,\n      features: isCollection(source) ? source : undefined,\n      clickTolerance: this.clickTolerance,\n      snapTolerance: this.snapTolerance,\n      type: transformType(this.type),\n      stopClick: this.stopClick,\n      maxPoints: this.maxPoints,\n      minPoints: this.minPoints,\n      finishCondition: this.finishCondition,\n      style: this.createStyleFunc(),\n      geometryFunction: this.geometryFunction,\n      geometryName: this.geometryName,\n      condition: this.condition,\n      freehand: this.freehand,\n      freehandCondition: this.freehandCondition,\n      wrapX: this.wrapX,\n    })\n  },\n  /**\n   * @return {function(feature: Feature): Style}\n   * @protected\n   */\n  getDefaultStyles () {\n    const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n    return function __selectDefaultStyleFunc (feature) {\n      if (feature.getGeometry()) {\n        return defaultStyles[feature.getGeometry().getType()]\n      }\n    }\n  },\n  /**\n   * @returns {Object}\n   * @protected\n   */\n  getServices () {\n    return mergeDescriptors(\n      this::interaction.methods.getServices(),\n      this::stylesContainer.methods.getServices(),\n    )\n  },\n  /**\n   * @return {Interaction|undefined}\n   * @protected\n   */\n  getStyleTarget () {\n    return this.$interaction\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  mount () {\n    this::interaction.methods.mount()\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  unmount () {\n    this::interaction.methods.unmount()\n  },\n  /**\n   * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n   * @return {void}\n   * @protected\n   */\n  setStyle (styles) {\n    if (styles !== this._styles) {\n      this._styles = styles\n      this.scheduleRefresh()\n    }\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  subscribeAll () {\n    this::subscribeToInteractionChanges()\n  },\n}\n// todo other props?\nconst watch = makeWatchers(['source', 'type'], () => function () {\n  this.scheduleRecreate()\n})\n\n/**\n * @alias module:draw-interaction/interaction\n * @title vl-interaction-draw\n * @vueProto\n */\nexport default {\n  name: 'vl-interaction-draw',\n  mixins: [interaction, stylesContainer],\n  props,\n  methods,\n  watch,\n  stubVNode: {\n    empty: false,\n    attrs () {\n      return {\n        class: this.$options.name,\n      }\n    },\n  },\n}\n\n/**\n * @return {void}\n * @private\n */\nfunction subscribeToInteractionChanges () {\n  hasInteraction(this)\n\n  const drawEvents = mergeObs(\n    observableFromOlEvent(this.$interaction, 'drawstart')\n      .pipe(\n        mapObs(evt => {\n          initFeature(evt.feature)\n          return evt\n        }),\n      ),\n    observableFromOlEvent(this.$interaction, 'drawend'),\n  )\n  this.subscribeTo(drawEvents, evt => {\n    ++this.rev\n    this.$emit(evt.type, evt)\n  })\n}\n","<script>\n  import { noModifierKeys, shiftKeyOnly } from 'ol/events/condition'\n  import DrawInteraction from 'ol/interaction/Draw'\n  import { merge as mergeObs } from 'rxjs/observable'\n  import { map as mapObs } from 'rxjs/operators'\n  import interaction from '../../mixin/interaction'\n  import stylesContainer from '../../mixin/styles-container'\n  import { GEOMETRY_TYPE } from '../../ol-ext/consts'\n  import { initFeature } from '../../ol-ext/feature'\n  import { createStyle, defaultEditStyle } from '../../ol-ext/style'\n  import { isCollection, isVectorSource } from '../../ol-ext/util'\n  import observableFromOlEvent from '../../rx-ext/from-ol-event'\n  import { hasInteraction } from '../../util/assert'\n  import { camelCase, isFunction, mapValues, upperFirst } from '../../util/minilo'\n  import mergeDescriptors from '../../util/multi-merge-descriptors'\n  import { makeWatchers } from '../../util/vue-helpers'\n\n  const transformType = type => upperFirst(camelCase(type))\n  /**\n   * @vueProps\n   */\n  const props = {\n    /**\n     * Target source or collection identifier from IdentityMap.\n     * @type {String}\n     */\n    source: {\n      type: String,\n      required: true,\n    },\n    /**\n     * The maximum distance in pixels between \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n     * actually add a point/vertex to the geometry being drawn. Default is 6 pixels. That value was chosen for the\n     * draw interaction to behave correctly on mouse as well as on touch devices.\n     * @type {number}\n     */\n    clickTolerance: {\n      type: Number,\n      default: 6,\n    },\n    /**\n     * Pixel distance for snapping to the drawing finish.\n     * @type {number}\n     */\n    snapTolerance: {\n      type: Number,\n      default: 12,\n    },\n    /**\n     * Drawing type ('Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').\n     * @type {string}\n     */\n    type: {\n      type: String,\n      required: true,\n      validator: value => Object.values(GEOMETRY_TYPE).includes(transformType(value)),\n    },\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * @type {boolean}\n     */\n    stopClick: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * The number of points that can be drawn before a polygon ring or line string is finished.\n     * @type {number|undefined}\n     */\n    maxPoints: Number,\n    /**\n     * The number of points that must be drawn before a polygon ring or line string can be finished.\n     * Default is `3` for polygon rings and `2` for line strings.\n     * @type {number|undefined}\n     */\n    minPoints: Number,\n    /**\n     * A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether the drawing can be finished.\n     * @type {function|undefined}\n     */\n    finishCondition: Function,\n    /**\n     * Function that is called when a geometry's coordinates are updated.\n     * @type {function|undefined}\n     */\n    geometryFunction: Function,\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string}\n     */\n    geometryName: {\n      type: String,\n      default: 'geometry',\n    },\n    /**\n     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.\n     * By default `ol.events.condition.noModifierKeys`, i.e. a click, adds a vertex or deactivates freehand drawing.\n     * @type {function|undefined}\n     */\n    condition: {\n      type: Function,\n      default: noModifierKeys,\n    },\n    /**\n     * Operate in freehand mode for lines, polygons, and circles. This makes the interaction always operate in\n     * freehand mode and takes precedence over any `freehandCondition` option.\n     * @type {boolean}\n     */\n    freehand: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * Condition that activates freehand drawing for lines and polygons. This function takes an `ol.MapBrowserEvent` and\n     * returns a boolean to indicate whether that event should be handled. The default is `ol.events.condition.shiftKeyOnly`,\n     * meaning that the Shift key activates freehand drawing.\n     * @type {function|undefined}\n     */\n    freehandCondition: {\n      type: Function,\n      default: shiftKeyOnly,\n    },\n    /**\n     * Wrap the world horizontally on the sketch overlay.\n     * @type {boolean}\n     */\n    wrapX: {\n      type: Boolean,\n      default: false,\n    },\n  }\n\n  /**\n   * @vueMethods\n   */\n  const methods = {\n    /**\n     * @return {Promise<Draw>}\n     * @protected\n     */\n    async createInteraction () {\n      let sourceIdent = this.makeIdent(this.source)\n      let source = await this.$identityMap.get(sourceIdent, this.$options.INSTANCE_PROMISE_POOL)\n\n      if (isFunction(source.getFeatures)) {\n        let features = source.getFeatures()\n        if (isCollection(features)) {\n          source = features\n        }\n      }\n\n      return new DrawInteraction({\n        source: isVectorSource(source) ? source : undefined,\n        features: isCollection(source) ? source : undefined,\n        clickTolerance: this.clickTolerance,\n        snapTolerance: this.snapTolerance,\n        type: transformType(this.type),\n        stopClick: this.stopClick,\n        maxPoints: this.maxPoints,\n        minPoints: this.minPoints,\n        finishCondition: this.finishCondition,\n        style: this.createStyleFunc(),\n        geometryFunction: this.geometryFunction,\n        geometryName: this.geometryName,\n        condition: this.condition,\n        freehand: this.freehand,\n        freehandCondition: this.freehandCondition,\n        wrapX: this.wrapX,\n      })\n    },\n    /**\n     * @return {function(feature: Feature): Style}\n     * @protected\n     */\n    getDefaultStyles () {\n      const defaultStyles = mapValues(defaultEditStyle(), styles => styles.map(createStyle))\n\n      return function __selectDefaultStyleFunc (feature) {\n        if (feature.getGeometry()) {\n          return defaultStyles[feature.getGeometry().getType()]\n        }\n      }\n    },\n    /**\n     * @returns {Object}\n     * @protected\n     */\n    getServices () {\n      return mergeDescriptors(\n        this::interaction.methods.getServices(),\n        this::stylesContainer.methods.getServices(),\n      )\n    },\n    /**\n     * @return {Interaction|undefined}\n     * @protected\n     */\n    getStyleTarget () {\n      return this.$interaction\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::interaction.methods.mount()\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this::interaction.methods.unmount()\n    },\n    /**\n     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles\n     * @return {void}\n     * @protected\n     */\n    setStyle (styles) {\n      if (styles !== this._styles) {\n        this._styles = styles\n        this.scheduleRefresh()\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    subscribeAll () {\n      this::subscribeToInteractionChanges()\n    },\n  }\n  // todo other props?\n  const watch = makeWatchers(['source', 'type'], () => function () {\n    this.scheduleRecreate()\n  })\n\n  /**\n   * @alias module:draw-interaction/interaction\n   * @title vl-interaction-draw\n   * @vueProto\n   */\n  export default {\n    name: 'vl-interaction-draw',\n    mixins: [interaction, stylesContainer],\n    props,\n    methods,\n    watch,\n    stubVNode: {\n      empty: false,\n      attrs () {\n        return {\n          class: this.$options.name,\n        }\n      },\n    },\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  function subscribeToInteractionChanges () {\n    hasInteraction(this)\n\n    const drawEvents = mergeObs(\n      observableFromOlEvent(this.$interaction, 'drawstart')\n        .pipe(\n          mapObs(evt => {\n            initFeature(evt.feature)\n            return evt\n          }),\n        ),\n      observableFromOlEvent(this.$interaction, 'drawend'),\n    )\n    this.subscribeTo(drawEvents, evt => {\n      ++this.rev\n      this.$emit(evt.type, evt)\n    })\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Interaction from './interaction.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Interaction, options)\n\n  Vue.component(Interaction.name, Interaction)\n}\n\nexport default plugin\n\nexport {\n  Interaction,\n  plugin as install,\n}\n"],"names":["transformType","type","upperFirst","camelCase","props","source","String","required","clickTolerance","Number","default","snapTolerance","validator","value","GEOMETRY_TYPE","includes","stopClick","Boolean","maxPoints","minPoints","finishCondition","Function","geometryFunction","geometryName","condition","noModifierKeys","freehand","freehandCondition","shiftKeyOnly","wrapX","methods","createInteraction","sourceIdent","makeIdent","$identityMap","get","$options","INSTANCE_PROMISE_POOL","isFunction","getFeatures","features","isCollection","DrawInteraction","isVectorSource","undefined","style","createStyleFunc","getDefaultStyles","defaultStyles","mapValues","defaultEditStyle","styles","map","createStyle","__selectDefaultStyleFunc","feature","getGeometry","getType","getServices","mergeDescriptors","interaction","stylesContainer","getStyleTarget","$interaction","mount","unmount","setStyle","_styles","scheduleRefresh","subscribeAll","subscribeToInteractionChanges","watch","makeWatchers","scheduleRecreate","name","mixins","stubVNode","empty","attrs","class","hasInteraction","drawEvents","mergeObs","observableFromOlEvent","pipe","mapObs","evt","initFeature","subscribeTo","rev","$emit","plugin","Vue","options","installed","pick","Interaction","component"],"mappings":"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"}