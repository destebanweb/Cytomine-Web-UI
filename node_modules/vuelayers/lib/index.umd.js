/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.11.4
 * @license MIT
 * @copyright (c) 2017-2019, Vladimir Vershinin <ghettovoice@gmail.com>
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('ol/Feature'), require('vue'), require('ol/geom/Circle'), require('ol/geom/GeometryCollection'), require('ol/geom/LineString'), require('ol/geom/MultiLineString'), require('ol/geom/MultiPoint'), require('ol/geom/MultiPolygon'), require('ol/geom/Point'), require('ol/geom/Polygon'), require('ol/proj'), require('ol/proj/Projection'), require('ol/format/GeoJSON'), require('ol/format/MVT'), require('ol/format/TopoJSON'), require('ol/extent'), require('ol/proj/Units'), require('ol/interaction/Interaction'), require('ol/layer/Base'), require('ol/Overlay'), require('ol/tilegrid'), require('ol/size'), require('ol/tilegrid/TileGrid'), require('ol/loadingstrategy'), require('ol/style/Circle'), require('ol/style/Fill'), require('ol/style/Icon'), require('ol/style/Image'), require('ol/style/RegularShape'), require('ol/style/Stroke'), require('ol/style/Style'), require('ol/style/Text'), require('ol/source/XYZ'), require('ol/source/TileArcGISRest'), require('ol/source/BingMaps'), require('ol/source/Cluster'), require('ol/events/condition'), require('ol/interaction/Draw'), require('ol/Geolocation'), require('ol/Graticule'), require('ol/layer/Group'), require('ol/layer/Image'), require('ol/source/ImageStatic'), require('ol/source/ImageWMS'), require('ol/source/WMSServerType'), require('ol/control'), require('ol/interaction'), require('ol/layer/Vector'), require('ol/Collection'), require('ol/Map'), require('ol/WebGLMap'), require('ol/source/Vector'), require('ol/View'), require('ol/interaction/Modify'), require('ol/source/OSM'), require('ol/interaction/Select'), require('ol/interaction/Snap'), require('ol/source/Stamen'), require('ol/layer/Tile'), require('ol/layer/VectorTile'), require('ol/source/VectorTile'), require('ol/source/TileWMS'), require('ol/source/WMTS'), require('ol/tilegrid/WMTS')) :
  typeof define === 'function' && define.amd ? define('vuelayers', ['ol/Feature', 'vue', 'ol/geom/Circle', 'ol/geom/GeometryCollection', 'ol/geom/LineString', 'ol/geom/MultiLineString', 'ol/geom/MultiPoint', 'ol/geom/MultiPolygon', 'ol/geom/Point', 'ol/geom/Polygon', 'ol/proj', 'ol/proj/Projection', 'ol/format/GeoJSON', 'ol/format/MVT', 'ol/format/TopoJSON', 'ol/extent', 'ol/proj/Units', 'ol/interaction/Interaction', 'ol/layer/Base', 'ol/Overlay', 'ol/tilegrid', 'ol/size', 'ol/tilegrid/TileGrid', 'ol/loadingstrategy', 'ol/style/Circle', 'ol/style/Fill', 'ol/style/Icon', 'ol/style/Image', 'ol/style/RegularShape', 'ol/style/Stroke', 'ol/style/Style', 'ol/style/Text', 'ol/source/XYZ', 'ol/source/TileArcGISRest', 'ol/source/BingMaps', 'ol/source/Cluster', 'ol/events/condition', 'ol/interaction/Draw', 'ol/Geolocation', 'ol/Graticule', 'ol/layer/Group', 'ol/layer/Image', 'ol/source/ImageStatic', 'ol/source/ImageWMS', 'ol/source/WMSServerType', 'ol/control', 'ol/interaction', 'ol/layer/Vector', 'ol/Collection', 'ol/Map', 'ol/WebGLMap', 'ol/source/Vector', 'ol/View', 'ol/interaction/Modify', 'ol/source/OSM', 'ol/interaction/Select', 'ol/interaction/Snap', 'ol/source/Stamen', 'ol/layer/Tile', 'ol/layer/VectorTile', 'ol/source/VectorTile', 'ol/source/TileWMS', 'ol/source/WMTS', 'ol/tilegrid/WMTS'], factory) :
  (global.VueLayers = factory(global.ol.Feature,global.Vue,global.ol.geom.Circle,global.ol.geom.GeometryCollection,global.ol.geom.LineString,global.ol.geom.MultiLineString,global.ol.geom.MultiPoint,global.ol.geom.MultiPolygon,global.ol.geom.Point,global.ol.geom.Polygon,global.ol.proj,global.ol.proj.Projection,global.ol.format.GeoJSON,global.ol.format.MVT,global.ol.format.TopoJSON,global.ol.extent,global.ol.proj.Units,global.ol.interaction.Interaction,global.ol.layer.Base,global.ol.Overlay,global.ol.tilegrid,global.ol.size,global.ol.tilegrid.TileGrid,global.ol.loadingstrategy,global.ol.style.Circle,global.ol.style.Fill,global.ol.style.Icon,global.ol.style.Image,global.ol.style.RegularShape,global.ol.style.Stroke,global.ol.style.Style,global.ol.style.Text,global.ol.source.XYZ,global.ol.source.TileArcGISRest,global.ol.source.BingMaps,global.ol.source.Cluster,global.ol.events.condition,global.ol.interaction.Draw,global.ol.Geolocation,global.ol.Graticule,global.ol.layer.Group,global.ol.layer.Image,global.ol.source.ImageStatic,global.ol.source.ImageWMS,global.ol.source.WMSServerType,global.ol.control,global.ol.interaction,global.ol.layer.Vector,global.ol.Collection,global.ol.Map,global.ol.WebGLMap,global.ol.source.Vector,global.ol.View,global.ol.interaction.Modify,global.ol.source.OSM,global.ol.interaction.Select,global.ol.interaction.Snap,global.ol.source.Stamen,global.ol.layer.Tile,global.ol.layer.VectorTile,global.ol.source.VectorTile,global.ol.source.TileWMS,global.ol.source.WMTS,global.ol.tilegrid.WMTS));
}(this, (function (Feature,Vue,Circle,GeometryCollection,LineString,MultiLineString,MultiPoint,MultiPolygon,Point,Polygon,proj,Projection,BaseGeoJSON,MVT,TopoJSON,extent,Units,Interaction,BaseLayer,Overlay,tilegrid,size,TileGrid,loadingstrategy,Circle$1,Fill,Icon,ImageStyle,RegularShape,Stroke,Style,Text,XYZSource,TileArcGISRestSource,BingMapsSource,Cluster,condition,DrawInteraction,Geolocation,Graticule,GroupLayer,ImageLayer,ImageStaticSource,ImageWMS,WMSServerType,control,interaction,VectorLayer,Collection,Map,WebGLMap,VectorSource,View,ModifyInteraction,OSMSource,SelectInteraction,SnapInteraction,StamenSource,TileLayer,VectorTileLayer,VectorTileSource,TileWMSSource,WMTSSource,WMTSTileGrid) { 'use strict';

  Feature = Feature && Feature.hasOwnProperty('default') ? Feature['default'] : Feature;
  Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;
  Circle = Circle && Circle.hasOwnProperty('default') ? Circle['default'] : Circle;
  GeometryCollection = GeometryCollection && GeometryCollection.hasOwnProperty('default') ? GeometryCollection['default'] : GeometryCollection;
  LineString = LineString && LineString.hasOwnProperty('default') ? LineString['default'] : LineString;
  MultiLineString = MultiLineString && MultiLineString.hasOwnProperty('default') ? MultiLineString['default'] : MultiLineString;
  MultiPoint = MultiPoint && MultiPoint.hasOwnProperty('default') ? MultiPoint['default'] : MultiPoint;
  MultiPolygon = MultiPolygon && MultiPolygon.hasOwnProperty('default') ? MultiPolygon['default'] : MultiPolygon;
  Point = Point && Point.hasOwnProperty('default') ? Point['default'] : Point;
  var Polygon__default = 'default' in Polygon ? Polygon['default'] : Polygon;
  Projection = Projection && Projection.hasOwnProperty('default') ? Projection['default'] : Projection;
  BaseGeoJSON = BaseGeoJSON && BaseGeoJSON.hasOwnProperty('default') ? BaseGeoJSON['default'] : BaseGeoJSON;
  MVT = MVT && MVT.hasOwnProperty('default') ? MVT['default'] : MVT;
  TopoJSON = TopoJSON && TopoJSON.hasOwnProperty('default') ? TopoJSON['default'] : TopoJSON;
  Interaction = Interaction && Interaction.hasOwnProperty('default') ? Interaction['default'] : Interaction;
  BaseLayer = BaseLayer && BaseLayer.hasOwnProperty('default') ? BaseLayer['default'] : BaseLayer;
  Overlay = Overlay && Overlay.hasOwnProperty('default') ? Overlay['default'] : Overlay;
  TileGrid = TileGrid && TileGrid.hasOwnProperty('default') ? TileGrid['default'] : TileGrid;
  Circle$1 = Circle$1 && Circle$1.hasOwnProperty('default') ? Circle$1['default'] : Circle$1;
  Fill = Fill && Fill.hasOwnProperty('default') ? Fill['default'] : Fill;
  Icon = Icon && Icon.hasOwnProperty('default') ? Icon['default'] : Icon;
  ImageStyle = ImageStyle && ImageStyle.hasOwnProperty('default') ? ImageStyle['default'] : ImageStyle;
  RegularShape = RegularShape && RegularShape.hasOwnProperty('default') ? RegularShape['default'] : RegularShape;
  Stroke = Stroke && Stroke.hasOwnProperty('default') ? Stroke['default'] : Stroke;
  Style = Style && Style.hasOwnProperty('default') ? Style['default'] : Style;
  Text = Text && Text.hasOwnProperty('default') ? Text['default'] : Text;
  XYZSource = XYZSource && XYZSource.hasOwnProperty('default') ? XYZSource['default'] : XYZSource;
  TileArcGISRestSource = TileArcGISRestSource && TileArcGISRestSource.hasOwnProperty('default') ? TileArcGISRestSource['default'] : TileArcGISRestSource;
  BingMapsSource = BingMapsSource && BingMapsSource.hasOwnProperty('default') ? BingMapsSource['default'] : BingMapsSource;
  Cluster = Cluster && Cluster.hasOwnProperty('default') ? Cluster['default'] : Cluster;
  DrawInteraction = DrawInteraction && DrawInteraction.hasOwnProperty('default') ? DrawInteraction['default'] : DrawInteraction;
  Geolocation = Geolocation && Geolocation.hasOwnProperty('default') ? Geolocation['default'] : Geolocation;
  Graticule = Graticule && Graticule.hasOwnProperty('default') ? Graticule['default'] : Graticule;
  GroupLayer = GroupLayer && GroupLayer.hasOwnProperty('default') ? GroupLayer['default'] : GroupLayer;
  ImageLayer = ImageLayer && ImageLayer.hasOwnProperty('default') ? ImageLayer['default'] : ImageLayer;
  ImageStaticSource = ImageStaticSource && ImageStaticSource.hasOwnProperty('default') ? ImageStaticSource['default'] : ImageStaticSource;
  ImageWMS = ImageWMS && ImageWMS.hasOwnProperty('default') ? ImageWMS['default'] : ImageWMS;
  WMSServerType = WMSServerType && WMSServerType.hasOwnProperty('default') ? WMSServerType['default'] : WMSServerType;
  VectorLayer = VectorLayer && VectorLayer.hasOwnProperty('default') ? VectorLayer['default'] : VectorLayer;
  Collection = Collection && Collection.hasOwnProperty('default') ? Collection['default'] : Collection;
  Map = Map && Map.hasOwnProperty('default') ? Map['default'] : Map;
  WebGLMap = WebGLMap && WebGLMap.hasOwnProperty('default') ? WebGLMap['default'] : WebGLMap;
  VectorSource = VectorSource && VectorSource.hasOwnProperty('default') ? VectorSource['default'] : VectorSource;
  View = View && View.hasOwnProperty('default') ? View['default'] : View;
  ModifyInteraction = ModifyInteraction && ModifyInteraction.hasOwnProperty('default') ? ModifyInteraction['default'] : ModifyInteraction;
  OSMSource = OSMSource && OSMSource.hasOwnProperty('default') ? OSMSource['default'] : OSMSource;
  SelectInteraction = SelectInteraction && SelectInteraction.hasOwnProperty('default') ? SelectInteraction['default'] : SelectInteraction;
  SnapInteraction = SnapInteraction && SnapInteraction.hasOwnProperty('default') ? SnapInteraction['default'] : SnapInteraction;
  StamenSource = StamenSource && StamenSource.hasOwnProperty('default') ? StamenSource['default'] : StamenSource;
  TileLayer = TileLayer && TileLayer.hasOwnProperty('default') ? TileLayer['default'] : TileLayer;
  VectorTileLayer = VectorTileLayer && VectorTileLayer.hasOwnProperty('default') ? VectorTileLayer['default'] : VectorTileLayer;
  VectorTileSource = VectorTileSource && VectorTileSource.hasOwnProperty('default') ? VectorTileSource['default'] : VectorTileSource;
  TileWMSSource = TileWMSSource && TileWMSSource.hasOwnProperty('default') ? TileWMSSource['default'] : TileWMSSource;
  WMTSSource = WMTSSource && WMTSSource.hasOwnProperty('default') ? WMTSSource['default'] : WMTSSource;
  WMTSTileGrid = WMTSTileGrid && WMTSTileGrid.hasOwnProperty('default') ? WMTSTileGrid['default'] : WMTSTileGrid;

  var toString = {}.toString;

  var _cof = function (it) {
    return toString.call(it).slice(8, -1);
  };

  // fallback for non-array-like ES3 and non-enumerable old V8 strings

  // eslint-disable-next-line no-prototype-builtins
  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return _cof(it) == 'String' ? it.split('') : Object(it);
  };

  // 7.2.1 RequireObjectCoercible(argument)
  var _defined = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };

  // to indexed object, toObject with fallback for non-array-like ES3 strings


  var _toIobject = function (it) {
    return _iobject(_defined(it));
  };

  var f = {}.propertyIsEnumerable;

  var _objectPie = {
  	f: f
  };

  var _propertyDesc = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _isObject = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  // 7.1.1 ToPrimitive(input [, PreferredType])

  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  var _toPrimitive = function (it, S) {
    if (!_isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var hasOwnProperty = {}.hasOwnProperty;
  var _has = function (it, key) {
    return hasOwnProperty.call(it, key);
  };

  var _fails = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };

  // Thank's IE8 for his funny defineProperty
  var _descriptors = !_fails(function () {
    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  });

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var _global = createCommonjsModule(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self
    // eslint-disable-next-line no-new-func
    : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
  });

  var document$1 = _global.document;
  // typeof document.createElement is 'object' in old IE
  var is = _isObject(document$1) && _isObject(document$1.createElement);
  var _domCreate = function (it) {
    return is ? document$1.createElement(it) : {};
  };

  var _ie8DomDefine = !_descriptors && !_fails(function () {
    return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
  });

  var gOPD = Object.getOwnPropertyDescriptor;

  var f$1 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
    O = _toIobject(O);
    P = _toPrimitive(P, true);
    if (_ie8DomDefine) try {
      return gOPD(O, P);
    } catch (e) { /* empty */ }
    if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
  };

  var _objectGopd = {
  	f: f$1
  };

  var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.5.7' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
  });
  var _core_1 = _core.version;

  var _aFunction = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };

  // optional / simple context binding

  var _ctx = function (fn, that, length) {
    _aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };

  var _anObject = function (it) {
    if (!_isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };

  var dP = Object.defineProperty;

  var f$2 = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject(O);
    P = _toPrimitive(P, true);
    _anObject(Attributes);
    if (_ie8DomDefine) try {
      return dP(O, P, Attributes);
    } catch (e) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var _objectDp = {
  	f: f$2
  };

  var _hide = _descriptors ? function (object, key, value) {
    return _objectDp.f(object, key, _propertyDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var PROTOTYPE = 'prototype';

  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var IS_WRAP = type & $export.W;
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE];
    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
    var key, own, out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      if (own && _has(exports, key)) continue;
      // export native or passed
      out = own ? target[key] : source[key];
      // prevent global pollution for namespaces
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
      // bind timers to global for call from export context
      : IS_BIND && own ? _ctx(out, _global)
      // wrap global constructors for prevent change them in library
      : IS_WRAP && target[key] == out ? (function (C) {
        var F = function (a, b, c) {
          if (this instanceof C) {
            switch (arguments.length) {
              case 0: return new C();
              case 1: return new C(a);
              case 2: return new C(a, b);
            } return new C(a, b, c);
          } return C.apply(this, arguments);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      // make static versions for prototype methods
      })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
      // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out;
        // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
        if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
      }
    }
  };
  // type bitmap
  $export.F = 1;   // forced
  $export.G = 2;   // global
  $export.S = 4;   // static
  $export.P = 8;   // proto
  $export.B = 16;  // bind
  $export.W = 32;  // wrap
  $export.U = 64;  // safe
  $export.R = 128; // real proto method for `library`
  var _export = $export;

  // most Object methods by ES6 should accept primitives



  var _objectSap = function (KEY, exec) {
    var fn = (_core.Object || {})[KEY] || Object[KEY];
    var exp = {};
    exp[KEY] = exec(fn);
    _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
  };

  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)

  var $getOwnPropertyDescriptor = _objectGopd.f;

  _objectSap('getOwnPropertyDescriptor', function () {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(_toIobject(it), key);
    };
  });

  var $Object = _core.Object;
  var getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    return $Object.getOwnPropertyDescriptor(it, key);
  };

  var getOwnPropertyDescriptor$1 = getOwnPropertyDescriptor;

  var _redefine = _hide;

  var id = 0;
  var px = Math.random();
  var _uid = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };

  var _meta = createCommonjsModule(function (module) {
  var META = _uid('meta');


  var setDesc = _objectDp.f;
  var id = 0;
  var isExtensible = Object.isExtensible || function () {
    return true;
  };
  var FREEZE = !_fails(function () {
    return isExtensible(Object.preventExtensions({}));
  });
  var setMeta = function (it) {
    setDesc(it, META, { value: {
      i: 'O' + ++id, // object ID
      w: {}          // weak collections IDs
    } });
  };
  var fastKey = function (it, create) {
    // return primitive with prefix
    if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F';
      // not necessary to add metadata
      if (!create) return 'E';
      // add missing metadata
      setMeta(it);
    // return object ID
    } return it[META].i;
  };
  var getWeak = function (it, create) {
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true;
      // not necessary to add metadata
      if (!create) return false;
      // add missing metadata
      setMeta(it);
    // return hash weak collections IDs
    } return it[META].w;
  };
  // add metadata on freeze-family methods calling
  var onFreeze = function (it) {
    if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
    return it;
  };
  var meta = module.exports = {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze
  };
  });
  var _meta_1 = _meta.KEY;
  var _meta_2 = _meta.NEED;
  var _meta_3 = _meta.fastKey;
  var _meta_4 = _meta.getWeak;
  var _meta_5 = _meta.onFreeze;

  var _library = true;

  var _shared = createCommonjsModule(function (module) {
  var SHARED = '__core-js_shared__';
  var store = _global[SHARED] || (_global[SHARED] = {});

  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: _core.version,
    mode: 'pure',
    copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
  });
  });

  var _wks = createCommonjsModule(function (module) {
  var store = _shared('wks');

  var Symbol = _global.Symbol;
  var USE_SYMBOL = typeof Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] =
      USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
  };

  $exports.store = store;
  });

  var def = _objectDp.f;

  var TAG = _wks('toStringTag');

  var _setToStringTag = function (it, tag, stat) {
    if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
  };

  var f$3 = _wks;

  var _wksExt = {
  	f: f$3
  };

  var defineProperty = _objectDp.f;
  var _wksDefine = function (name) {
    var $Symbol = _core.Symbol || (_core.Symbol = {});
    if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: _wksExt.f(name) });
  };

  // 7.1.4 ToInteger
  var ceil = Math.ceil;
  var floor = Math.floor;
  var _toInteger = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };

  // 7.1.15 ToLength

  var min = Math.min;
  var _toLength = function (it) {
    return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };

  var max = Math.max;
  var min$1 = Math.min;
  var _toAbsoluteIndex = function (index, length) {
    index = _toInteger(index);
    return index < 0 ? max(index + length, 0) : min$1(index, length);
  };

  // false -> Array#indexOf
  // true  -> Array#includes



  var _arrayIncludes = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = _toIobject($this);
      var length = _toLength(O.length);
      var index = _toAbsoluteIndex(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var shared = _shared('keys');

  var _sharedKey = function (key) {
    return shared[key] || (shared[key] = _uid(key));
  };

  var arrayIndexOf = _arrayIncludes(false);
  var IE_PROTO = _sharedKey('IE_PROTO');

  var _objectKeysInternal = function (object, names) {
    var O = _toIobject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };

  // IE 8- don't enum bug keys
  var _enumBugKeys = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');

  // 19.1.2.14 / 15.2.3.14 Object.keys(O)



  var _objectKeys = Object.keys || function keys(O) {
    return _objectKeysInternal(O, _enumBugKeys);
  };

  var f$4 = Object.getOwnPropertySymbols;

  var _objectGops = {
  	f: f$4
  };

  // all enumerable object keys, includes symbols



  var _enumKeys = function (it) {
    var result = _objectKeys(it);
    var getSymbols = _objectGops.f;
    if (getSymbols) {
      var symbols = getSymbols(it);
      var isEnum = _objectPie.f;
      var i = 0;
      var key;
      while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
    } return result;
  };

  // 7.2.2 IsArray(argument)

  var _isArray = Array.isArray || function isArray(arg) {
    return _cof(arg) == 'Array';
  };

  var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    _anObject(O);
    var keys = _objectKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;
    while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
    return O;
  };

  var document$2 = _global.document;
  var _html = document$2 && document$2.documentElement;

  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



  var IE_PROTO$1 = _sharedKey('IE_PROTO');
  var Empty = function () { /* empty */ };
  var PROTOTYPE$1 = 'prototype';

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var createDict = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = _domCreate('iframe');
    var i = _enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    _html.appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
    return createDict();
  };

  var _objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE$1] = _anObject(O);
      result = new Empty();
      Empty[PROTOTYPE$1] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO$1] = O;
    } else result = createDict();
    return Properties === undefined ? result : _objectDps(result, Properties);
  };

  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

  var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

  var f$5 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return _objectKeysInternal(O, hiddenKeys);
  };

  var _objectGopn = {
  	f: f$5
  };

  // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

  var gOPN = _objectGopn.f;
  var toString$1 = {}.toString;

  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
    ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function (it) {
    try {
      return gOPN(it);
    } catch (e) {
      return windowNames.slice();
    }
  };

  var f$6 = function getOwnPropertyNames(it) {
    return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(_toIobject(it));
  };

  var _objectGopnExt = {
  	f: f$6
  };

  // ECMAScript 6 symbols shim





  var META = _meta.KEY;



















  var gOPD$1 = _objectGopd.f;
  var dP$1 = _objectDp.f;
  var gOPN$1 = _objectGopnExt.f;
  var $Symbol = _global.Symbol;
  var $JSON = _global.JSON;
  var _stringify = $JSON && $JSON.stringify;
  var PROTOTYPE$2 = 'prototype';
  var HIDDEN = _wks('_hidden');
  var TO_PRIMITIVE = _wks('toPrimitive');
  var isEnum = {}.propertyIsEnumerable;
  var SymbolRegistry = _shared('symbol-registry');
  var AllSymbols = _shared('symbols');
  var OPSymbols = _shared('op-symbols');
  var ObjectProto = Object[PROTOTYPE$2];
  var USE_NATIVE = typeof $Symbol == 'function';
  var QObject = _global.QObject;
  // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
  var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;

  // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
  var setSymbolDesc = _descriptors && _fails(function () {
    return _objectCreate(dP$1({}, 'a', {
      get: function () { return dP$1(this, 'a', { value: 7 }).a; }
    })).a != 7;
  }) ? function (it, key, D) {
    var protoDesc = gOPD$1(ObjectProto, key);
    if (protoDesc) delete ObjectProto[key];
    dP$1(it, key, D);
    if (protoDesc && it !== ObjectProto) dP$1(ObjectProto, key, protoDesc);
  } : dP$1;

  var wrap = function (tag) {
    var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);
    sym._k = tag;
    return sym;
  };

  var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    return it instanceof $Symbol;
  };

  var $defineProperty = function defineProperty(it, key, D) {
    if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
    _anObject(it);
    key = _toPrimitive(key, true);
    _anObject(D);
    if (_has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!_has(it, HIDDEN)) dP$1(it, HIDDEN, _propertyDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
        D = _objectCreate(D, { enumerable: _propertyDesc(0, false) });
      } return setSymbolDesc(it, key, D);
    } return dP$1(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    _anObject(it);
    var keys = _enumKeys(P = _toIobject(P));
    var i = 0;
    var l = keys.length;
    var key;
    while (l > i) $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key = _toPrimitive(key, true));
    if (this === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
    return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor$1 = function getOwnPropertyDescriptor(it, key) {
    it = _toIobject(it);
    key = _toPrimitive(key, true);
    if (it === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
    var D = gOPD$1(it, key);
    if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = gOPN$1(_toIobject(it));
    var result = [];
    var i = 0;
    var key;
    while (names.length > i) {
      if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
    } return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var IS_OP = it === ObjectProto;
    var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
    var result = [];
    var i = 0;
    var key;
    while (names.length > i) {
      if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
    } return result;
  };

  // 19.4.1.1 Symbol([description])
  if (!USE_NATIVE) {
    $Symbol = function Symbol() {
      if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
      var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);
      var $set = function (value) {
        if (this === ObjectProto) $set.call(OPSymbols, value);
        if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, _propertyDesc(1, value));
      };
      if (_descriptors && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
      return wrap(tag);
    };
    _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
      return this._k;
    });

    _objectGopd.f = $getOwnPropertyDescriptor$1;
    _objectDp.f = $defineProperty;
    _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
    _objectPie.f = $propertyIsEnumerable;
    _objectGops.f = $getOwnPropertySymbols;

    if (_descriptors && !_library) {
      _redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }

    _wksExt.f = function (name) {
      return wrap(_wks(name));
    };
  }

  _export(_export.G + _export.W + _export.F * !USE_NATIVE, { Symbol: $Symbol });

  for (var es6Symbols = (
    // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), j = 0; es6Symbols.length > j;)_wks(es6Symbols[j++]);

  for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) _wksDefine(wellKnownSymbols[k++]);

  _export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {
    // 19.4.2.1 Symbol.for(key)
    'for': function (key) {
      return _has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = $Symbol(key);
    },
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
      for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
    },
    useSetter: function () { setter = true; },
    useSimple: function () { setter = false; }
  });

  _export(_export.S + _export.F * !USE_NATIVE, 'Object', {
    // 19.1.2.2 Object.create(O [, Properties])
    create: $create,
    // 19.1.2.4 Object.defineProperty(O, P, Attributes)
    defineProperty: $defineProperty,
    // 19.1.2.3 Object.defineProperties(O, Properties)
    defineProperties: $defineProperties,
    // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor$1,
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: $getOwnPropertyNames,
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: $getOwnPropertySymbols
  });

  // 24.3.2 JSON.stringify(value [, replacer [, space]])
  $JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function () {
    var S = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    // WebKit converts symbol values to JSON as null
    // V8 throws on boxed symbols
    return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
  })), 'JSON', {
    stringify: function stringify(it) {
      var args = [it];
      var i = 1;
      var replacer, $replacer;
      while (arguments.length > i) args.push(arguments[i++]);
      $replacer = replacer = args[1];
      if (!_isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!_isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return _stringify.apply($JSON, args);
    }
  });

  // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
  $Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
  // 19.4.3.5 Symbol.prototype[@@toStringTag]
  _setToStringTag($Symbol, 'Symbol');
  // 20.2.1.9 Math[@@toStringTag]
  _setToStringTag(Math, 'Math', true);
  // 24.3.3 JSON[@@toStringTag]
  _setToStringTag(_global.JSON, 'JSON', true);

  var getOwnPropertySymbols = _core.Object.getOwnPropertySymbols;

  var getOwnPropertySymbols$1 = getOwnPropertySymbols;

  // 7.1.13 ToObject(argument)

  var _toObject = function (it) {
    return Object(_defined(it));
  };

  // 19.1.2.14 Object.keys(O)



  _objectSap('keys', function () {
    return function keys(it) {
      return _objectKeys(_toObject(it));
    };
  });

  var keys = _core.Object.keys;

  var keys$1 = keys;

  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
  _export(_export.S + _export.F * !_descriptors, 'Object', { defineProperty: _objectDp.f });

  var $Object$1 = _core.Object;
  var defineProperty$1 = function defineProperty(it, key, desc) {
    return $Object$1.defineProperty(it, key, desc);
  };

  var defineProperty$2 = defineProperty$1;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      defineProperty$2(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      var ownKeys = keys$1(source);

      if (typeof getOwnPropertySymbols$1 === 'function') {
        ownKeys = ownKeys.concat(getOwnPropertySymbols$1(source).filter(function (sym) {
          return getOwnPropertyDescriptor$1(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  // 19.1.2.1 Object.assign(target, source, ...)





  var $assign = Object.assign;

  // should work with symbols and should have deterministic property order (V8 bug)
  var _objectAssign = !$assign || _fails(function () {
    var A = {};
    var B = {};
    // eslint-disable-next-line no-undef
    var S = Symbol();
    var K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) { B[k] = k; });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source) { // eslint-disable-line no-unused-vars
    var T = _toObject(target);
    var aLen = arguments.length;
    var index = 1;
    var getSymbols = _objectGops.f;
    var isEnum = _objectPie.f;
    while (aLen > index) {
      var S = _iobject(arguments[index++]);
      var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
      var length = keys.length;
      var j = 0;
      var key;
      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    } return T;
  } : $assign;

  // 19.1.3.1 Object.assign(target, source)


  _export(_export.S + _export.F, 'Object', { assign: _objectAssign });

  var assign = _core.Object.assign;

  var assign$1 = assign;

  var runtime = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  !(function(global) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    var runtime = global.regeneratorRuntime;
    if (runtime) {
      {
        // If regeneratorRuntime is defined globally and we're in a module,
        // make the exports object identical to regeneratorRuntime.
        module.exports = runtime;
      }
      // Don't bother evaluating the rest of this file if the runtime was
      // already defined globally.
      return;
    }

    // Define the runtime globally (as expected by generated code) as either
    // module.exports (if we're in a module) or a new, empty object.
    runtime = global.regeneratorRuntime = module.exports;

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);

      return generator;
    }
    runtime.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] =
      GeneratorFunction.displayName = "GeneratorFunction";

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        prototype[method] = function(arg) {
          return this._invoke(method, arg);
        };
      });
    }

    runtime.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };

    runtime.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    runtime.awrap = function(arg) {
      return { __await: arg };
    };

    function AsyncIterator(generator) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return Promise.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return Promise.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new Promise(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };
    runtime.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    runtime.async = function(innerFn, outerFn, self, tryLocsList) {
      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList)
      );

      return runtime.isGeneratorFunction(outerFn)
        ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;

      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;

          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);

          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;

          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };

          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          if (delegate.iterator.return) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined;
        }

      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);

    Gp[toStringTagSymbol] = "Generator";

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function() {
      return this;
    };

    Gp.toString = function() {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    runtime.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined;
            next.done = true;

            return next;
          };

          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return { next: doneResult };
    }
    runtime.values = values;

    function doneResult() {
      return { value: undefined, done: true };
    }

    Context.prototype = {
      constructor: Context,

      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined;
        this.done = false;
        this.delegate = null;

        this.method = "next";
        this.arg = undefined;

        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined;
            }
          }
        }
      },

      stop: function() {
        this.done = true;

        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },

      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined;
          }

          return !! caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }

            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },

      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },

      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },

      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },

      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },

      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined;
        }

        return ContinueSentinel;
      }
    };
  })(
    // In sloppy mode, unbound `this` refers to the global object, fallback to
    // Function constructor if we're in global strict mode. That is sadly a form
    // of indirect eval which violates Content Security Policy.
    (function() {
      return this || (typeof self === "object" && self);
    })() || Function("return this")()
  );
  });

  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // This method of obtaining a reference to the global object needs to be
  // kept identical to the way it is obtained in runtime.js
  var g$1 = (function() {
    return this || (typeof self === "object" && self);
  })() || Function("return this")();

  // Use `getOwnPropertyNames` because not all browsers support calling
  // `hasOwnProperty` on the global `self` object in a worker. See #183.
  var hadRuntime = g$1.regeneratorRuntime &&
    Object.getOwnPropertyNames(g$1).indexOf("regeneratorRuntime") >= 0;

  // Save the old regeneratorRuntime in case it needs to be restored later.
  var oldRuntime = hadRuntime && g$1.regeneratorRuntime;

  // Force reevalutation of runtime.js.
  g$1.regeneratorRuntime = undefined;

  var runtimeModule = runtime;

  if (hadRuntime) {
    // Restore the original runtime.
    g$1.regeneratorRuntime = oldRuntime;
  } else {
    // Remove the global property added by runtime.js.
    try {
      delete g$1.regeneratorRuntime;
    } catch(e) {
      g$1.regeneratorRuntime = undefined;
    }
  }

  var regenerator = runtimeModule;

  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


  var IE_PROTO$2 = _sharedKey('IE_PROTO');
  var ObjectProto$1 = Object.prototype;

  var _objectGpo = Object.getPrototypeOf || function (O) {
    O = _toObject(O);
    if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto$1 : null;
  };

  // 19.1.2.9 Object.getPrototypeOf(O)



  _objectSap('getPrototypeOf', function () {
    return function getPrototypeOf(it) {
      return _objectGpo(_toObject(it));
    };
  });

  var getPrototypeOf = _core.Object.getPrototypeOf;

  var getPrototypeOf$1 = getPrototypeOf;

  // true  -> String#at
  // false -> String#codePointAt
  var _stringAt = function (TO_STRING) {
    return function (that, pos) {
      var s = String(_defined(that));
      var i = _toInteger(pos);
      var l = s.length;
      var a, b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };

  var _iterators = {};

  var IteratorPrototype = {};

  // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
  _hide(IteratorPrototype, _wks('iterator'), function () { return this; });

  var _iterCreate = function (Constructor, NAME, next) {
    Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
    _setToStringTag(Constructor, NAME + ' Iterator');
  };

  var ITERATOR = _wks('iterator');
  var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
  var FF_ITERATOR = '@@iterator';
  var KEYS = 'keys';
  var VALUES = 'values';

  var returnThis = function () { return this; };

  var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    _iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS: return function keys() { return new Constructor(this, kind); };
        case VALUES: return function values() { return new Constructor(this, kind); };
      } return function entries() { return new Constructor(this, kind); };
    };
    var TAG = NAME + ' Iterator';
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype;
    // Fix native
    if ($anyNative) {
      IteratorPrototype = _objectGpo($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        // Set @@toStringTag to native iterators
        _setToStringTag(IteratorPrototype, TAG, true);
        // fix for some old engines
        if (!_library && typeof IteratorPrototype[ITERATOR] != 'function') _hide(IteratorPrototype, ITERATOR, returnThis);
      }
    }
    // fix Array#{values, @@iterator}.name in V8 / FF
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() { return $native.call(this); };
    }
    // Define iterator
    if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      _hide(proto, ITERATOR, $default);
    }
    // Plug for library
    _iterators[NAME] = $default;
    _iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) _redefine(proto, key, methods[key]);
      } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };

  var $at = _stringAt(true);

  // 21.1.3.27 String.prototype[@@iterator]()
  _iterDefine(String, 'String', function (iterated) {
    this._t = String(iterated); // target
    this._i = 0;                // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var index = this._i;
    var point;
    if (index >= O.length) return { value: undefined, done: true };
    point = $at(O, index);
    this._i += point.length;
    return { value: point, done: false };
  });

  var _iterStep = function (done, value) {
    return { value: value, done: !!done };
  };

  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
    this._t = _toIobject(iterated); // target
    this._i = 0;                   // next index
    this._k = kind;                // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function () {
    var O = this._t;
    var kind = this._k;
    var index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return _iterStep(1);
    }
    if (kind == 'keys') return _iterStep(0, index);
    if (kind == 'values') return _iterStep(0, O[index]);
    return _iterStep(0, [index, O[index]]);
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  _iterators.Arguments = _iterators.Array;

  var TO_STRING_TAG = _wks('toStringTag');

  var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
    'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
    'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
    'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
    'TextTrackList,TouchList').split(',');

  for (var i = 0; i < DOMIterables.length; i++) {
    var NAME = DOMIterables[i];
    var Collection$1 = _global[NAME];
    var proto = Collection$1 && Collection$1.prototype;
    if (proto && !proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
    _iterators[NAME] = _iterators.Array;
  }

  var iterator = _wksExt.f('iterator');

  var iterator$1 = iterator;

  _wksDefine('asyncIterator');

  _wksDefine('observable');

  var symbol = _core.Symbol;

  var symbol$1 = symbol;

  function _typeof2(obj) { if (typeof symbol$1 === "function" && typeof iterator$1 === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof symbol$1 === "function" && obj.constructor === symbol$1 && obj !== symbol$1.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

  function _typeof(obj) {
    if (typeof symbol$1 === "function" && _typeof2(iterator$1) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof symbol$1 === "function" && obj.constructor === symbol$1 && obj !== symbol$1.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var space = '[' + _stringWs + ']';
  var non = '\u200b\u0085';
  var ltrim = RegExp('^' + space + space + '*');
  var rtrim = RegExp(space + space + '*$');

  var exporter = function (KEY, exec, ALIAS) {
    var exp = {};
    var FORCE = _fails(function () {
      return !!_stringWs[KEY]() || non[KEY]() != non;
    });
    var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
    if (ALIAS) exp[ALIAS] = fn;
    _export(_export.P + _export.F * FORCE, 'String', exp);
  };

  // 1 -> String#trimLeft
  // 2 -> String#trimRight
  // 3 -> String#trim
  var trim = exporter.trim = function (string, TYPE) {
    string = String(_defined(string));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };

  var _stringTrim = exporter;

  var $parseFloat = _global.parseFloat;
  var $trim = _stringTrim.trim;

  var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
    var string = $trim(String(str), 3);
    var result = $parseFloat(string);
    return result === 0 && string.charAt(0) == '-' ? -0 : result;
  } : $parseFloat;

  // 18.2.4 parseFloat(string)
  _export(_export.G + _export.F * (parseFloat != _parseFloat), { parseFloat: _parseFloat });

  var _parseFloat$1 = _core.parseFloat;

  var _parseFloat$2 = _parseFloat$1;

  // 22.1.2.2 / 15.4.3.2 Array.isArray(arg)


  _export(_export.S, 'Array', { isArray: _isArray });

  var isArray = _core.Array.isArray;

  var isArray$1 = isArray;

  // call something on iterator step with safe closing on error

  var _iterCall = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) _anObject(ret.call(iterator));
      throw e;
    }
  };

  // check on default Array iterator

  var ITERATOR$1 = _wks('iterator');
  var ArrayProto = Array.prototype;

  var _isArrayIter = function (it) {
    return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
  };

  var _createProperty = function (object, index, value) {
    if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));
    else object[index] = value;
  };

  // getting tag from 19.1.3.6 Object.prototype.toString()

  var TAG$1 = _wks('toStringTag');
  // ES3 wrong here
  var ARG = _cof(function () { return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) { /* empty */ }
  };

  var _classof = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
      // builtinTag case
      : ARG ? _cof(O)
      // ES3 arguments fallback
      : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };

  var ITERATOR$2 = _wks('iterator');

  var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR$2]
      || it['@@iterator']
      || _iterators[_classof(it)];
  };

  var ITERATOR$3 = _wks('iterator');
  var SAFE_CLOSING = false;

  try {
    var riter = [7][ITERATOR$3]();
    riter['return'] = function () { SAFE_CLOSING = true; };
  } catch (e) { /* empty */ }

  var _iterDetect = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7];
      var iter = arr[ITERATOR$3]();
      iter.next = function () { return { done: safe = true }; };
      arr[ITERATOR$3] = function () { return iter; };
      exec(arr);
    } catch (e) { /* empty */ }
    return safe;
  };

  _export(_export.S + _export.F * !_iterDetect(function (iter) { }), 'Array', {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
      var O = _toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var index = 0;
      var iterFn = core_getIteratorMethod(O);
      var length, result, step, iterator;
      if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
      // if object isn't iterable or it's array with default iterator - use simple case
      if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
        }
      } else {
        length = _toLength(O.length);
        for (result = new C(length); length > index; index++) {
          _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }
      result.length = index;
      return result;
    }
  });

  var from_1 = _core.Array.from;

  var from_1$1 = from_1;

  var _context;

  var _marked =
  /*#__PURE__*/
  regenerator.mark(range);

  /**
   * Mini Lodash.
   * @module util/minilo
   */
  var glob = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};
  var globIsFinite = glob.isFinite || noop;
  var objectProto = Object.prototype;
  var funcProto = Object.prototype;
  var objectToString = objectProto.toString;
  var funcToString = funcProto.toString;
  var objectTag = (_context = {}, objectToString).call(_context);
  var numberTag = (_context = 0, objectToString).call(_context);
  var stringTag = (_context = '', objectToString).call(_context);
  var booleanTag = (_context = true, objectToString).call(_context);
  var objectCtorString = funcToString.call(Object);
  function noop() {// do nothing
  }
  function constant(value) {
    return function () {
      return value;
    };
  }
  function stubArray() {
    return [];
  }
  function identity(value) {
    return value;
  }
  function isBoolean(value) {
    return objectToString.call(value) === booleanTag;
  }
  function isNumber(value) {
    return objectToString.call(value) === numberTag;
  }
  function isString(value) {
    return objectToString.call(value) === stringTag;
  }
  function isArray$2(value) {
    return isArray$1(value);
  }
  function isArrayLike(value) {
    return isObjectLike(value) && value.hasOwnProperty('length');
  }
  function isFinite(value) {
    return typeof value === 'number' && globIsFinite(value);
  }
  function isFunction(value) {
    return typeof value === 'function';
  }
  /**
   * @param {*} value
   * @return {boolean} True if value is number or numeric string.
   */

  function isNumeric(value) {
    return !isNaN(_parseFloat$2(value)) && globIsFinite(value);
  }
  function isObjectLike(value) {
    return value != null && _typeof(value) === 'object';
  }
  function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) !== objectTag) {
      return false;
    }

    var proto = getPrototypeOf$1(value);

    if (proto == null) {
      return true;
    }

    var Ctor = proto.constructor;
    return typeof Ctor === 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
  }
  /**
   * @param {...*} [args]
   *
   * @return {*}
   */

  function coalesce() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args.find(function (val) {
      return val != null;
    });
  }
  /**
   * @param {Object} object
   * @return {Object} Returns object only with plain properties.
   */

  function plainProps(object) {
    var newObject = {};

    var isPlain = function isPlain(x) {
      return isNumeric(x) || isString(x) || isArray$2(x) || isBoolean(x) || isPlainObject(x);
    };

    keys$1(object).forEach(function (key) {
      if (isPlain(object[key])) {
        newObject[key] = object[key];
      }
    });

    return newObject;
  }
  /**
   * Replaces `tokens` in the `string` by values from the `replaces`.
   *
   * @param {string} string
   * @param {Object} replaces
   *
   * @returns {string}
   */

  function replaceTokens(string, replaces) {
    var regExp = new RegExp(keys$1(replaces).map(function (field) {
      return '(\\{' + field + '\\})';
    }).join('|'), 'ig');
    return string.replace(regExp, function (match) {
      return replaces[match.substr(1, match.length - 2)] || '';
    });
  }
  function isEqual(value, other) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      // eslint-disable-next-line no-self-compare
      return value !== value && other !== other;
    }

    var valueProps = keys$1(value);

    var otherProps = keys$1(other);

    if (valueProps.length !== otherProps.length) {
      return false;
    }

    var checked = [];

    var traverse = function traverse(valueProps, otherProps) {
      for (var i = 0, l = valueProps.length; i < l; i++) {
        var valueProp = valueProps[i];

        if (checked.includes(valueProp)) {
          continue;
        }

        if (other.hasOwnProperty(valueProp) === false) {
          return false;
        }

        var otherProp = otherProps[i];

        if (!isEqual(value[valueProp], other[otherProp])) {
          return false;
        }

        checked.push(otherProp);
      }

      return true;
    };

    if (traverse(valueProps, otherProps) === false) {
      return false;
    }

    return traverse(otherProps, valueProps);
  }
  function isEmpty(value) {
    return !value || isArrayLike(value) && value.length === 0 || isObjectLike(value) && keys$1(value).length === 0;
  }
  function isNotEmpty(value) {
    return !isEmpty(value);
  }
  function forEach(collection, iteratee) {
    var keys = keys$1(collection);

    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      var value = collection[key];

      if (iteratee(value, key) === false) {
        return;
      }
    }
  }
  function reduce(collection, iteratee, initial) {
    var result = initial;
    forEach(collection, function (value, key) {
      result = iteratee(result, value, key);
    });
    return result;
  }
  function filter(collection) {
    var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isNotEmpty;
    return reduce(collection, function (newCollection, value, key) {
      if (iteratee(value, key)) {
        if (isArray$2(newCollection)) {
          newCollection.push(value);
        } else {
          newCollection[key] = value;
        }
      }

      return newCollection;
    }, isArray$2(collection) ? [] : {});
  }
  function map(collection) {
    var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
    return reduce(collection, function (newCollection, value, key) {
      newCollection[key] = iteratee(value, key);
      return newCollection;
    }, isArray$2(collection) ? [] : {});
  }
  function mapValues(object) {
    var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
    return map(object, iteratee);
  }
  function firstEl(object) {
    if (!isArrayLike(object)) return;
    return object[0];
  }
  function pick(object, key) {
    for (var _len2 = arguments.length, keys = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      keys[_key2 - 2] = arguments[_key2];
    }

    if (isArray$1(key)) {
      keys = key;
    } else {
      keys = [key].concat(keys);
    }

    return reduce(keys, function (picked, key) {
      picked[key] = object[key];
      return picked;
    }, {});
  }
  function upperFirst(string) {
    string = String(string);

    if (string.length === 0) {
      return '';
    }

    return string[0].toUpperCase() + string.slice(1);
  }
  function lowerFirst(string) {
    string = String(string);

    if (string.length === 0) {
      return '';
    }

    return string[0].toLowerCase() + string.slice(1);
  }
  function range(start, end) {
    var step,
        i,
        _args = arguments;
    return regenerator.wrap(function range$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            step = _args.length > 2 && _args[2] !== undefined ? _args[2] : 1;
            i = start;

          case 2:
            if (!(i < end)) {
              _context2.next = 8;
              break;
            }

            _context2.next = 5;
            return i;

          case 5:
            i += step;
            _context2.next = 2;
            break;

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked, this);
  }
  function get(object, path, defaultValue) {
    // eslint-disable-next-line no-new-func
    var fn = new Function('object', "try { return object.".concat(path, " } catch (e) {}"));
    return coalesce(fn(object), defaultValue);
  }
  function includes(array, value) {
    var comparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isEqual;
    var elems = filter(array, function (elem) {
      return comparator(elem, value);
    });
    return elems.shift();
  }
  function difference(array1, array2) {
    var comparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isEqual;
    return filter(array1, function (value) {
      return !includes(array2, value, comparator);
    });
  }
  /**
   * @param {string} str
   * @return {string}
   */

  function camelCase(str) {
    var regExp = /([-_]\w)/g;
    return str.replace(regExp, function (matches) {
      return matches[1].toUpperCase();
    });
  }

  var $JSON$1 = _core.JSON || (_core.JSON = { stringify: JSON.stringify });
  var stringify = function stringify(it) { // eslint-disable-line no-unused-vars
    return $JSON$1.stringify.apply($JSON$1, arguments);
  };

  var stringify$1 = stringify;

  var _cleanExtParams = function cleanExtParams(params) {
    return reduce(params, function (params, value, key) {
      var filterKeys = ['FORMAT', 'F', 'LAYERS', 'LAYERDEFS', 'DYNAMICLAYERS', 'DPI', 'TRANSPARENT', 'TIME', 'LAYERTIMEOPTIONS', 'GDBVERSION', 'MAPSCALE', 'ROTATION', 'DATUMTRANSFORMATIONS', 'MAPRANGEVALUES', 'LAYERRANGEVALUES', 'LAYERPARAMETERVALUES', 'HISTORICMOMENT'];
      key = key.toUpperCase();

      if (filterKeys.includes(key)) {
        return params;
      }

      params[key] = value;
      return params;
    }, {});
  };

  var serialize = function serialize(value) {
    if (value == null) return value;
    return _typeof(value) === 'object' ? stringify$1(value) : value;
  };

  var props = {
    /**
     * Extra WMS request parameters
     */
    extParams: Object,
    format: {
      type: String,
      default: 'PNG32'
    },
    layers: String,
    layerDefs: [Object, String],
    dynamicLayers: [Object, String],
    dpi: Number,
    transparent: {
      type: Boolean,
      default: true
    },
    time: String,
    layerTimeOptions: [Object, String],
    gdbVersion: String,
    mapScale: String,
    rotation: Number,
    datumTransformations: [Array, String],
    mapRangeValues: [Array, String],
    layerRangeValues: [Array, String],
    layerParameterValues: [Array, String],
    historicMoment: Number
  };
  var computed = {
    cleanExtParams: function cleanExtParams() {
      return this.extParams ? _cleanExtParams(this.extParams) : undefined;
    },
    allParams: function allParams() {
      return _objectSpread({}, this.cleanExtParams, {
        LAYERS: this.layers,
        FORMAT: this.format,
        LAYERDEFS: serialize(this.layerDefs),
        DYNAMICLAYERS: serialize(this.dynamicLayers),
        DPI: this.dpi,
        TRANSPARENT: this.transparent,
        TIME: serialize(this.time),
        LAYERTIMEOPTIONS: serialize(this.layerTimeOptions),
        GDBVERSION: this.gdbVersion,
        MAPSCALE: this.mapScale,
        ROTATION: this.rotation,
        DATUMTRANSFORMATIONS: serialize(this.datumTransformations),
        MAPRANGEVALUES: serialize(this.mapRangeValues),
        LAYERRANGEVALUES: serialize(this.layerRangeValues),
        LAYERPARAMETERVALUES: serialize(this.layerParameterValues),
        HISTORICMOMENT: serialize(this.historicMoment)
      });
    }
  };
  var methods = {};
  var watch = {
    layers: function layers(LAYERS) {
      this.$source && this.$source.updateParams({
        LAYERS: LAYERS
      });
    },
    format: function format(FORMAT) {
      this.$source && this.$source.updateParams({
        FORMAT: FORMAT
      });
    },
    layerDefs: function layerDefs(LAYERDEFS) {
      this.$source && this.$source.updateParams({
        LAYERDEFS: serialize(LAYERDEFS)
      });
    },
    dynamicLayers: function dynamicLayers(DYNAMICLAYERS) {
      this.$source && this.$source.updateParams({
        DYNAMICLAYERS: serialize(DYNAMICLAYERS)
      });
    },
    dpi: function dpi(DPI) {
      this.$source && this.$source.updateParams({
        DPI: DPI
      });
    },
    transparent: function transparent(TRANSPARENT) {
      this.$source && this.$source.updateParams({
        TRANSPARENT: TRANSPARENT
      });
    },
    time: function time(TIME) {
      this.$source && this.$source.updateParams({
        TIME: serialize(TIME)
      });
    },
    layerTimeOptions: function layerTimeOptions(LAYERTIMEOPTIONS) {
      this.$source && this.$source.updateParams({
        LAYERTIMEOPTIONS: serialize(LAYERTIMEOPTIONS)
      });
    },
    gdbVersion: function gdbVersion(GDBVERSION) {
      this.$source && this.$source.updateParams({
        GDBVERSION: GDBVERSION
      });
    },
    mapScale: function mapScale(MAPSCALE) {
      this.$source && this.$source.updateParams({
        MAPSCALE: MAPSCALE
      });
    },
    rotation: function rotation(ROTATION) {
      this.$source && this.$source.updateParams({
        ROTATION: ROTATION
      });
    },
    datumTransformations: function datumTransformations(DATUMTRANSFORMATIONS) {
      this.$source && this.$source.updateParams({
        DATUMTRANSFORMATIONS: serialize(DATUMTRANSFORMATIONS)
      });
    },
    mapRangeValues: function mapRangeValues(MAPRANGEVALUES) {
      this.$source && this.$source.updateParams({
        MAPRANGEVALUES: serialize(MAPRANGEVALUES)
      });
    },
    layerRangeValues: function layerRangeValues(LAYERRANGEVALUES) {
      this.$source && this.$source.updateParams({
        LAYERRANGEVALUES: serialize(LAYERRANGEVALUES)
      });
    },
    layerParameterValues: function layerParameterValues(LAYERPARAMETERVALUES) {
      this.$source && this.$source.updateParams({
        LAYERPARAMETERVALUES: serialize(LAYERPARAMETERVALUES)
      });
    },
    historicMoment: function historicMoment(HISTORICMOMENT) {
      this.$source && this.$source.updateParams({
        HISTORICMOMENT: HISTORICMOMENT
      });
    },
    extParams: function extParams(value) {
      this.$source && this.$source.updateParams(value ? _cleanExtParams(value) : undefined);
    }
  };
  var arcgisSource = {
    props: props,
    computed: computed,
    methods: methods,
    watch: watch
  };

  var rngBrowser = createCommonjsModule(function (module) {
  // Unique ID creation requires a high quality random # generator.  In the
  // browser this is a little complicated due to unknown quality of Math.random()
  // and inconsistent support for the `crypto` API.  We do the best we can via
  // feature-detection

  // getRandomValues needs to be invoked in a context where "this" is a Crypto
  // implementation. Also, find the complete implementation of crypto on IE11.
  var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                        (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

  if (getRandomValues) {
    // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
    var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

    module.exports = function whatwgRNG() {
      getRandomValues(rnds8);
      return rnds8;
    };
  } else {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var rnds = new Array(16);

    module.exports = function mathRNG() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return rnds;
    };
  }
  });

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */
  var byteToHex = [];
  for (var i$1 = 0; i$1 < 256; ++i$1) {
    byteToHex[i$1] = (i$1 + 0x100).toString(16).substr(1);
  }

  function bytesToUuid(buf, offset) {
    var i = offset || 0;
    var bth = byteToHex;
    // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return ([bth[buf[i++]], bth[buf[i++]], 
  	bth[buf[i++]], bth[buf[i++]], '-',
  	bth[buf[i++]], bth[buf[i++]], '-',
  	bth[buf[i++]], bth[buf[i++]], '-',
  	bth[buf[i++]], bth[buf[i++]], '-',
  	bth[buf[i++]], bth[buf[i++]],
  	bth[buf[i++]], bth[buf[i++]],
  	bth[buf[i++]], bth[buf[i++]]]).join('');
  }

  var bytesToUuid_1 = bytesToUuid;

  function v4(options, buf, offset) {
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options === 'binary' ? new Array(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || rngBrowser)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || bytesToUuid_1(rnds);
  }

  var v4_1 = v4;

  /**
   * Basic feature initialization
   * @param feature
   */

  function initFeature(feature) {
    if (feature.getId() == null) {
      feature.setId(v4_1());
    }

    return feature;
  }
  /**
   * @param {Object|Vue|Feature|string|number} feature
   * @return {string|number}
   * @throws {Error}
   */

  function getFeatureId(feature) {
    var id;

    if (isPlainObject(feature) || feature instanceof Vue) {
      id = feature.id;
    } else if (feature instanceof Feature) {
      id = feature.getId();
    } else if (isString(feature) || isNumber(feature)) {
      id = feature;
    } else {
      throw new Error('Illegal feature format');
    }

    return id;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  // Works with __proto__ only. Old v8 can't work with null proto objects.
  /* eslint-disable no-proto */


  var check = function (O, proto) {
    _anObject(O);
    if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
  };
  var _setProto = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
      function (test, buggy, set) {
        try {
          set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
          set(test, []);
          buggy = !(test instanceof Array);
        } catch (e) { buggy = true; }
        return function setPrototypeOf(O, proto) {
          check(O, proto);
          if (buggy) O.__proto__ = proto;
          else set(O, proto);
          return O;
        };
      }({}, false) : undefined),
    check: check
  };

  // 19.1.3.19 Object.setPrototypeOf(O, proto)

  _export(_export.S, 'Object', { setPrototypeOf: _setProto.set });

  var setPrototypeOf = _core.Object.setPrototypeOf;

  var setPrototypeOf$1 = setPrototypeOf;

  function _getPrototypeOf(o) {
    _getPrototypeOf = setPrototypeOf$1 ? getPrototypeOf$1 : function _getPrototypeOf(o) {
      return o.__proto__ || getPrototypeOf$1(o);
    };
    return _getPrototypeOf(o);
  }

  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  _export(_export.S, 'Object', { create: _objectCreate });

  var $Object$2 = _core.Object;
  var create = function create(P, D) {
    return $Object$2.create(P, D);
  };

  var create$1 = create;

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = setPrototypeOf$1 || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = create$1(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  var _redefineAll = function (target, src, safe) {
    for (var key in src) {
      if (safe && target[key]) target[key] = src[key];
      else _hide(target, key, src[key]);
    } return target;
  };

  var _anInstance = function (it, Constructor, name, forbiddenField) {
    if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
      throw TypeError(name + ': incorrect invocation!');
    } return it;
  };

  var _forOf = createCommonjsModule(function (module) {
  var BREAK = {};
  var RETURN = {};
  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
    var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
    var f = _ctx(fn, that, entries ? 2 : 1);
    var index = 0;
    var length, step, iterator, result;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    // fast case for arrays with default iterator
    if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
      result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      if (result === BREAK || result === RETURN) return result;
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      result = _iterCall(iterator, f, step.value, entries);
      if (result === BREAK || result === RETURN) return result;
    }
  };
  exports.BREAK = BREAK;
  exports.RETURN = RETURN;
  });

  var SPECIES = _wks('species');

  var _setSpecies = function (KEY) {
    var C = typeof _core[KEY] == 'function' ? _core[KEY] : _global[KEY];
    if (_descriptors && C && !C[SPECIES]) _objectDp.f(C, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  };

  var _validateCollection = function (it, TYPE) {
    if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
    return it;
  };

  var dP$2 = _objectDp.f;









  var fastKey = _meta.fastKey;

  var SIZE = _descriptors ? '_s' : 'size';

  var getEntry = function (that, key) {
    // fast case
    var index = fastKey(key);
    var entry;
    if (index !== 'F') return that._i[index];
    // frozen object case
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key) return entry;
    }
  };

  var _collectionStrong = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        _anInstance(that, C, NAME, '_i');
        that._t = NAME;         // collection type
        that._i = _objectCreate(null); // index
        that._f = undefined;    // first entry
        that._l = undefined;    // last entry
        that[SIZE] = 0;         // size
        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
      });
      _redefineAll(C.prototype, {
        // 23.1.3.1 Map.prototype.clear()
        // 23.2.3.2 Set.prototype.clear()
        clear: function clear() {
          for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p) entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        // 23.1.3.3 Map.prototype.delete(key)
        // 23.2.3.4 Set.prototype.delete(value)
        'delete': function (key) {
          var that = _validateCollection(this, NAME);
          var entry = getEntry(that, key);
          if (entry) {
            var next = entry.n;
            var prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev) prev.n = next;
            if (next) next.p = prev;
            if (that._f == entry) that._f = next;
            if (that._l == entry) that._l = prev;
            that[SIZE]--;
          } return !!entry;
        },
        // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
        // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
        forEach: function forEach(callbackfn /* , that = undefined */) {
          _validateCollection(this, NAME);
          var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
          var entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            // revert to the last existing entry
            while (entry && entry.r) entry = entry.p;
          }
        },
        // 23.1.3.7 Map.prototype.has(key)
        // 23.2.3.7 Set.prototype.has(value)
        has: function has(key) {
          return !!getEntry(_validateCollection(this, NAME), key);
        }
      });
      if (_descriptors) dP$2(C.prototype, 'size', {
        get: function () {
          return _validateCollection(this, NAME)[SIZE];
        }
      });
      return C;
    },
    def: function (that, key, value) {
      var entry = getEntry(that, key);
      var prev, index;
      // change existing entry
      if (entry) {
        entry.v = value;
      // create new entry
      } else {
        that._l = entry = {
          i: index = fastKey(key, true), // <- index
          k: key,                        // <- key
          v: value,                      // <- value
          p: prev = that._l,             // <- previous entry
          n: undefined,                  // <- next entry
          r: false                       // <- removed
        };
        if (!that._f) that._f = entry;
        if (prev) prev.n = entry;
        that[SIZE]++;
        // add to index
        if (index !== 'F') that._i[index] = entry;
      } return that;
    },
    getEntry: getEntry,
    setStrong: function (C, NAME, IS_MAP) {
      // add .keys, .values, .entries, [@@iterator]
      // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
      _iterDefine(C, NAME, function (iterated, kind) {
        this._t = _validateCollection(iterated, NAME); // target
        this._k = kind;                     // kind
        this._l = undefined;                // previous
      }, function () {
        var that = this;
        var kind = that._k;
        var entry = that._l;
        // revert to the last existing entry
        while (entry && entry.r) entry = entry.p;
        // get next entry
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          // or finish the iteration
          that._t = undefined;
          return _iterStep(1);
        }
        // return step by kind
        if (kind == 'keys') return _iterStep(0, entry.k);
        if (kind == 'values') return _iterStep(0, entry.v);
        return _iterStep(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

      // add [@@species], 23.1.2.2, 23.2.2.2
      _setSpecies(NAME);
    }
  };

  var SPECIES$1 = _wks('species');

  var _arraySpeciesConstructor = function (original) {
    var C;
    if (_isArray(original)) {
      C = original.constructor;
      // cross-realm fallback
      if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
      if (_isObject(C)) {
        C = C[SPECIES$1];
        if (C === null) C = undefined;
      }
    } return C === undefined ? Array : C;
  };

  // 9.4.2.3 ArraySpeciesCreate(originalArray, length)


  var _arraySpeciesCreate = function (original, length) {
    return new (_arraySpeciesConstructor(original))(length);
  };

  // 0 -> Array#forEach
  // 1 -> Array#map
  // 2 -> Array#filter
  // 3 -> Array#some
  // 4 -> Array#every
  // 5 -> Array#find
  // 6 -> Array#findIndex





  var _arrayMethods = function (TYPE, $create) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    var create = $create || _arraySpeciesCreate;
    return function ($this, callbackfn, that) {
      var O = _toObject($this);
      var self = _iobject(O);
      var f = _ctx(callbackfn, that, 3);
      var length = _toLength(self.length);
      var index = 0;
      var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
      var val, res;
      for (;length > index; index++) if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res;   // map
          else if (res) switch (TYPE) {
            case 3: return true;             // some
            case 5: return val;              // find
            case 6: return index;            // findIndex
            case 2: result.push(val);        // filter
          } else if (IS_EVERY) return false; // every
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };

  var dP$3 = _objectDp.f;
  var each = _arrayMethods(0);


  var _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = _global[NAME];
    var C = Base;
    var ADDER = IS_MAP ? 'set' : 'add';
    var proto = C && C.prototype;
    var O = {};
    if (!_descriptors || typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
      new C().entries().next();
    }))) {
      // create collection constructor
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      _redefineAll(C.prototype, methods);
      _meta.NEED = true;
    } else {
      C = wrapper(function (target, iterable) {
        _anInstance(target, C, NAME, '_c');
        target._c = new Base();
        if (iterable != undefined) _forOf(iterable, IS_MAP, target[ADDER], target);
      });
      each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear')) _hide(C.prototype, KEY, function (a, b) {
          _anInstance(this, C, KEY);
          if (!IS_ADDER && IS_WEAK && !_isObject(a)) return KEY == 'get' ? undefined : false;
          var result = this._c[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      });
      IS_WEAK || dP$3(C.prototype, 'size', {
        get: function () {
          return this._c.size;
        }
      });
    }

    _setToStringTag(C, NAME);

    O[NAME] = C;
    _export(_export.G + _export.W + _export.F, O);

    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

    return C;
  };

  var MAP = 'Map';

  // 23.1 Map Objects
  var es6_map = _collection(MAP, function (get) {
    return function Map$$1() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
  }, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function get(key) {
      var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function set(key, value) {
      return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
    }
  }, _collectionStrong, true);

  var _arrayFromIterable = function (iter, ITERATOR) {
    var result = [];
    _forOf(iter, false, result.push, result, ITERATOR);
    return result;
  };

  // https://github.com/DavidBruant/Map-Set.prototype.toJSON


  var _collectionToJson = function (NAME) {
    return function toJSON() {
      if (_classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
      return _arrayFromIterable(this);
    };
  };

  // https://github.com/DavidBruant/Map-Set.prototype.toJSON


  _export(_export.P + _export.R, 'Map', { toJSON: _collectionToJson('Map') });

  // https://tc39.github.io/proposal-setmap-offrom/


  var _setCollectionOf = function (COLLECTION) {
    _export(_export.S, COLLECTION, { of: function of() {
      var length = arguments.length;
      var A = new Array(length);
      while (length--) A[length] = arguments[length];
      return new this(A);
    } });
  };

  // https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
  _setCollectionOf('Map');

  // https://tc39.github.io/proposal-setmap-offrom/





  var _setCollectionFrom = function (COLLECTION) {
    _export(_export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      _aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) _aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];
      if (mapping) {
        n = 0;
        cb = _ctx(mapFn, arguments[2], 2);
        _forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        _forOf(source, false, A.push, A);
      }
      return new this(A);
    } });
  };

  // https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
  _setCollectionFrom('Map');

  var map$1 = _core.Map;

  var map$2 = map$1;

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  // fast apply, http://jsperf.lnkit.com/fast-apply/5
  var _invoke = function (fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0: return un ? fn()
                        : fn.call(that);
      case 1: return un ? fn(args[0])
                        : fn.call(that, args[0]);
      case 2: return un ? fn(args[0], args[1])
                        : fn.call(that, args[0], args[1]);
      case 3: return un ? fn(args[0], args[1], args[2])
                        : fn.call(that, args[0], args[1], args[2]);
      case 4: return un ? fn(args[0], args[1], args[2], args[3])
                        : fn.call(that, args[0], args[1], args[2], args[3]);
    } return fn.apply(that, args);
  };

  var arraySlice = [].slice;
  var factories = {};

  var construct = function (F, len, args) {
    if (!(len in factories)) {
      for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
      // eslint-disable-next-line no-new-func
      factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
    } return factories[len](F, args);
  };

  var _bind = Function.bind || function bind(that /* , ...args */) {
    var fn = _aFunction(this);
    var partArgs = arraySlice.call(arguments, 1);
    var bound = function (/* args... */) {
      var args = partArgs.concat(arraySlice.call(arguments));
      return this instanceof bound ? construct(fn, args.length, args) : _invoke(fn, args, that);
    };
    if (_isObject(fn.prototype)) bound.prototype = fn.prototype;
    return bound;
  };

  // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])







  var rConstruct = (_global.Reflect || {}).construct;

  // MS Edge supports only 2 arguments and argumentsList argument is optional
  // FF Nightly sets third argument as `new.target`, but does not create `this` from it
  var NEW_TARGET_BUG = _fails(function () {
    function F() { /* empty */ }
    return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
  });
  var ARGS_BUG = !_fails(function () {
    rConstruct(function () { /* empty */ });
  });

  _export(_export.S + _export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
    construct: function construct(Target, args /* , newTarget */) {
      _aFunction(Target);
      _anObject(args);
      var newTarget = arguments.length < 3 ? Target : _aFunction(arguments[2]);
      if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
      if (Target == newTarget) {
        // w/o altered newTarget, optimization for 0-4 arguments
        switch (args.length) {
          case 0: return new Target();
          case 1: return new Target(args[0]);
          case 2: return new Target(args[0], args[1]);
          case 3: return new Target(args[0], args[1], args[2]);
          case 4: return new Target(args[0], args[1], args[2], args[3]);
        }
        // w/o altered newTarget, lot of arguments case
        var $args = [null];
        $args.push.apply($args, args);
        return new (_bind.apply(Target, $args))();
      }
      // with altered newTarget, not support built-in constructors
      var proto = newTarget.prototype;
      var instance = _objectCreate(_isObject(proto) ? proto : Object.prototype);
      var result = Function.apply.call(Target, instance, args);
      return _isObject(result) ? result : instance;
    }
  });

  var construct$1 = _core.Reflect.construct;

  var construct$2 = construct$1;

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !construct$2) return false;
    if (construct$2.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(construct$2(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = construct$2;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof map$2 === "function" ? new map$2() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = create$1(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  var AssertionError =
  /*#__PURE__*/
  function (_Error) {
    _inherits(AssertionError, _Error);

    function AssertionError(message) {
      var _this;

      _classCallCheck(this, AssertionError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, message));
      _this.name = _this.constructor.name;

      if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), _this.constructor);
      } else {
        _this.stack = new Error(message).stack;
      }

      return _this;
    }

    return AssertionError;
  }(_wrapNativeSuper(Error));
  /**
   * @param {*} value
   * @param {string} message
   * @throws AssertionError
   */

  function assert(value, message) {
    if (!value) {
      throw new AssertionError(message || "Assertion failed");
    }
  }
  /**
   * Alias of `assert` function.
   * @param value
   * @param message
   */

  function ok(value, message) {
    return assert(value, message);
  }
  /**
   * @param {*} value
   * @param {Function} Ctor
   * @throws {AssertionError}
   */

  function instanceOf(value, Ctor) {
    assert(value instanceof Ctor, "value is an instance of ".concat(Ctor.name));
  }
  /**
   * @param {Object} vm
   * @return {void}
   * @throws {AssertionError}
   */

  function hasMap(vm) {
    assert(vm.$map, 'component has "$map" property');
  }
  /**
   * @param {Object} vm
   * @return {void}
   * @throws {AssertionError}
   */

  function hasView(vm) {
    assert(vm.$view, 'component has "$view" property');
  }
  /**
   * @param {Object} vm
   * @return {void}
   * @throws {AssertionError}
   */

  function hasGeolocation(vm) {
    assert(vm.$geolocation, 'component has "$geolocation" property');
  }
  /**
   * @param {Object} vm
   * @return {void}
   * @throws {AssertionError}
   */

  function hasFeature(vm) {
    assert(vm.$feature, 'component has "$feature" property');
  }
  /**
   * @param {Object} vm
   * @return {void}
   * @throws {AssertionError}
   */

  function hasLayer(vm) {
    assert(vm.$layer, 'component has "$layer" property');
  }
  /**
   * @param {Object} vm
   * @return {void}
   * @throws {AssertionError}
   */

  function hasSource(vm) {
    assert(vm.$source, 'component has "$source" property');
  }
  /**
   * @param {Object} vm
   * @return {void}
   * @throws {AssertionError}
   */

  function hasGeometry(vm) {
    assert(vm.$geometry, 'component has "$geometry" property');
  }
  /**
   * @param {Object} vm
   * @return {void}
   * @throws {AssertionError}
   */

  function hasInteraction(vm) {
    assert(vm.$interaction, 'component has "$interaction" property');
  }
  /**
   * @param {Object} vm
   * @return {void}
   * @throws {AssertionError}
   */

  function hasOverlay(vm) {
    assert(vm.$overlay, 'component has "$overlay" property');
  }
  function hasGraticule(vm) {
    assert(vm.$graticule, 'component has "$graticule" property');
  }

  var EPSG_4326 = 'EPSG:4326';
  var EPSG_3857 = 'EPSG:3857';
  /**
   * @type {number} Default map max zoom
   */

  var MAX_ZOOM = 28;
  /**
   * @type {number} Default map min zoom
   */

  var MIN_ZOOM = 0;
  /**
   * @type {number} Default tile size
   */

  var TILE_SIZE = 256;
  /**
   * @type {string}
   */

  var TILE_FORMAT = 'png';
  /**
   * @type {number} Default zoom factor
   */

  var ZOOM_FACTOR = 2;
  /**
   * @type {number}
   */

  var CACHE_SIZE = 2048;
  /**
   * @type {number}
   */

  var PIXEL_RATIO = 1;
  /**
   * @type {string}
   */

  var CROSS_ORIGIN = 'anonymous';
  /**
   * @type {number}
   */

  var REPROJ_ERR_THRESHOLD = 0.5;
  /**
   * @type {number} Earth radius in meters
   */

  var EARTH_RADIUS = 6378137;
  var RENDERER_TYPE = {
    CANVAS: 'canvas',
    WEBGL: 'webgl'
  };
  var GEOMETRY_TYPE = {
    POINT: 'Point',
    LINE_STRING: 'LineString',
    POLYGON: 'Polygon',
    MULTI_POINT: 'MultiPoint',
    MULTI_LINE_STRING: 'MultiLineString',
    MULTI_POLYGON: 'MultiPolygon',
    GEOMETRY_COLLECTION: 'GeometryCollection',
    CIRCLE: 'Circle'
  };
  var EXTENT_CORNER = {
    BOTTOM_LEFT: 'bottom-left',
    BOTTOM_RIGHT: 'bottom-right',
    TOP_LEFT: 'top-left',
    TOP_RIGHT: 'top-right'
  };
  var PROJ_UNIT = {
    DEGREES: 'degrees',
    FEET: 'ft',
    METERS: 'm',
    PIXELS: 'pixels',
    TILE_PIXELS: 'tile-pixels',
    USFEET: 'us-ft'
  };
  var OVERLAY_POSITIONING = {
    BOTTOM_LEFT: 'bottom-left',
    BOTTOM_CENTER: 'bottom-center',
    BOTTOM_RIGHT: 'bottom-right',
    CENTER_LEFT: 'center-left',
    CENTER_CENTER: 'center-center',
    CENTER_RIGHT: 'center-right',
    TOP_LEFT: 'top-left',
    TOP_CENTER: 'top-center',
    TOP_RIGHT: 'top-right'
    /**
     * @type {string} Default WMS version
     */

  };
  var WMS_VERSION = '1.3.0';
  var WMTS_VERSION = '1.0.0';
  var WMTS_REQUEST_ENCODING = 'KVP';
  var WMTS_FORMAT = 'image/jpeg';
  var LAYER_PROP = 'layer';

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;

      defineProperty$2(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  // 26.1.6 Reflect.get(target, propertyKey [, receiver])







  function get$1(target, propertyKey /* , receiver */) {
    var receiver = arguments.length < 3 ? target : arguments[2];
    var desc, proto;
    if (_anObject(target) === receiver) return target[propertyKey];
    if (desc = _objectGopd.f(target, propertyKey)) return _has(desc, 'value')
      ? desc.value
      : desc.get !== undefined
        ? desc.get.call(receiver)
        : undefined;
    if (_isObject(proto = _objectGpo(target))) return get$1(proto, propertyKey, receiver);
  }

  _export(_export.S, 'Reflect', { get: get$1 });

  var get$2 = _core.Reflect.get;

  var get$3 = get$2;

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && get$3) {
      _get = get$3;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;

        var desc = getOwnPropertyDescriptor$1(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  /**
   * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
   */

  /**
   * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
   *
   * @name feature
   * @param {Geometry} geometry input geometry
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature} a GeoJSON Feature
   * @example
   * var geometry = {
   *   "type": "Point",
   *   "coordinates": [110, 50]
   * };
   *
   * var feature = turf.feature(geometry);
   *
   * //=feature
   */
  function feature(geometry, properties, options) {
      // Optional Parameters
      options = options || {};
      if (!isObject(options)) throw new Error('options is invalid');
      var bbox = options.bbox;
      var id = options.id;

      // Validation
      if (geometry === undefined) throw new Error('geometry is required');
      if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
      if (bbox) validateBBox(bbox);
      if (id) validateId(id);

      // Main
      var feat = {type: 'Feature'};
      if (id) feat.id = id;
      if (bbox) feat.bbox = bbox;
      feat.properties = properties || {};
      feat.geometry = geometry;
      return feat;
  }

  /**
   * Creates a {@link Point} {@link Feature} from a Position.
   *
   * @name point
   * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature<Point>} a Point feature
   * @example
   * var point = turf.point([-75.343, 39.984]);
   *
   * //=point
   */
  function point(coordinates, properties, options) {
      if (!coordinates) throw new Error('coordinates is required');
      if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
      if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');
      if (!isNumber$1(coordinates[0]) || !isNumber$1(coordinates[1])) throw new Error('coordinates must contain numbers');

      return feature({
          type: 'Point',
          coordinates: coordinates
      }, properties, options);
  }

  /**
   * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
   *
   * @name featureCollection
   * @param {Feature[]} features input features
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {FeatureCollection} FeatureCollection of Features
   * @example
   * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
   * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
   * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
   *
   * var collection = turf.featureCollection([
   *   locationA,
   *   locationB,
   *   locationC
   * ]);
   *
   * //=collection
   */
  function featureCollection(features, options) {
      // Optional Parameters
      options = options || {};
      if (!isObject(options)) throw new Error('options is invalid');
      var bbox = options.bbox;
      var id = options.id;

      // Validation
      if (!features) throw new Error('No features passed');
      if (!Array.isArray(features)) throw new Error('features must be an Array');
      if (bbox) validateBBox(bbox);
      if (id) validateId(id);

      // Main
      var fc = {type: 'FeatureCollection'};
      if (id) fc.id = id;
      if (bbox) fc.bbox = bbox;
      fc.features = features;
      return fc;
  }

  /**
   * isNumber
   *
   * @param {*} num Number to validate
   * @returns {boolean} true/false
   * @example
   * turf.isNumber(123)
   * //=true
   * turf.isNumber('foo')
   * //=false
   */
  function isNumber$1(num) {
      return !isNaN(num) && num !== null && !Array.isArray(num);
  }

  /**
   * isObject
   *
   * @param {*} input variable to validate
   * @returns {boolean} true/false
   * @example
   * turf.isObject({elevation: 10})
   * //=true
   * turf.isObject('foo')
   * //=false
   */
  function isObject(input) {
      return (!!input) && (input.constructor === Object);
  }

  /**
   * Validate BBox
   *
   * @private
   * @param {Array<number>} bbox BBox to validate
   * @returns {void}
   * @throws Error if BBox is not valid
   * @example
   * validateBBox([-180, -40, 110, 50])
   * //=OK
   * validateBBox([-180, -40])
   * //=Error
   * validateBBox('Foo')
   * //=Error
   * validateBBox(5)
   * //=Error
   * validateBBox(null)
   * //=Error
   * validateBBox(undefined)
   * //=Error
   */
  function validateBBox(bbox) {
      if (!bbox) throw new Error('bbox is required');
      if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');
      if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');
      bbox.forEach(function (num) {
          if (!isNumber$1(num)) throw new Error('bbox must only contain numbers');
      });
  }

  /**
   * Validate Id
   *
   * @private
   * @param {string|number} id Id to validate
   * @returns {void}
   * @throws Error if Id is not valid
   * @example
   * validateId([-180, -40, 110, 50])
   * //=Error
   * validateId([-180, -40])
   * //=Error
   * validateId('Foo')
   * //=OK
   * validateId(5)
   * //=OK
   * validateId(null)
   * //=Error
   * validateId(undefined)
   * //=Error
   */
  function validateId(id) {
      if (!id) throw new Error('id is required');
      if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');
  }

  /**
   * Callback for coordEach
   *
   * @callback coordEachCallback
   * @param {Array<number>} currentCoord The current coordinate being processed.
   * @param {number} coordIndex The current index of the coordinate being processed.
   * @param {number} featureIndex The current index of the Feature being processed.
   * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
   * @param {number} geometryIndex The current index of the Geometry being processed.
   */

  /**
   * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
   *
   * @name coordEach
   * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
   * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
   * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
   * @returns {void}
   * @example
   * var features = turf.featureCollection([
   *   turf.point([26, 37], {"foo": "bar"}),
   *   turf.point([36, 53], {"hello": "world"})
   * ]);
   *
   * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
   *   //=currentCoord
   *   //=coordIndex
   *   //=featureIndex
   *   //=multiFeatureIndex
   *   //=geometryIndex
   * });
   */
  function coordEach(geojson, callback, excludeWrapCoord) {
      // Handles null Geometry -- Skips this GeoJSON
      if (geojson === null) return;
      var j, k, l, geometry$$1, stopG, coords,
          geometryMaybeCollection,
          wrapShrink = 0,
          coordIndex = 0,
          isGeometryCollection,
          type = geojson.type,
          isFeatureCollection = type === 'FeatureCollection',
          isFeature = type === 'Feature',
          stop = isFeatureCollection ? geojson.features.length : 1;

      // This logic may look a little weird. The reason why it is that way
      // is because it's trying to be fast. GeoJSON supports multiple kinds
      // of objects at its root: FeatureCollection, Features, Geometries.
      // This function has the responsibility of handling all of them, and that
      // means that some of the `for` loops you see below actually just don't apply
      // to certain inputs. For instance, if you give this just a
      // Point geometry, then both loops are short-circuited and all we do
      // is gradually rename the input until it's called 'geometry'.
      //
      // This also aims to allocate as few resources as possible: just a
      // few numbers and booleans, rather than any temporary arrays as would
      // be required with the normalization approach.
      for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
          geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
              (isFeature ? geojson.geometry : geojson));
          isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

          for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
              var multiFeatureIndex = 0;
              var geometryIndex = 0;
              geometry$$1 = isGeometryCollection ?
                  geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

              // Handles null Geometry -- Skips this geometry
              if (geometry$$1 === null) continue;
              coords = geometry$$1.coordinates;
              var geomType = geometry$$1.type;

              wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

              switch (geomType) {
              case null:
                  break;
              case 'Point':
                  if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                  coordIndex++;
                  multiFeatureIndex++;
                  break;
              case 'LineString':
              case 'MultiPoint':
                  for (j = 0; j < coords.length; j++) {
                      if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                      coordIndex++;
                      if (geomType === 'MultiPoint') multiFeatureIndex++;
                  }
                  if (geomType === 'LineString') multiFeatureIndex++;
                  break;
              case 'Polygon':
              case 'MultiLineString':
                  for (j = 0; j < coords.length; j++) {
                      for (k = 0; k < coords[j].length - wrapShrink; k++) {
                          if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                          coordIndex++;
                      }
                      if (geomType === 'MultiLineString') multiFeatureIndex++;
                      if (geomType === 'Polygon') geometryIndex++;
                  }
                  if (geomType === 'Polygon') multiFeatureIndex++;
                  break;
              case 'MultiPolygon':
                  for (j = 0; j < coords.length; j++) {
                      if (geomType === 'MultiPolygon') geometryIndex = 0;
                      for (k = 0; k < coords[j].length; k++) {
                          for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                              if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                              coordIndex++;
                          }
                          geometryIndex++;
                      }
                      multiFeatureIndex++;
                  }
                  break;
              case 'GeometryCollection':
                  for (j = 0; j < geometry$$1.geometries.length; j++)
                      if (coordEach(geometry$$1.geometries[j], callback, excludeWrapCoord) === false) return false;
                  break;
              default:
                  throw new Error('Unknown Geometry Type');
              }
          }
      }
  }

  /**
   * Callback for featureEach
   *
   * @callback featureEachCallback
   * @param {Feature<any>} currentFeature The current Feature being processed.
   * @param {number} featureIndex The current index of the Feature being processed.
   */

  /**
   * Iterate over features in any GeoJSON object, similar to
   * Array.forEach.
   *
   * @name featureEach
   * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
   * @param {Function} callback a method that takes (currentFeature, featureIndex)
   * @returns {void}
   * @example
   * var features = turf.featureCollection([
   *   turf.point([26, 37], {foo: 'bar'}),
   *   turf.point([36, 53], {hello: 'world'})
   * ]);
   *
   * turf.featureEach(features, function (currentFeature, featureIndex) {
   *   //=currentFeature
   *   //=featureIndex
   * });
   */
  function featureEach(geojson, callback) {
      if (geojson.type === 'Feature') {
          callback(geojson, 0);
      } else if (geojson.type === 'FeatureCollection') {
          for (var i = 0; i < geojson.features.length; i++) {
              if (callback(geojson.features[i], i) === false) break;
          }
      }
  }

  /**
   * Takes a feature or set of features and returns all positions as {@link Point|points}.
   *
   * @name explode
   * @param {GeoJSON} geojson input features
   * @returns {FeatureCollection<point>} points representing the exploded input features
   * @throws {Error} if it encounters an unknown geometry type
   * @example
   * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);
   *
   * var explode = turf.explode(polygon);
   *
   * //addToMap
   * var addToMap = [polygon, explode]
   */
  function explode(geojson) {
      var points$$1 = [];
      if (geojson.type === 'FeatureCollection') {
          featureEach(geojson, function (feature$$1) {
              coordEach(feature$$1, function (coord) {
                  points$$1.push(point(coord, feature$$1.properties));
              });
          });
      } else {
          coordEach(geojson, function (coord) {
              points$$1.push(point(coord, geojson.properties));
          });
      }
      return featureCollection(points$$1);
  }

  /**
   * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
   *
   * @name bbox
   * @param {GeoJSON} geojson any GeoJSON object
   * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
   * @example
   * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
   * var bbox = turf.bbox(line);
   * var bboxPolygon = turf.bboxPolygon(bbox);
   *
   * //addToMap
   * var addToMap = [line, bboxPolygon]
   */
  function bbox(geojson) {
      var BBox = [Infinity, Infinity, -Infinity, -Infinity];
      coordEach(geojson, function (coord) {
          if (BBox[0] > coord[0]) BBox[0] = coord[0];
          if (BBox[1] > coord[1]) BBox[1] = coord[1];
          if (BBox[2] < coord[0]) BBox[2] = coord[0];
          if (BBox[3] < coord[1]) BBox[3] = coord[1];
      });
      return BBox;
  }

  /**
   * Takes a {@link Feature} or {@link FeatureCollection} and returns the absolute center point of all features.
   *
   * @name center
   * @param {GeoJSON} geojson GeoJSON to be centered
   * @param {Object} [options={}] Optional parameters
   * @param {Object} [options.properties={}] an Object that is used as the {@link Feature}'s properties
   * @returns {Feature<Point>} a Point feature at the absolute center point of all input features
   * @example
   * var features = turf.featureCollection([
   *   turf.point( [-97.522259, 35.4691]),
   *   turf.point( [-97.502754, 35.463455]),
   *   turf.point( [-97.508269, 35.463245])
   * ]);
   *
   * var center = turf.center(features);
   *
   * //addToMap
   * var addToMap = [features, center]
   * center.properties['marker-size'] = 'large';
   * center.properties['marker-color'] = '#000';
   */
  function center(geojson, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error('options is invalid');
      var properties = options.properties;

      // Input validation
      if (!geojson) throw new Error('geojson is required');

      var ext = bbox(geojson);
      var x = (ext[0] + ext[2]) / 2;
      var y = (ext[1] + ext[3]) / 2;
      return point([x, y], properties);
  }

  /**
   * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.
   * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.
   *
   * @name clone
   * @param {GeoJSON} geojson GeoJSON Object
   * @returns {GeoJSON} cloned GeoJSON Object
   * @example
   * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});
   *
   * var lineCloned = turf.clone(line);
   */
  function clone(geojson) {
      if (!geojson) throw new Error('geojson is required');

      switch (geojson.type) {
      case 'Feature':
          return cloneFeature(geojson);
      case 'FeatureCollection':
          return cloneFeatureCollection(geojson);
      case 'Point':
      case 'LineString':
      case 'Polygon':
      case 'MultiPoint':
      case 'MultiLineString':
      case 'MultiPolygon':
      case 'GeometryCollection':
          return cloneGeometry(geojson);
      default:
          throw new Error('unknown GeoJSON type');
      }
  }

  /**
   * Clone Feature
   *
   * @private
   * @param {Feature<any>} geojson GeoJSON Feature
   * @returns {Feature<any>} cloned Feature
   */
  function cloneFeature(geojson) {
      var cloned = {type: 'Feature'};
      // Preserve Foreign Members
      Object.keys(geojson).forEach(function (key) {
          switch (key) {
          case 'type':
          case 'properties':
          case 'geometry':
              return;
          default:
              cloned[key] = geojson[key];
          }
      });
      // Add properties & geometry last
      cloned.properties = cloneProperties(geojson.properties);
      cloned.geometry = cloneGeometry(geojson.geometry);
      return cloned;
  }

  /**
   * Clone Properties
   *
   * @private
   * @param {Object} properties GeoJSON Properties
   * @returns {Object} cloned Properties
   */
  function cloneProperties(properties) {
      var cloned = {};
      if (!properties) return cloned;
      Object.keys(properties).forEach(function (key) {
          var value = properties[key];
          if (typeof value === 'object') {
              if (value === null) {
                  // handle null
                  cloned[key] = null;
              } else if (value.length) {
                  // handle Array
                  cloned[key] = value.map(function (item) {
                      return item;
                  });
              } else {
                  // handle generic Object
                  cloned[key] = cloneProperties(value);
              }
          } else cloned[key] = value;
      });
      return cloned;
  }

  /**
   * Clone Feature Collection
   *
   * @private
   * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection
   * @returns {FeatureCollection<any>} cloned Feature Collection
   */
  function cloneFeatureCollection(geojson) {
      var cloned = {type: 'FeatureCollection'};

      // Preserve Foreign Members
      Object.keys(geojson).forEach(function (key) {
          switch (key) {
          case 'type':
          case 'features':
              return;
          default:
              cloned[key] = geojson[key];
          }
      });
      // Add features
      cloned.features = geojson.features.map(function (feature) {
          return cloneFeature(feature);
      });
      return cloned;
  }

  /**
   * Clone Geometry
   *
   * @private
   * @param {Geometry<any>} geometry GeoJSON Geometry
   * @returns {Geometry<any>} cloned Geometry
   */
  function cloneGeometry(geometry) {
      var geom = {type: geometry.type};
      if (geometry.bbox) geom.bbox = geometry.bbox;

      if (geometry.type === 'GeometryCollection') {
          geom.geometries = geometry.geometries.map(function (geom) {
              return cloneGeometry(geom);
          });
          return geom;
      }
      geom.coordinates = deepSlice(geometry.coordinates);
      return geom;
  }

  /**
   * Deep Slice coordinates
   *
   * @private
   * @param {Coordinates} coords Coordinates
   * @returns {Coordinates} all coordinates sliced
   */
  function deepSlice(coords) {
      if (typeof coords[0] !== 'object') { return coords.slice(); }
      return coords.map(function (coord) {
          return deepSlice(coord);
      });
  }

  /**
   * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
   */
  var earthRadius$1 = 6371008.8;

  /**
   * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
   */
  var factors$1 = {
      meters: earthRadius$1,
      metres: earthRadius$1,
      millimeters: earthRadius$1 * 1000,
      millimetres: earthRadius$1 * 1000,
      centimeters: earthRadius$1 * 100,
      centimetres: earthRadius$1 * 100,
      kilometers: earthRadius$1 / 1000,
      kilometres: earthRadius$1 / 1000,
      miles: earthRadius$1 / 1609.344,
      nauticalmiles: earthRadius$1 / 1852,
      inches: earthRadius$1 * 39.370,
      yards: earthRadius$1 / 1.0936,
      feet: earthRadius$1 * 3.28084,
      radians: 1,
      degrees: earthRadius$1 / 111325,
  };

  /**
   * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
   * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
   *
   * @name radiansToLength
   * @param {number} radians in radians across the sphere
   * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
   * @returns {number} distance
   */
  function radiansToLength$1(radians, units) {
      if (radians === undefined || radians === null) throw new Error('radians is required');

      if (units && typeof units !== 'string') throw new Error('units must be a string');
      var factor = factors$1[units || 'kilometers'];
      if (!factor) throw new Error(units + ' units is invalid');
      return radians * factor;
  }

  /**
   * Converts an angle in degrees to radians
   *
   * @name degreesToRadians
   * @param {number} degrees angle between 0 and 360 degrees
   * @returns {number} angle in radians
   */
  function degreesToRadians$1(degrees) {
      if (degrees === null || degrees === undefined) throw new Error('degrees is required');

      var radians = degrees % 360;
      return radians * Math.PI / 180;
  }

  /**
   * isObject
   *
   * @param {*} input variable to validate
   * @returns {boolean} true/false
   * @example
   * turf.isObject({elevation: 10})
   * //=true
   * turf.isObject('foo')
   * //=false
   */
  function isObject$1(input) {
      return (!!input) && (input.constructor === Object);
  }

  /**
   * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
   *
   * @name getCoord
   * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
   * @returns {Array<number>} coordinates
   * @example
   * var pt = turf.point([10, 10]);
   *
   * var coord = turf.getCoord(pt);
   * //= [10, 10]
   */
  function getCoord(coord) {
      if (!coord) throw new Error('coord is required');
      if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;
      if (coord.type === 'Point') return coord.coordinates;
      if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;

      throw new Error('coord must be GeoJSON Point or an Array of numbers');
  }

  //http://en.wikipedia.org/wiki/Haversine_formula
  //http://www.movable-type.co.uk/scripts/latlong.html

  /**
   * Calculates the distance between two {@link Point|points} in degrees, radians,
   * miles, or kilometers. This uses the
   * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)
   * to account for global curvature.
   *
   * @name distance
   * @param {Coord} from origin point
   * @param {Coord} to destination point
   * @param {Object} [options={}] Optional parameters
   * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
   * @returns {number} distance between the two points
   * @example
   * var from = turf.point([-75.343, 39.984]);
   * var to = turf.point([-75.534, 39.123]);
   * var options = {units: 'miles'};
   *
   * var distance = turf.distance(from, to, options);
   *
   * //addToMap
   * var addToMap = [from, to];
   * from.properties.distance = distance;
   * to.properties.distance = distance;
   */
  function distance(from, to, options) {
      // Optional parameters
      options = options || {};
      if (!isObject$1(options)) throw new Error('options is invalid');
      var units = options.units;

      var coordinates1 = getCoord(from);
      var coordinates2 = getCoord(to);
      var dLat = degreesToRadians$1((coordinates2[1] - coordinates1[1]));
      var dLon = degreesToRadians$1((coordinates2[0] - coordinates1[0]));
      var lat1 = degreesToRadians$1(coordinates1[1]);
      var lat2 = degreesToRadians$1(coordinates2[1]);

      var a = Math.pow(Math.sin(dLat / 2), 2) +
            Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);

      return radiansToLength$1(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);
  }

  /**
   * Callback for featureEach
   *
   * @callback featureEachCallback
   * @param {Feature<any>} currentFeature The current Feature being processed.
   * @param {number} featureIndex The current index of the Feature being processed.
   */

  /**
   * Iterate over features in any GeoJSON object, similar to
   * Array.forEach.
   *
   * @name featureEach
   * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
   * @param {Function} callback a method that takes (currentFeature, featureIndex)
   * @returns {void}
   * @example
   * var features = turf.featureCollection([
   *   turf.point([26, 37], {foo: 'bar'}),
   *   turf.point([36, 53], {hello: 'world'})
   * ]);
   *
   * turf.featureEach(features, function (currentFeature, featureIndex) {
   *   //=currentFeature
   *   //=featureIndex
   * });
   */
  function featureEach$1(geojson, callback) {
      if (geojson.type === 'Feature') {
          callback(geojson, 0);
      } else if (geojson.type === 'FeatureCollection') {
          for (var i = 0; i < geojson.features.length; i++) {
              if (callback(geojson.features[i], i) === false) break;
          }
      }
  }

  /**
   * Takes a reference {@link Point|point} and a FeatureCollection of Features
   * with Point geometries and returns the
   * point from the FeatureCollection closest to the reference. This calculation
   * is geodesic.
   *
   * @name nearestPoint
   * @param {Coord} targetPoint the reference point
   * @param {FeatureCollection<Point>} points against input point set
   * @returns {Feature<Point>} the closest point in the set to the reference point
   * @example
   * var targetPoint = turf.point([28.965797, 41.010086], {"marker-color": "#0F0"});
   * var points = turf.featureCollection([
   *     turf.point([28.973865, 41.011122]),
   *     turf.point([28.948459, 41.024204]),
   *     turf.point([28.938674, 41.013324])
   * ]);
   *
   * var nearest = turf.nearestPoint(targetPoint, points);
   *
   * //addToMap
   * var addToMap = [targetPoint, points, nearest];
   * nearest.properties['marker-color'] = '#F00';
   */
  function nearestPoint(targetPoint, points) {
      // Input validation
      if (!targetPoint) throw new Error('targetPoint is required');
      if (!points) throw new Error('points is required');

      var nearest;
      var minDist = Infinity;
      featureEach$1(points, function (pt, featureIndex) {
          var distanceToPoint = distance(targetPoint, pt);
          if (distanceToPoint < minDist) {
              nearest = clone(pt);
              nearest.properties.featureIndex = featureIndex;
              nearest.properties.distanceToPoint = distanceToPoint;
              minDist = distanceToPoint;
          }

      });
      return nearest;
  }

  /**
   * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
   */

  /**
   * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
   *
   * @name getCoord
   * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
   * @returns {Array<number>} coordinates
   * @example
   * var pt = turf.point([10, 10]);
   *
   * var coord = turf.getCoord(pt);
   * //= [10, 10]
   */
  function getCoord$1(coord) {
      if (!coord) throw new Error('coord is required');
      if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;
      if (coord.type === 'Point') return coord.coordinates;
      if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;

      throw new Error('coord must be GeoJSON Point or an Array of numbers');
  }

  /**
   * Unwrap coordinates from a Feature, Geometry Object or an Array
   *
   * @name getCoords
   * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
   * @returns {Array<any>} coordinates
   * @example
   * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
   *
   * var coords = turf.getCoords(poly);
   * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
   */
  function getCoords$1(coords) {
      if (!coords) throw new Error('coords is required');

      // Feature
      if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;

      // Geometry
      if (coords.coordinates) return coords.coordinates;

      // Array of numbers
      if (Array.isArray(coords)) return coords;

      throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');
  }

  // http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
  // modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
  // which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

  /**
   * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can
   * be convex or concave. The function accounts for holes.
   *
   * @name booleanPointInPolygon
   * @param {Coord} point input point
   * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
   * @param {Object} [options={}] Optional parameters
   * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.
   * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
   * @example
   * var pt = turf.point([-77, 44]);
   * var poly = turf.polygon([[
   *   [-81, 41],
   *   [-81, 47],
   *   [-72, 47],
   *   [-72, 41],
   *   [-81, 41]
   * ]]);
   *
   * turf.booleanPointInPolygon(pt, poly);
   * //= true
   */
  function booleanPointInPolygon(point, polygon, options) {
      // Optional parameters
      options = options || {};
      if (typeof options !== 'object') throw new Error('options is invalid');
      var ignoreBoundary = options.ignoreBoundary;

      // validation
      if (!point) throw new Error('point is required');
      if (!polygon) throw new Error('polygon is required');

      var pt = getCoord$1(point);
      var polys = getCoords$1(polygon);
      var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;
      var bbox = polygon.bbox;

      // Quick elimination if point is not inside bbox
      if (bbox && inBBox(pt, bbox) === false) return false;

      // normalize to multipolygon
      if (type === 'Polygon') polys = [polys];

      for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {
          // check if it is in the outer ring first
          if (inRing(pt, polys[i][0], ignoreBoundary)) {
              var inHole = false;
              var k = 1;
              // check for the point in any of the holes
              while (k < polys[i].length && !inHole) {
                  if (inRing(pt, polys[i][k], !ignoreBoundary)) {
                      inHole = true;
                  }
                  k++;
              }
              if (!inHole) insidePoly = true;
          }
      }
      return insidePoly;
  }

  /**
   * inRing
   *
   * @private
   * @param {Array<number>} pt [x,y]
   * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
   * @param {boolean} ignoreBoundary ignoreBoundary
   * @returns {boolean} inRing
   */
  function inRing(pt, ring, ignoreBoundary) {
      var isInside = false;
      if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);

      for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          var xi = ring[i][0], yi = ring[i][1];
          var xj = ring[j][0], yj = ring[j][1];
          var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&
              ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);
          if (onBoundary) return !ignoreBoundary;
          var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&
          (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);
          if (intersect) isInside = !isInside;
      }
      return isInside;
  }

  /**
   * inBBox
   *
   * @private
   * @param {Position} pt point [x,y]
   * @param {BBox} bbox BBox [west, south, east, north]
   * @returns {boolean} true/false if point is inside BBox
   */
  function inBBox(pt, bbox) {
      return bbox[0] <= pt[0] &&
             bbox[1] <= pt[1] &&
             bbox[2] >= pt[0] &&
             bbox[3] >= pt[1];
  }

  /**
   * Takes a Feature or FeatureCollection and returns a {@link Point} guaranteed to be on the surface of the feature.
   *
   * * Given a {@link Polygon}, the point will be in the area of the polygon
   * * Given a {@link LineString}, the point will be along the string
   * * Given a {@link Point}, the point will the same as the input
   *
   * @name pointOnFeature
   * @param {GeoJSON} geojson any Feature or FeatureCollection
   * @returns {Feature<Point>} a point on the surface of `input`
   * @example
   * var polygon = turf.polygon([[
   *   [116, -36],
   *   [131, -32],
   *   [146, -43],
   *   [155, -25],
   *   [133, -9],
   *   [111, -22],
   *   [116, -36]
   * ]]);
   *
   * var pointOnPolygon = turf.pointOnFeature(polygon);
   *
   * //addToMap
   * var addToMap = [polygon, pointOnPolygon];
   */
  function pointOnFeature(geojson) {
      // normalize
      var fc = normalize(geojson);

      // get centroid
      var cent = center(fc);

      // check to see if centroid is on surface
      var onSurface = false;
      var i = 0;
      while (!onSurface && i < fc.features.length) {
          var geom = fc.features[i].geometry;
          var x, y, x1, y1, x2, y2, k;
          var onLine = false;
          if (geom.type === 'Point') {
              if (cent.geometry.coordinates[0] === geom.coordinates[0] &&
                  cent.geometry.coordinates[1] === geom.coordinates[1]) {
                  onSurface = true;
              }
          } else if (geom.type === 'MultiPoint') {
              var onMultiPoint = false;
              k = 0;
              while (!onMultiPoint && k < geom.coordinates.length) {
                  if (cent.geometry.coordinates[0] === geom.coordinates[k][0] &&
            cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
                      onSurface = true;
                      onMultiPoint = true;
                  }
                  k++;
              }
          } else if (geom.type === 'LineString') {
              k = 0;
              while (!onLine && k < geom.coordinates.length - 1) {
                  x = cent.geometry.coordinates[0];
                  y = cent.geometry.coordinates[1];
                  x1 = geom.coordinates[k][0];
                  y1 = geom.coordinates[k][1];
                  x2 = geom.coordinates[k + 1][0];
                  y2 = geom.coordinates[k + 1][1];
                  if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                      onLine = true;
                      onSurface = true;
                  }
                  k++;
              }
          } else if (geom.type === 'MultiLineString') {
              var j = 0;
              while (j < geom.coordinates.length) {
                  onLine = false;
                  k = 0;
                  var line = geom.coordinates[j];
                  while (!onLine && k < line.length - 1) {
                      x = cent.geometry.coordinates[0];
                      y = cent.geometry.coordinates[1];
                      x1 = line[k][0];
                      y1 = line[k][1];
                      x2 = line[k + 1][0];
                      y2 = line[k + 1][1];
                      if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                          onLine = true;
                          onSurface = true;
                      }
                      k++;
                  }
                  j++;
              }
          } else if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
              if (booleanPointInPolygon(cent, geom)) {
                  onSurface = true;
              }
          }
          i++;
      }
      if (onSurface) {
          return cent;
      } else {
          var vertices = featureCollection([]);
          for (i = 0; i < fc.features.length; i++) {
              vertices.features = vertices.features.concat(explode(fc.features[i]).features);
          }
          // Remove distanceToPoint properties from nearestPoint()
          return point(nearestPoint(cent, vertices).geometry.coordinates);
      }
  }

  /**
   * Normalizes any GeoJSON to a FeatureCollection
   *
   * @private
   * @name normalize
   * @param {GeoJSON} geojson Any GeoJSON
   * @returns {FeatureCollection} FeatureCollection
   */
  function normalize(geojson) {
      if (geojson.type !== 'FeatureCollection') {
          if (geojson.type !== 'Feature') {
              return featureCollection([feature(geojson)]);
          }
          return featureCollection([geojson]);
      }
      return geojson;
  }

  function pointOnSegment(x, y, x1, y1, x2, y2) {
      var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
      var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));
      return ab === ap + pb;
  }

  /**
   * @param {number|number[]} lonOrCoordinates
   * @param {number} [lat]
   * @return {Point}
   */

  function createPointGeom(lonOrCoordinates, lat) {
    var coordinates = isArray$1(lonOrCoordinates) ? lonOrCoordinates : [lonOrCoordinates, lat];
    return new Point(coordinates);
  }
  /**
   * @param {Array<number[]>} points
   * @returns {LineString}
   */

  function createLineGeom(points) {
    return new LineString(points);
  }
  /**
   * @param {Array<Array<number[]>>} rings
   * @returns {Polygon}
   */

  function createPolygonGeom(rings) {
    return new Polygon__default(rings);
  }
  /**
   * @param {Array<number[]>} points
   * @returns {MultiPoint}
   */

  function createMultiPointGeom(points) {
    return new MultiPoint(points);
  }
  /**
   * @param {Array<Array<number[]>>} lines
   * @returns {MultiLineString}
   */

  function createMultiLineGeom(lines) {
    return new MultiLineString(lines);
  }
  /**
   * @param {Array<Array<Array<number[]>>>} polygons
   * @returns {MultiPolygon}
   */

  function createMultiPolygonGeom(polygons) {
    return new MultiPolygon(polygons);
  }
  /**
   * @param {Geometry[]} geoms
   * @returns {GeometryCollection}
   */

  function createGeomCollection(geoms) {
    return new GeometryCollection(geoms);
  }
  /**
   * @param {Coordinate|number[]} center
   * @param {number} radius
   * @return {Polygon}
   */

  function createCircularPolygon(center, radius) {
    return Polygon.circular(center, radius);
  }
  /**
   * @param {Geometry|Object} geom
   * @return {boolean}
   * @throws {Error}
   */

  function isMultiGeom(geom) {
    var multiTypes = [GEOMETRY_TYPE.MULTI_POINT, GEOMETRY_TYPE.MULTI_LINE_STRING, GEOMETRY_TYPE.MULTI_POLYGON, GEOMETRY_TYPE.GEOMETRY_COLLECTION];
    return multiTypes.includes(geom.type || geom.getType());
  }
  /**
   * @param {Geometry|Object} geom
   * @return {SimpleGeometry|Object}
   * @throws {Error}
   */

  function toSimpleGeom(geom) {
    if (geom instanceof Circle) {
      geom = createPointGeom(geom.getCenter());
    }

    var type = geom.type || geom.getType();
    var complexTypes = [GEOMETRY_TYPE.GEOMETRY_COLLECTION];

    if (complexTypes.includes(type) === false) {
      return geom;
    }

    return (geom.geometries || geom.getGeometries())[0];
  }
  /**
   * @param {Geometry|Object} geom
   * @return {Coordinate|undefined}
   */

  function findPointOnSurface(geom) {
    var simpleGeom = toSimpleGeom(geom);
    var pointFeature = pointOnFeature({
      type: simpleGeom.type || simpleGeom.getType(),
      coordinates: simpleGeom.coordinates || simpleGeom.getCoordinates()
    });

    if (pointFeature && pointFeature.geometry) {
      return pointFeature.geometry.coordinates;
    }
  }

  var geomHelper = /*#__PURE__*/Object.freeze({
    createPointGeom: createPointGeom,
    createLineGeom: createLineGeom,
    createPolygonGeom: createPolygonGeom,
    createMultiPointGeom: createMultiPointGeom,
    createMultiLineGeom: createMultiLineGeom,
    createMultiPolygonGeom: createMultiPolygonGeom,
    createGeomCollection: createGeomCollection,
    createCircularPolygon: createCircularPolygon,
    isMultiGeom: isMultiGeom,
    toSimpleGeom: toSimpleGeom,
    findPointOnSurface: findPointOnSurface
  });

  var _transforms;
  /**
   * @param {Object} options
   * @return {Projection}
   */

  function createProj(options) {
    return new Projection(options);
  }
  /**
   * @param {number[]} coordinate
   * @param {ProjectionLike} [projection]
   * @return {Coordinate|number[]}
   */

  function pointToLonLat(coordinate) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return proj.toLonLat(coordinate, projection);
  }
  /**
   * @param {number[]} coordinate
   * @param {ProjectionLike} [projection]
   * @return {number[]}
   */

  function pointFromLonLat(coordinate) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return proj.fromLonLat(coordinate, projection);
  }
  function transformPoint(coordinate, sourceProjection, destProjection) {
    return proj.transform(coordinate, sourceProjection, destProjection);
  }
  /**
   * @param {Array<number[]>} coordinates
   * @param {ProjectionLike} [projection]
   * @return {Array<number[]>}
   */

  function lineToLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return coordinates.map(function (point) {
      return pointToLonLat(point, projection);
    });
  }
  /**
   * @param {Array<number[]>} coordinates
   * @param {ProjectionLike} [projection]
   * @return {Array<number[]>}
   */

  function lineFromLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return coordinates.map(function (point) {
      return pointFromLonLat(point, projection);
    });
  }
  function transformLine(coordinates, sourceProjection, destProjection) {
    return coordinates.map(function (point) {
      return proj.transform(point, sourceProjection, destProjection);
    });
  }
  /**
   * @param {Array<Array<number[]>>} coordinates
   * @param {ProjectionLike} [projection]
   * @return {Array<Array<number[]>>}
   */

  function polygonToLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return coordinates.map(function (line) {
      return lineToLonLat(line, projection);
    });
  }
  /**
   * @param {Array<Array<number[]>>} coordinates
   * @param {ProjectionLike} [projection]
   * @return {Array<Array<number[]>>}
   */

  function polygonFromLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return coordinates.map(function (line) {
      return lineFromLonLat(line, projection);
    });
  }
  function transformPolygon(coordinates, sourceProjection, destProjection) {
    return coordinates.map(function (line) {
      return transformLine(line, sourceProjection, destProjection);
    });
  }
  /**
   * @param {Array<number[]>} coordinates
   * @param {ProjectionLike} [projection]
   * @return {Array<number[]>}
   */

  function multiPointToLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return coordinates.map(function (point) {
      return pointToLonLat(point, projection);
    });
  }
  /**
   * @param {Array<number[]>} coordinates
   * @param {ProjectionLike} [projection]
   * @return {Array<number[]>}
   */

  function multiPointFromLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return coordinates.map(function (point) {
      return pointFromLonLat(point, projection);
    });
  }
  function transformMultiPoint(coordinates, sourceProjection, destProjection) {
    return coordinates.map(function (point) {
      return transformPoint(point, sourceProjection, destProjection);
    });
  }
  /**
   * @param {Array<Array<number[]>>} coordinates
   * @param {ProjectionLike} [projection]
   * @return {Array<Array<number[]>>}
   */

  function multiLineToLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return coordinates.map(function (line) {
      return lineToLonLat(line, projection);
    });
  }
  /**
   * @param {Array<Array<number[]>>} coordinates
   * @param {ProjectionLike} [projection]
   * @return {Array<Array<number[]>>}
   */

  function multiLineFromLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return coordinates.map(function (line) {
      return lineFromLonLat(line, projection);
    });
  }
  function transformMultiLine(coordinates, sourceProjection, destProjection) {
    return coordinates.map(function (line) {
      return transformLine(line, sourceProjection, destProjection);
    });
  }
  /**
   * @param {Array<Array<Array<number[]>>>} coordinates
   * @param {ProjectionLike} projection
   * @return {Array<Array<Array<number[]>>>}
   */

  function multiPolygonToLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return coordinates.map(function (polygon) {
      return polygonToLonLat(polygon, projection);
    });
  }
  /**
   * @param {Array<Array<Array<number[]>>>} coordinates
   * @param {ProjectionLike} projection
   * @return {Array<Array<Array<number[]>>>}
   */

  function multiPolygonFromLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return coordinates.map(function (polygon) {
      return polygonFromLonLat(polygon, projection);
    });
  }
  function transformMultiPolygon(coordinates, sourceProjection, destProjection) {
    return coordinates.map(function (polygon) {
      return transformPolygon(polygon, sourceProjection, destProjection);
    });
  }
  /**
   * Transforms by geom type
   * @type {Object<string, function>}
   */

  var transforms = (_transforms = {}, _defineProperty(_transforms, GEOMETRY_TYPE.POINT, {
    toLonLat: pointToLonLat,
    fromLonLat: pointFromLonLat,
    transform: transformPoint
  }), _defineProperty(_transforms, GEOMETRY_TYPE.LINE_STRING, {
    toLonLat: lineToLonLat,
    fromLonLat: lineFromLonLat,
    transform: transformLine
  }), _defineProperty(_transforms, GEOMETRY_TYPE.POLYGON, {
    toLonLat: polygonToLonLat,
    fromLonLat: polygonFromLonLat,
    transform: transformPolygon
  }), _defineProperty(_transforms, GEOMETRY_TYPE.MULTI_POINT, {
    toLonLat: multiPointToLonLat,
    fromLonLat: multiPointFromLonLat,
    transform: transformMultiPoint
  }), _defineProperty(_transforms, GEOMETRY_TYPE.MULTI_LINE_STRING, {
    toLonLat: multiLineToLonLat,
    fromLonLat: multiLineFromLonLat,
    transform: transformMultiLine
  }), _defineProperty(_transforms, GEOMETRY_TYPE.MULTI_POLYGON, {
    toLonLat: multiPolygonToLonLat,
    fromLonLat: multiPolygonFromLonLat,
    transform: transformMultiPolygon
  }), _transforms);
  /**
   * @param {Extent} extent
   * @param {ProjectionLike} [projection=EPSG:3857]
   * @return {Extent}
   */

  function extentFromLonLat(extent$$1) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return proj.transformExtent(extent$$1, EPSG_4326, projection);
  }
  /**
   * @param {Extent} extent
   * @param {ProjectionLike} [projection=EPSG:3857]
   * @return {Extent}
   */

  function extentToLonLat(extent$$1) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    return proj.transformExtent(extent$$1, projection, EPSG_4326);
  }

  /** @module ol-ext/util */
  /**
   * heuristic check that value is ol collection
   * @param value
   * @return {boolean}
   */

  function isCollection(value) {
    return value && isFunction(value.getArray);
  }
  /**
   * heuristic check that value is ol vector source
   * @param value
   * @return {*}
   */

  function isVectorSource(value) {
    return value && isFunction(value.getAttributions) && isFunction(value.getFeatureById);
  }
  /**
   * @param value
   * @return {*}
   */

  function isCircle(value) {
    return isFunction(value.getCenter) && isFunction(value.getRadius);
  }

  /**
   * @param {Object} [options]
   * @return {GeoJSON}
   */

  function createGeoJsonFmt(options) {
    return new GeoJSON(options);
  }
  /**
   * @param {Object} [options]
   * @return {TopoJSON}
   */

  function createTopoJsonFmt(options) {
    return new TopoJSON(options);
  }
  /**
   * @param [options]
   * @return {MVT}
   */

  function createMvtFmt(options) {
    return new MVT(options);
  }

  var GeoJSON =
  /*#__PURE__*/
  function (_BaseGeoJSON) {
    _inherits(GeoJSON, _BaseGeoJSON);

    function GeoJSON() {
      _classCallCheck(this, GeoJSON);

      return _possibleConstructorReturn(this, _getPrototypeOf(GeoJSON).apply(this, arguments));
    }

    _createClass(GeoJSON, [{
      key: "writeGeometryObject",
      value: function writeGeometryObject(geometry, options) {
        if (isCircle(geometry)) {
          geometry = createCircularPolygon(transformPoint(geometry.getCenter(), options.featureProjection || this.defaultFeatureProjection, EPSG_4326), geometry.getRadius());
          options.featureProjection = EPSG_4326;
        }

        return _get(_getPrototypeOf(GeoJSON.prototype), "writeGeometryObject", this).call(this, geometry, options);
      }
    }, {
      key: "writeFeatureObject",
      value: function writeFeatureObject(feature, options) {
        var object =
        /** @type {Object} */
        {
          'type': 'Feature'
        };
        var id = feature.getId();

        if (id !== undefined) {
          object.id = id;
        }

        var geometry = feature.getGeometry();

        if (geometry) {
          object.geometry = this.writeGeometryObject(geometry, options);
        } else {
          object.geometry = null;
        }

        var properties = feature.getProperties();
        delete properties[feature.getGeometryName()];

        if (!isEmpty(properties)) {
          object.properties = properties;
        } else {
          object.properties = null;
        }

        return object;
      }
    }]);

    return GeoJSON;
  }(BaseGeoJSON);

  var geoJsonFmt = createGeoJsonFmt();
  /**
   * @param {Feature} feature
   * @param {ProjectionLike|undefined} [featureProjection]
   * @param {ProjectionLike|undefined} [dataProjection]
   * @return {Object}
   */

  function writeGeoJsonFeature(feature, featureProjection, dataProjection) {
    var geoJsonFeature = geoJsonFmt.writeFeatureObject(feature, {
      featureProjection: featureProjection,
      dataProjection: dataProjection
    });

    if (isArray$1(get(geoJsonFeature, 'properties.features'))) {
      geoJsonFeature.properties.features = geoJsonFeature.properties.features.map(function (feature) {
        if (feature instanceof Feature) {
          return writeGeoJsonFeature(feature, featureProjection, dataProjection);
        }

        return feature;
      });
    }

    return geoJsonFeature;
  }
  /**
   * @param {Object} geoJsonFeature
   * @param {ProjectionLike|undefined} [featureProjection]
   * @param {ProjectionLike|undefined} [dataProjection]
   * @return {Feature}
   */

  function readGeoJsonFeature(geoJsonFeature, featureProjection, dataProjection) {
    var feature = geoJsonFmt.readFeature(geoJsonFeature, {
      featureProjection: featureProjection,
      dataProjection: dataProjection
    });

    if (isArray$1(feature.get('features'))) {
      feature.set('features', feature.get('features').map(function (feature) {
        if (isPlainObject(feature)) {
          return readGeoJsonFeature(feature, featureProjection, dataProjection);
        }

        return feature;
      }));
    }

    return feature;
  }
  /**
   * @param {Geometry} geometry
   * @param {ProjectionLike|undefined} [geometryProjection]
   * @param {ProjectionLike|undefined} [dataProjection]
   * @return {Object}
   */

  function writeGeoJsonGeometry(geometry, geometryProjection, dataProjection) {
    return geoJsonFmt.writeGeometryObject(geometry, {
      featureProjection: geometryProjection,
      dataProjection: dataProjection
    });
  }
  /**
   * @param {Object|Object} geoJsonGeometry
   * @param {ProjectionLike|undefined} [geometryProjection]
   * @param {ProjectionLike|undefined} [dataProjection]
   * @return {Geometry}
   */

  function readGeoJsonGeometry(geoJsonGeometry, geometryProjection, dataProjection) {
    dataProjection = readProjection(geoJsonGeometry, dataProjection);
    return geoJsonFmt.readGeometry(geoJsonGeometry, {
      featureProjection: geometryProjection,
      dataProjection: dataProjection
    });
  }
  function readProjection(geoJsonObj, defaultProjection) {
    return geoJsonFmt.readProjection(geoJsonObj) || defaultProjection;
  }

  /**
   * Mixin with helpers for projection transforms between current view projection and global defined projection.
   */

  var projTransforms = {
    computed: {
      /**
       * @return {ProjectionLike}
       */
      viewProjection: function viewProjection() {
        if (this.rev && this.$view) {
          return this.$view.getProjection().getCode();
        }

        return EPSG_3857;
      },

      /**
       * @return {ProjectionLike}
       */
      resolvedDataProjection: function resolvedDataProjection() {
        return coalesce(this.dataProjection, // may or may not be present
        this.projection, // may or may not be present
        this.$map && this.$map.get('dataProjection'), this.$options.dataProjection, this.viewProjection);
      }
    },
    methods: {
      pointToViewProj: function pointToViewProj(point) {
        return transformPoint(point, this.resolvedDataProjection, this.viewProjection);
      },
      pointToDataProj: function pointToDataProj(point) {
        return transformPoint(point, this.viewProjection, this.resolvedDataProjection);
      },
      lineToViewProj: function lineToViewProj(line) {
        return transformLine(line, this.resolvedDataProjection, this.viewProjection);
      },
      lineToDataProj: function lineToDataProj(line) {
        return transformLine(line, this.viewProjection, this.resolvedDataProjection);
      },
      polygonToViewProj: function polygonToViewProj(polygon) {
        return transformPolygon(polygon, this.resolvedDataProjection, this.viewProjection);
      },
      polygonToDataProj: function polygonToDataProj(polygon) {
        return transformPolygon(polygon, this.viewProjection, this.resolvedDataProjection);
      },
      multiPointToViewProj: function multiPointToViewProj(multiPoint) {
        return transformMultiPoint(multiPoint, this.resolvedDataProjection, this.viewProjection);
      },
      multiPointToDataProj: function multiPointToDataProj(multiPoint) {
        return transformMultiPoint(multiPoint, this.viewProjection, this.resolvedDataProjection);
      },
      multiLineToViewProj: function multiLineToViewProj(multiLine) {
        return transformMultiLine(multiLine, this.resolvedDataProjection, this.viewProjection);
      },
      multiLineToDataProj: function multiLineToDataProj(multiLine) {
        return transformMultiLine(multiLine, this.viewProjection, this.resolvedDataProjection);
      },
      multiPolygonToViewProj: function multiPolygonToViewProj(multiPolygon) {
        return transformMultiPolygon(multiPolygon, this.resolvedDataProjection, this.viewProjection);
      },
      multiPolygonToDataProj: function multiPolygonToDataProj(multiPolygon) {
        return transformMultiPolygon(multiPolygon, this.viewProjection, this.resolvedDataProjection);
      },
      extentToViewProj: function extentToViewProj(extent$$1) {
        return proj.transformExtent(extent$$1, this.resolvedDataProjection, this.viewProjection);
      },
      extentToDataProj: function extentToDataProj(extent$$1) {
        return proj.transformExtent(extent$$1, this.viewProjection, this.resolvedDataProjection);
      },
      writeGeometryInDataProj: function writeGeometryInDataProj(geometry) {
        return writeGeoJsonGeometry(geometry, this.viewProjection, this.resolvedDataProjection);
      },
      writeGeometryInViewProj: function writeGeometryInViewProj(geometry) {
        return writeGeoJsonGeometry(geometry);
      },
      readGeometryInDataProj: function readGeometryInDataProj(geometry) {
        return readGeoJsonGeometry(geometry, this.viewProjection, this.resolvedDataProjection);
      },
      writeFeatureInDataProj: function writeFeatureInDataProj(feature) {
        return writeGeoJsonFeature(feature, this.viewProjection, this.resolvedDataProjection);
      },
      writeFeatureInViewProj: function writeFeatureInViewProj(feature) {
        return writeGeoJsonFeature(feature);
      },
      readFeatureInDataProj: function readFeatureInDataProj(feature) {
        return readGeoJsonFeature(feature, this.viewProjection, this.resolvedDataProjection);
      }
    }
  };

  var methods$1 = {
    /**
     * @return {IndexedCollectionAdapter|SourceCollectionAdapter}
     * @protected
     */
    getFeaturesTarget: function getFeaturesTarget() {
      throw new Error('Not implemented method');
    },

    /**
     * @param {Array<(Feature|Vue|Object)>} features
     * @return {void}
     */
    addFeatures: function addFeatures(features) {
      features.forEach(this.addFeature.bind(this));
    },

    /**
     * @param {Feature|Vue|Object} feature
     * @return {void}
     */
    addFeature: function addFeature(feature) {
      if (feature instanceof Vue) {
        feature = feature.$feature;
      } else if (isPlainObject(feature)) {
        feature = this.readFeatureInDataProj(feature);
      }

      instanceOf(feature, Feature);
      this.prepareFeature(feature);

      if (!this.getFeaturesTarget().has(feature)) {
        this.getFeaturesTarget().add(feature);
      }
    },

    /**
     * @param {Array<(Feature|Vue|Object)>} features
     * @return {void}
     */
    removeFeatures: function removeFeatures(features) {
      features.forEach(this.removeFeature.bind(this));
    },

    /**
     * @param {Feature|Vue|Object} feature
     * @return {void}
     */
    removeFeature: function removeFeature(feature) {
      if (feature instanceof Vue) {
        feature = feature.$feature;
      } else if (isPlainObject(feature)) {
        // feature = this._features[feature.id]
        feature = this.getFeatureById(feature.id);
      }

      if (!feature) return;

      if (this.getFeaturesTarget().has(feature)) {
        this.getFeaturesTarget().remove(feature);
      }
    },

    /**
     * @return {void}
     */
    clearFeatures: function clearFeatures() {
      this.getFeaturesTarget().clear();
    },

    /**
     * @param {string|number} id
     * @return {Feature|undefined}
     */
    getFeatureById: function getFeatureById(id) {
      return this.getFeaturesTarget().findByKey(id);
    },

    /**
     * @return {Feature[]}
     */
    getFeatures: function getFeatures() {
      return this.getFeaturesTarget().elements;
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return {
        get featuresContainer() {
          return vm;
        }

      };
    },

    /**
     * @param {Feature} feature
     * @return {Feature}
     * @protected
     */
    prepareFeature: function prepareFeature(feature) {
      return initFeature(feature);
    }
  };
  var featuresContainer = {
    mixins: [projTransforms],
    methods: methods$1
  };

  // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
  _export(_export.S + _export.F * !_descriptors, 'Object', { defineProperties: _objectDps });

  var $Object$3 = _core.Object;
  var defineProperties = function defineProperties(T, D) {
    return $Object$3.defineProperties(T, D);
  };

  var defineProperties$1 = defineProperties;

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isFunction$1(x) {
      return typeof x === 'function';
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var _enable_super_gross_mode_that_will_cause_bad_things = false;
  var config = {
      Promise: undefined,
      set useDeprecatedSynchronousErrorHandling(value) {
          if (value) {
              var error = /*@__PURE__*/ new Error();
              /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
          }
          else if (_enable_super_gross_mode_that_will_cause_bad_things) {
              /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');
          }
          _enable_super_gross_mode_that_will_cause_bad_things = value;
      },
      get useDeprecatedSynchronousErrorHandling() {
          return _enable_super_gross_mode_that_will_cause_bad_things;
      },
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function hostReportError(err) {
      setTimeout(function () { throw err; });
  }

  /** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
  var empty = {
      closed: true,
      next: function (value) { },
      error: function (err) {
          if (config.useDeprecatedSynchronousErrorHandling) {
              throw err;
          }
          else {
              hostReportError(err);
          }
      },
      complete: function () { }
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var isArray$3 = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isObject$3(x) {
      return x != null && typeof x === 'object';
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var errorObject = { e: {} };

  /** PURE_IMPORTS_START _errorObject PURE_IMPORTS_END */
  var tryCatchTarget;
  function tryCatcher() {
      try {
          return tryCatchTarget.apply(this, arguments);
      }
      catch (e) {
          errorObject.e = e;
          return errorObject;
      }
  }
  function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function UnsubscriptionErrorImpl(errors) {
      Error.call(this);
      this.message = errors ?
          errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
      this.name = 'UnsubscriptionError';
      this.errors = errors;
      return this;
  }
  UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
  var UnsubscriptionError = UnsubscriptionErrorImpl;

  /** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_tryCatch,_util_errorObject,_util_UnsubscriptionError PURE_IMPORTS_END */
  var Subscription = /*@__PURE__*/ (function () {
      function Subscription(unsubscribe) {
          this.closed = false;
          this._parent = null;
          this._parents = null;
          this._subscriptions = null;
          if (unsubscribe) {
              this._unsubscribe = unsubscribe;
          }
      }
      Subscription.prototype.unsubscribe = function () {
          var hasErrors = false;
          var errors;
          if (this.closed) {
              return;
          }
          var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
          this.closed = true;
          this._parent = null;
          this._parents = null;
          this._subscriptions = null;
          var index = -1;
          var len = _parents ? _parents.length : 0;
          while (_parent) {
              _parent.remove(this);
              _parent = ++index < len && _parents[index] || null;
          }
          if (isFunction$1(_unsubscribe)) {
              var trial = tryCatch(_unsubscribe).call(this);
              if (trial === errorObject) {
                  hasErrors = true;
                  errors = errors || (errorObject.e instanceof UnsubscriptionError ?
                      flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);
              }
          }
          if (isArray$3(_subscriptions)) {
              index = -1;
              len = _subscriptions.length;
              while (++index < len) {
                  var sub = _subscriptions[index];
                  if (isObject$3(sub)) {
                      var trial = tryCatch(sub.unsubscribe).call(sub);
                      if (trial === errorObject) {
                          hasErrors = true;
                          errors = errors || [];
                          var err = errorObject.e;
                          if (err instanceof UnsubscriptionError) {
                              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                          }
                          else {
                              errors.push(err);
                          }
                      }
                  }
              }
          }
          if (hasErrors) {
              throw new UnsubscriptionError(errors);
          }
      };
      Subscription.prototype.add = function (teardown) {
          if (!teardown || (teardown === Subscription.EMPTY)) {
              return Subscription.EMPTY;
          }
          if (teardown === this) {
              return this;
          }
          var subscription = teardown;
          switch (typeof teardown) {
              case 'function':
                  subscription = new Subscription(teardown);
              case 'object':
                  if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                      return subscription;
                  }
                  else if (this.closed) {
                      subscription.unsubscribe();
                      return subscription;
                  }
                  else if (typeof subscription._addParent !== 'function') {
                      var tmp = subscription;
                      subscription = new Subscription();
                      subscription._subscriptions = [tmp];
                  }
                  break;
              default:
                  throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
          }
          var subscriptions = this._subscriptions || (this._subscriptions = []);
          subscriptions.push(subscription);
          subscription._addParent(this);
          return subscription;
      };
      Subscription.prototype.remove = function (subscription) {
          var subscriptions = this._subscriptions;
          if (subscriptions) {
              var subscriptionIndex = subscriptions.indexOf(subscription);
              if (subscriptionIndex !== -1) {
                  subscriptions.splice(subscriptionIndex, 1);
              }
          }
      };
      Subscription.prototype._addParent = function (parent) {
          var _a = this, _parent = _a._parent, _parents = _a._parents;
          if (!_parent || _parent === parent) {
              this._parent = parent;
          }
          else if (!_parents) {
              this._parents = [parent];
          }
          else if (_parents.indexOf(parent) === -1) {
              _parents.push(parent);
          }
      };
      Subscription.EMPTY = (function (empty) {
          empty.closed = true;
          return empty;
      }(new Subscription()));
      return Subscription;
  }());
  function flattenUnsubscriptionErrors(errors) {
      return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var rxSubscriber = typeof Symbol === 'function'
      ? /*@__PURE__*/ Symbol('rxSubscriber')
      : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();

  /** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
  var Subscriber = /*@__PURE__*/ (function (_super) {
      __extends(Subscriber, _super);
      function Subscriber(destinationOrNext, error, complete) {
          var _this = _super.call(this) || this;
          _this.syncErrorValue = null;
          _this.syncErrorThrown = false;
          _this.syncErrorThrowable = false;
          _this.isStopped = false;
          _this._parentSubscription = null;
          switch (arguments.length) {
              case 0:
                  _this.destination = empty;
                  break;
              case 1:
                  if (!destinationOrNext) {
                      _this.destination = empty;
                      break;
                  }
                  if (typeof destinationOrNext === 'object') {
                      if (destinationOrNext instanceof Subscriber) {
                          _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                          _this.destination = destinationOrNext;
                          destinationOrNext.add(_this);
                      }
                      else {
                          _this.syncErrorThrowable = true;
                          _this.destination = new SafeSubscriber(_this, destinationOrNext);
                      }
                      break;
                  }
              default:
                  _this.syncErrorThrowable = true;
                  _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                  break;
          }
          return _this;
      }
      Subscriber.prototype[rxSubscriber] = function () { return this; };
      Subscriber.create = function (next, error, complete) {
          var subscriber = new Subscriber(next, error, complete);
          subscriber.syncErrorThrowable = false;
          return subscriber;
      };
      Subscriber.prototype.next = function (value) {
          if (!this.isStopped) {
              this._next(value);
          }
      };
      Subscriber.prototype.error = function (err) {
          if (!this.isStopped) {
              this.isStopped = true;
              this._error(err);
          }
      };
      Subscriber.prototype.complete = function () {
          if (!this.isStopped) {
              this.isStopped = true;
              this._complete();
          }
      };
      Subscriber.prototype.unsubscribe = function () {
          if (this.closed) {
              return;
          }
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
      };
      Subscriber.prototype._next = function (value) {
          this.destination.next(value);
      };
      Subscriber.prototype._error = function (err) {
          this.destination.error(err);
          this.unsubscribe();
      };
      Subscriber.prototype._complete = function () {
          this.destination.complete();
          this.unsubscribe();
      };
      Subscriber.prototype._unsubscribeAndRecycle = function () {
          var _a = this, _parent = _a._parent, _parents = _a._parents;
          this._parent = null;
          this._parents = null;
          this.unsubscribe();
          this.closed = false;
          this.isStopped = false;
          this._parent = _parent;
          this._parents = _parents;
          this._parentSubscription = null;
          return this;
      };
      return Subscriber;
  }(Subscription));
  var SafeSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(SafeSubscriber, _super);
      function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
          var _this = _super.call(this) || this;
          _this._parentSubscriber = _parentSubscriber;
          var next;
          var context = _this;
          if (isFunction$1(observerOrNext)) {
              next = observerOrNext;
          }
          else if (observerOrNext) {
              next = observerOrNext.next;
              error = observerOrNext.error;
              complete = observerOrNext.complete;
              if (observerOrNext !== empty) {
                  context = Object.create(observerOrNext);
                  if (isFunction$1(context.unsubscribe)) {
                      _this.add(context.unsubscribe.bind(context));
                  }
                  context.unsubscribe = _this.unsubscribe.bind(_this);
              }
          }
          _this._context = context;
          _this._next = next;
          _this._error = error;
          _this._complete = complete;
          return _this;
      }
      SafeSubscriber.prototype.next = function (value) {
          if (!this.isStopped && this._next) {
              var _parentSubscriber = this._parentSubscriber;
              if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                  this.__tryOrUnsub(this._next, value);
              }
              else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                  this.unsubscribe();
              }
          }
      };
      SafeSubscriber.prototype.error = function (err) {
          if (!this.isStopped) {
              var _parentSubscriber = this._parentSubscriber;
              var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
              if (this._error) {
                  if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                      this.__tryOrUnsub(this._error, err);
                      this.unsubscribe();
                  }
                  else {
                      this.__tryOrSetError(_parentSubscriber, this._error, err);
                      this.unsubscribe();
                  }
              }
              else if (!_parentSubscriber.syncErrorThrowable) {
                  this.unsubscribe();
                  if (useDeprecatedSynchronousErrorHandling) {
                      throw err;
                  }
                  hostReportError(err);
              }
              else {
                  if (useDeprecatedSynchronousErrorHandling) {
                      _parentSubscriber.syncErrorValue = err;
                      _parentSubscriber.syncErrorThrown = true;
                  }
                  else {
                      hostReportError(err);
                  }
                  this.unsubscribe();
              }
          }
      };
      SafeSubscriber.prototype.complete = function () {
          var _this = this;
          if (!this.isStopped) {
              var _parentSubscriber = this._parentSubscriber;
              if (this._complete) {
                  var wrappedComplete = function () { return _this._complete.call(_this._context); };
                  if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                      this.__tryOrUnsub(wrappedComplete);
                      this.unsubscribe();
                  }
                  else {
                      this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                      this.unsubscribe();
                  }
              }
              else {
                  this.unsubscribe();
              }
          }
      };
      SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
          try {
              fn.call(this._context, value);
          }
          catch (err) {
              this.unsubscribe();
              if (config.useDeprecatedSynchronousErrorHandling) {
                  throw err;
              }
              else {
                  hostReportError(err);
              }
          }
      };
      SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
          if (!config.useDeprecatedSynchronousErrorHandling) {
              throw new Error('bad call');
          }
          try {
              fn.call(this._context, value);
          }
          catch (err) {
              if (config.useDeprecatedSynchronousErrorHandling) {
                  parent.syncErrorValue = err;
                  parent.syncErrorThrown = true;
                  return true;
              }
              else {
                  hostReportError(err);
                  return true;
              }
          }
          return false;
      };
      SafeSubscriber.prototype._unsubscribe = function () {
          var _parentSubscriber = this._parentSubscriber;
          this._context = null;
          this._parentSubscriber = null;
          _parentSubscriber.unsubscribe();
      };
      return SafeSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */
  function distinctUntilChanged(compare, keySelector) {
      return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
  }
  var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
      function DistinctUntilChangedOperator(compare, keySelector) {
          this.compare = compare;
          this.keySelector = keySelector;
      }
      DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
      };
      return DistinctUntilChangedOperator;
  }());
  var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(DistinctUntilChangedSubscriber, _super);
      function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
          var _this = _super.call(this, destination) || this;
          _this.keySelector = keySelector;
          _this.hasKey = false;
          if (typeof compare === 'function') {
              _this.compare = compare;
          }
          return _this;
      }
      DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
          return x === y;
      };
      DistinctUntilChangedSubscriber.prototype._next = function (value) {
          var keySelector = this.keySelector;
          var key = value;
          if (keySelector) {
              key = tryCatch(this.keySelector)(value);
              if (key === errorObject) {
                  return this.destination.error(errorObject.e);
              }
          }
          var result = false;
          if (this.hasKey) {
              result = tryCatch(this.compare)(this.key, key);
              if (result === errorObject) {
                  return this.destination.error(errorObject.e);
              }
          }
          else {
              this.hasKey = true;
          }
          if (Boolean(result) === false) {
              this.key = key;
              this.destination.next(value);
          }
      };
      return DistinctUntilChangedSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  function map$3(project, thisArg) {
      return function mapOperation(source) {
          if (typeof project !== 'function') {
              throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
          }
          return source.lift(new MapOperator(project, thisArg));
      };
  }
  var MapOperator = /*@__PURE__*/ (function () {
      function MapOperator(project, thisArg) {
          this.project = project;
          this.thisArg = thisArg;
      }
      MapOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
      };
      return MapOperator;
  }());
  var MapSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(MapSubscriber, _super);
      function MapSubscriber(destination, project, thisArg) {
          var _this = _super.call(this, destination) || this;
          _this.project = project;
          _this.count = 0;
          _this.thisArg = thisArg || _this;
          return _this;
      }
      MapSubscriber.prototype._next = function (value) {
          var result;
          try {
              result = this.project.call(this.thisArg, value, this.count++);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          this.destination.next(result);
      };
      return MapSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
  var Action = /*@__PURE__*/ (function (_super) {
      __extends(Action, _super);
      function Action(scheduler, work) {
          return _super.call(this) || this;
      }
      Action.prototype.schedule = function (state, delay) {
          if (delay === void 0) {
              delay = 0;
          }
          return this;
      };
      return Action;
  }(Subscription));

  /** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
  var AsyncAction = /*@__PURE__*/ (function (_super) {
      __extends(AsyncAction, _super);
      function AsyncAction(scheduler, work) {
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          _this.pending = false;
          return _this;
      }
      AsyncAction.prototype.schedule = function (state, delay) {
          if (delay === void 0) {
              delay = 0;
          }
          if (this.closed) {
              return this;
          }
          this.state = state;
          var id = this.id;
          var scheduler = this.scheduler;
          if (id != null) {
              this.id = this.recycleAsyncId(scheduler, id, delay);
          }
          this.pending = true;
          this.delay = delay;
          this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
          return this;
      };
      AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
          if (delay === void 0) {
              delay = 0;
          }
          return setInterval(scheduler.flush.bind(scheduler, this), delay);
      };
      AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
          if (delay === void 0) {
              delay = 0;
          }
          if (delay !== null && this.delay === delay && this.pending === false) {
              return id;
          }
          clearInterval(id);
      };
      AsyncAction.prototype.execute = function (state, delay) {
          if (this.closed) {
              return new Error('executing a cancelled action');
          }
          this.pending = false;
          var error = this._execute(state, delay);
          if (error) {
              return error;
          }
          else if (this.pending === false && this.id != null) {
              this.id = this.recycleAsyncId(this.scheduler, this.id, null);
          }
      };
      AsyncAction.prototype._execute = function (state, delay) {
          var errored = false;
          var errorValue = undefined;
          try {
              this.work(state);
          }
          catch (e) {
              errored = true;
              errorValue = !!e && e || new Error(e);
          }
          if (errored) {
              this.unsubscribe();
              return errorValue;
          }
      };
      AsyncAction.prototype._unsubscribe = function () {
          var id = this.id;
          var scheduler = this.scheduler;
          var actions = scheduler.actions;
          var index = actions.indexOf(this);
          this.work = null;
          this.state = null;
          this.pending = false;
          this.scheduler = null;
          if (index !== -1) {
              actions.splice(index, 1);
          }
          if (id != null) {
              this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
      };
      return AsyncAction;
  }(Action));

  var Scheduler = /*@__PURE__*/ (function () {
      function Scheduler(SchedulerAction, now) {
          if (now === void 0) {
              now = Scheduler.now;
          }
          this.SchedulerAction = SchedulerAction;
          this.now = now;
      }
      Scheduler.prototype.schedule = function (work, delay, state) {
          if (delay === void 0) {
              delay = 0;
          }
          return new this.SchedulerAction(this, work).schedule(state, delay);
      };
      Scheduler.now = function () { return Date.now(); };
      return Scheduler;
  }());

  /** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
  var AsyncScheduler = /*@__PURE__*/ (function (_super) {
      __extends(AsyncScheduler, _super);
      function AsyncScheduler(SchedulerAction, now) {
          if (now === void 0) {
              now = Scheduler.now;
          }
          var _this = _super.call(this, SchedulerAction, function () {
              if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                  return AsyncScheduler.delegate.now();
              }
              else {
                  return now();
              }
          }) || this;
          _this.actions = [];
          _this.active = false;
          _this.scheduled = undefined;
          return _this;
      }
      AsyncScheduler.prototype.schedule = function (work, delay, state) {
          if (delay === void 0) {
              delay = 0;
          }
          if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
              return AsyncScheduler.delegate.schedule(work, delay, state);
          }
          else {
              return _super.prototype.schedule.call(this, work, delay, state);
          }
      };
      AsyncScheduler.prototype.flush = function (action) {
          var actions = this.actions;
          if (this.active) {
              actions.push(action);
              return;
          }
          var error;
          this.active = true;
          do {
              if (error = action.execute(action.state, action.delay)) {
                  break;
              }
          } while (action = actions.shift());
          this.active = false;
          if (error) {
              while (action = actions.shift()) {
                  action.unsubscribe();
              }
              throw error;
          }
      };
      return AsyncScheduler;
  }(Scheduler));

  /** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
  var async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  var OuterSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(OuterSubscriber, _super);
      function OuterSubscriber() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(innerValue);
      };
      OuterSubscriber.prototype.notifyError = function (error, innerSub) {
          this.destination.error(error);
      };
      OuterSubscriber.prototype.notifyComplete = function (innerSub) {
          this.destination.complete();
      };
      return OuterSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  var InnerSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(InnerSubscriber, _super);
      function InnerSubscriber(parent, outerValue, outerIndex) {
          var _this = _super.call(this) || this;
          _this.parent = parent;
          _this.outerValue = outerValue;
          _this.outerIndex = outerIndex;
          _this.index = 0;
          return _this;
      }
      InnerSubscriber.prototype._next = function (value) {
          this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
      };
      InnerSubscriber.prototype._error = function (error) {
          this.parent.notifyError(error, this);
          this.unsubscribe();
      };
      InnerSubscriber.prototype._complete = function () {
          this.parent.notifyComplete(this);
          this.unsubscribe();
      };
      return InnerSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
  function canReportError(observer) {
      while (observer) {
          var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
          if (closed_1 || isStopped) {
              return false;
          }
          else if (destination && destination instanceof Subscriber) {
              observer = destination;
          }
          else {
              observer = null;
          }
      }
      return true;
  }

  /** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
  function toSubscriber(nextOrObserver, error, complete) {
      if (nextOrObserver) {
          if (nextOrObserver instanceof Subscriber) {
              return nextOrObserver;
          }
          if (nextOrObserver[rxSubscriber]) {
              return nextOrObserver[rxSubscriber]();
          }
      }
      if (!nextOrObserver && !error && !complete) {
          return new Subscriber(empty);
      }
      return new Subscriber(nextOrObserver, error, complete);
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function noop$1() { }

  /** PURE_IMPORTS_START _noop PURE_IMPORTS_END */
  function pipeFromArray(fns) {
      if (!fns) {
          return noop$1;
      }
      if (fns.length === 1) {
          return fns[0];
      }
      return function piped(input) {
          return fns.reduce(function (prev, fn) { return fn(prev); }, input);
      };
  }

  /** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
  var Observable = /*@__PURE__*/ (function () {
      function Observable(subscribe) {
          this._isScalar = false;
          if (subscribe) {
              this._subscribe = subscribe;
          }
      }
      Observable.prototype.lift = function (operator) {
          var observable$$1 = new Observable();
          observable$$1.source = this;
          observable$$1.operator = operator;
          return observable$$1;
      };
      Observable.prototype.subscribe = function (observerOrNext, error, complete) {
          var operator = this.operator;
          var sink = toSubscriber(observerOrNext, error, complete);
          if (operator) {
              operator.call(sink, this.source);
          }
          else {
              sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                  this._subscribe(sink) :
                  this._trySubscribe(sink));
          }
          if (config.useDeprecatedSynchronousErrorHandling) {
              if (sink.syncErrorThrowable) {
                  sink.syncErrorThrowable = false;
                  if (sink.syncErrorThrown) {
                      throw sink.syncErrorValue;
                  }
              }
          }
          return sink;
      };
      Observable.prototype._trySubscribe = function (sink) {
          try {
              return this._subscribe(sink);
          }
          catch (err) {
              if (config.useDeprecatedSynchronousErrorHandling) {
                  sink.syncErrorThrown = true;
                  sink.syncErrorValue = err;
              }
              if (canReportError(sink)) {
                  sink.error(err);
              }
              else {
                  console.warn(err);
              }
          }
      };
      Observable.prototype.forEach = function (next, promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function (resolve, reject) {
              var subscription;
              subscription = _this.subscribe(function (value) {
                  try {
                      next(value);
                  }
                  catch (err) {
                      reject(err);
                      if (subscription) {
                          subscription.unsubscribe();
                      }
                  }
              }, reject, resolve);
          });
      };
      Observable.prototype._subscribe = function (subscriber) {
          var source = this.source;
          return source && source.subscribe(subscriber);
      };
      Observable.prototype[observable] = function () {
          return this;
      };
      Observable.prototype.pipe = function () {
          var operations = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              operations[_i] = arguments[_i];
          }
          if (operations.length === 0) {
              return this;
          }
          return pipeFromArray(operations)(this);
      };
      Observable.prototype.toPromise = function (promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function (resolve, reject) {
              var value;
              _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
          });
      };
      Observable.create = function (subscribe) {
          return new Observable(subscribe);
      };
      return Observable;
  }());
  function getPromiseCtor(promiseCtor) {
      if (!promiseCtor) {
          promiseCtor = config.Promise || Promise;
      }
      if (!promiseCtor) {
          throw new Error('no Promise impl found');
      }
      return promiseCtor;
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var subscribeToArray = function (array) {
      return function (subscriber) {
          for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
              subscriber.next(array[i]);
          }
          if (!subscriber.closed) {
              subscriber.complete();
          }
      };
  };

  /** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
  var subscribeToPromise = function (promise) {
      return function (subscriber) {
          promise.then(function (value) {
              if (!subscriber.closed) {
                  subscriber.next(value);
                  subscriber.complete();
              }
          }, function (err) { return subscriber.error(err); })
              .then(null, hostReportError);
          return subscriber;
      };
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function getSymbolIterator() {
      if (typeof Symbol !== 'function' || !Symbol.iterator) {
          return '@@iterator';
      }
      return Symbol.iterator;
  }
  var iterator$2 = /*@__PURE__*/ getSymbolIterator();

  /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
  var subscribeToIterable = function (iterable) {
      return function (subscriber) {
          var iterator$$1 = iterable[iterator$2]();
          do {
              var item = iterator$$1.next();
              if (item.done) {
                  subscriber.complete();
                  break;
              }
              subscriber.next(item.value);
              if (subscriber.closed) {
                  break;
              }
          } while (true);
          if (typeof iterator$$1.return === 'function') {
              subscriber.add(function () {
                  if (iterator$$1.return) {
                      iterator$$1.return();
                  }
              });
          }
          return subscriber;
      };
  };

  /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
  var subscribeToObservable = function (obj) {
      return function (subscriber) {
          var obs = obj[observable]();
          if (typeof obs.subscribe !== 'function') {
              throw new TypeError('Provided object does not correctly implement Symbol.observable');
          }
          else {
              return obs.subscribe(subscriber);
          }
      };
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var isArrayLike$1 = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isPromise(value) {
      return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
  }

  /** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
  var subscribeTo = function (result) {
      if (result instanceof Observable) {
          return function (subscriber) {
              if (result._isScalar) {
                  subscriber.next(result.value);
                  subscriber.complete();
                  return undefined;
              }
              else {
                  return result.subscribe(subscriber);
              }
          };
      }
      else if (result && typeof result[observable] === 'function') {
          return subscribeToObservable(result);
      }
      else if (isArrayLike$1(result)) {
          return subscribeToArray(result);
      }
      else if (isPromise(result)) {
          return subscribeToPromise(result);
      }
      else if (result && typeof result[iterator$2] === 'function') {
          return subscribeToIterable(result);
      }
      else {
          var value = isObject$3(result) ? 'an invalid object' : "'" + result + "'";
          var msg = "You provided " + value + " where a stream was expected."
              + ' You can provide an Observable, Promise, Array, or Iterable.';
          throw new TypeError(msg);
      }
  };

  /** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */
  function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
      if (destination === void 0) {
          destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
      }
      if (destination.closed) {
          return;
      }
      return subscribeTo(result)(destination);
  }

  /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
  var defaultThrottleConfig = {
      leading: true,
      trailing: false
  };
  var ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(ThrottleSubscriber, _super);
      function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
          var _this = _super.call(this, destination) || this;
          _this.destination = destination;
          _this.durationSelector = durationSelector;
          _this._leading = _leading;
          _this._trailing = _trailing;
          _this._hasValue = false;
          return _this;
      }
      ThrottleSubscriber.prototype._next = function (value) {
          this._hasValue = true;
          this._sendValue = value;
          if (!this._throttled) {
              if (this._leading) {
                  this.send();
              }
              else {
                  this.throttle(value);
              }
          }
      };
      ThrottleSubscriber.prototype.send = function () {
          var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
          if (_hasValue) {
              this.destination.next(_sendValue);
              this.throttle(_sendValue);
          }
          this._hasValue = false;
          this._sendValue = null;
      };
      ThrottleSubscriber.prototype.throttle = function (value) {
          var duration = this.tryDurationSelector(value);
          if (duration) {
              this.add(this._throttled = subscribeToResult(this, duration));
          }
      };
      ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
          try {
              return this.durationSelector(value);
          }
          catch (err) {
              this.destination.error(err);
              return null;
          }
      };
      ThrottleSubscriber.prototype.throttlingDone = function () {
          var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
          if (_throttled) {
              _throttled.unsubscribe();
          }
          this._throttled = null;
          if (_trailing) {
              this.send();
          }
      };
      ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.throttlingDone();
      };
      ThrottleSubscriber.prototype.notifyComplete = function () {
          this.throttlingDone();
      };
      return ThrottleSubscriber;
  }(OuterSubscriber));

  /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */
  function throttleTime(duration, scheduler, config) {
      if (scheduler === void 0) {
          scheduler = async;
      }
      if (config === void 0) {
          config = defaultThrottleConfig;
      }
      return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
  }
  var ThrottleTimeOperator = /*@__PURE__*/ (function () {
      function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
          this.duration = duration;
          this.scheduler = scheduler;
          this.leading = leading;
          this.trailing = trailing;
      }
      ThrottleTimeOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
      };
      return ThrottleTimeOperator;
  }());
  var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(ThrottleTimeSubscriber, _super);
      function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
          var _this = _super.call(this, destination) || this;
          _this.duration = duration;
          _this.scheduler = scheduler;
          _this.leading = leading;
          _this.trailing = trailing;
          _this._hasTrailingValue = false;
          _this._trailingValue = null;
          return _this;
      }
      ThrottleTimeSubscriber.prototype._next = function (value) {
          if (this.throttled) {
              if (this.trailing) {
                  this._trailingValue = value;
                  this._hasTrailingValue = true;
              }
          }
          else {
              this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
              if (this.leading) {
                  this.destination.next(value);
              }
          }
      };
      ThrottleTimeSubscriber.prototype._complete = function () {
          if (this._hasTrailingValue) {
              this.destination.next(this._trailingValue);
              this.destination.complete();
          }
          else {
              this.destination.complete();
          }
      };
      ThrottleTimeSubscriber.prototype.clearThrottle = function () {
          var throttled = this.throttled;
          if (throttled) {
              if (this.trailing && this._hasTrailingValue) {
                  this.destination.next(this._trailingValue);
                  this._trailingValue = null;
                  this._hasTrailingValue = false;
              }
              throttled.unsubscribe();
              this.remove(throttled);
              this.throttled = null;
          }
      };
      return ThrottleTimeSubscriber;
  }(Subscriber));
  function dispatchNext(arg) {
      var subscriber = arg.subscriber;
      subscriber.clearThrottle();
  }

  /**
   * Extent extensions
   */
  /**
   * Create a new extent or update the provided extent.
   * @param {number} minX Minimum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxX Maximum X.
   * @param {number} maxY Maximum Y.
   * @param {Extent=} extent Destination extent.
   * @return {Extent} Extent.
   * @see https://github.com/openlayers/openlayers/blob/master/src/ol/extent.js#L208
   */

  function createOrUpdateExtent(minX, minY, maxX, maxY, extent$$1) {
    if (extent$$1) {
      extent$$1[0] = minX;
      extent$$1[1] = minY;
      extent$$1[2] = maxX;
      extent$$1[3] = maxY;
      return extent$$1;
    } else {
      return [minX, minY, maxX, maxY];
    }
  }
  /**
   * Get a corner coordinate of an extent.
   * @param {Extent|number[]} extent Extent.
   * @param {string} corner Corner.
   * @return {Coordinate} Corner coordinate.
   * @see https://github.com/openlayers/openlayers/blob/master/src/ol/extent.js#L482
   */

  function getExtentCorner(extent$$1, corner) {
    var coordinate;

    if (corner === EXTENT_CORNER.BOTTOM_LEFT) {
      coordinate = extent.getBottomLeft(extent$$1);
    } else if (corner === EXTENT_CORNER.BOTTOM_RIGHT) {
      coordinate = extent.getBottomRight(extent$$1);
    } else if (corner === EXTENT_CORNER.TOP_LEFT) {
      coordinate = extent.getTopLeft(extent$$1);
    } else if (corner === EXTENT_CORNER.TOP_RIGHT) {
      coordinate = extent.getTopRight(extent$$1);
    } else {
      throw new Error('Invalid corner');
    }

    return coordinate;
  }
  /**
   * Generate a tile grid extent from a projection.  If the projection has an
   * extent, it is used.  If not, a global extent is assumed.
   * @param {Projection} projection Projection.
   * @return {Extent} Extent.
   * @see https://github.com/openlayers/openlayers/blob/master/src/ol/tilegrid.js#L148
   */

  function createExtentFromProjection(projection) {
    projection = proj.get(projection);
    var extent$$1 = projection.getExtent();

    if (!extent$$1) {
      var half = 180 * Units.METERS_PER_UNIT[PROJ_UNIT.DEGREES] / projection.getMetersPerUnit();
      extent$$1 = createOrUpdateExtent(-half, -half, half, half);
    }

    return extent$$1;
  }

  function _arrayWithoutHoles(arr) {
    if (isArray$1(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    }
  }

  var ITERATOR$4 = _wks('iterator');

  var core_isIterable = _core.isIterable = function (it) {
    var O = Object(it);
    return O[ITERATOR$4] !== undefined
      || '@@iterator' in O
      // eslint-disable-next-line no-prototype-builtins
      || _iterators.hasOwnProperty(_classof(O));
  };

  var isIterable = core_isIterable;

  var isIterable$1 = isIterable;

  function _iterableToArray(iter) {
    if (isIterable$1(Object(iter)) || Object.prototype.toString.call(iter) === "[object Arguments]") return from_1$1(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  /** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
  function fromEventPattern(addHandler, removeHandler, resultSelector) {
      if (resultSelector) {
          return fromEventPattern(addHandler, removeHandler).pipe(map$3(function (args) { return isArray$3(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
      }
      return new Observable(function (subscriber) {
          var handler = function () {
              var e = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  e[_i] = arguments[_i];
              }
              return subscriber.next(e.length === 1 ? e[0] : e);
          };
          var retValue;
          try {
              retValue = addHandler(handler);
          }
          catch (err) {
              subscriber.error(err);
              return undefined;
          }
          if (!isFunction$1(removeHandler)) {
              return undefined;
          }
          return function () { return removeHandler(handler, retValue); };
      });
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isScheduler(value) {
      return value && typeof value.schedule === 'function';
  }

  /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
  function isInteropObservable(input) {
      return input && typeof input[observable] === 'function';
  }

  /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
  function isIterable$2(input) {
      return input && typeof input[iterator$2] === 'function';
  }

  /** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */
  function fromArray(input, scheduler) {
      if (!scheduler) {
          return new Observable(subscribeToArray(input));
      }
      else {
          return new Observable(function (subscriber) {
              var sub = new Subscription();
              var i = 0;
              sub.add(scheduler.schedule(function () {
                  if (i === input.length) {
                      subscriber.complete();
                      return;
                  }
                  subscriber.next(input[i++]);
                  if (!subscriber.closed) {
                      sub.add(this.schedule());
                  }
              }));
              return sub;
          });
      }
  }

  /** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */
  function fromPromise(input, scheduler) {
      if (!scheduler) {
          return new Observable(subscribeToPromise(input));
      }
      else {
          return new Observable(function (subscriber) {
              var sub = new Subscription();
              sub.add(scheduler.schedule(function () {
                  return input.then(function (value) {
                      sub.add(scheduler.schedule(function () {
                          subscriber.next(value);
                          sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                      }));
                  }, function (err) {
                      sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
                  });
              }));
              return sub;
          });
      }
  }

  /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */
  function fromIterable(input, scheduler) {
      if (!input) {
          throw new Error('Iterable cannot be null');
      }
      if (!scheduler) {
          return new Observable(subscribeToIterable(input));
      }
      else {
          return new Observable(function (subscriber) {
              var sub = new Subscription();
              var iterator$$1;
              sub.add(function () {
                  if (iterator$$1 && typeof iterator$$1.return === 'function') {
                      iterator$$1.return();
                  }
              });
              sub.add(scheduler.schedule(function () {
                  iterator$$1 = input[iterator$2]();
                  sub.add(scheduler.schedule(function () {
                      if (subscriber.closed) {
                          return;
                      }
                      var value;
                      var done;
                      try {
                          var result = iterator$$1.next();
                          value = result.value;
                          done = result.done;
                      }
                      catch (err) {
                          subscriber.error(err);
                          return;
                      }
                      if (done) {
                          subscriber.complete();
                      }
                      else {
                          subscriber.next(value);
                          this.schedule();
                      }
                  }));
              }));
              return sub;
          });
      }
  }

  /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */
  function fromObservable(input, scheduler) {
      if (!scheduler) {
          return new Observable(subscribeToObservable(input));
      }
      else {
          return new Observable(function (subscriber) {
              var sub = new Subscription();
              sub.add(scheduler.schedule(function () {
                  var observable$$1 = input[observable]();
                  sub.add(observable$$1.subscribe({
                      next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                      error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                      complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
                  }));
              }));
              return sub;
          });
      }
  }

  /** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */
  function from(input, scheduler) {
      if (!scheduler) {
          if (input instanceof Observable) {
              return input;
          }
          return new Observable(subscribeTo(input));
      }
      if (input != null) {
          if (isInteropObservable(input)) {
              return fromObservable(input, scheduler);
          }
          else if (isPromise(input)) {
              return fromPromise(input, scheduler);
          }
          else if (isArrayLike$1(input)) {
              return fromArray(input, scheduler);
          }
          else if (isIterable$2(input) || typeof input === 'string') {
              return fromIterable(input, scheduler);
          }
      }
      throw new TypeError((input !== null && typeof input || input) + ' is not observable');
  }

  /** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
  function mergeMap(project, resultSelector, concurrent) {
      if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
      }
      if (typeof resultSelector === 'function') {
          return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map$3(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
      }
      else if (typeof resultSelector === 'number') {
          concurrent = resultSelector;
      }
      return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
  }
  var MergeMapOperator = /*@__PURE__*/ (function () {
      function MergeMapOperator(project, concurrent) {
          if (concurrent === void 0) {
              concurrent = Number.POSITIVE_INFINITY;
          }
          this.project = project;
          this.concurrent = concurrent;
      }
      MergeMapOperator.prototype.call = function (observer, source) {
          return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
      };
      return MergeMapOperator;
  }());
  var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(MergeMapSubscriber, _super);
      function MergeMapSubscriber(destination, project, concurrent) {
          if (concurrent === void 0) {
              concurrent = Number.POSITIVE_INFINITY;
          }
          var _this = _super.call(this, destination) || this;
          _this.project = project;
          _this.concurrent = concurrent;
          _this.hasCompleted = false;
          _this.buffer = [];
          _this.active = 0;
          _this.index = 0;
          return _this;
      }
      MergeMapSubscriber.prototype._next = function (value) {
          if (this.active < this.concurrent) {
              this._tryNext(value);
          }
          else {
              this.buffer.push(value);
          }
      };
      MergeMapSubscriber.prototype._tryNext = function (value) {
          var result;
          var index = this.index++;
          try {
              result = this.project(value, index);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          this.active++;
          this._innerSub(result, value, index);
      };
      MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
          var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
          var destination = this.destination;
          destination.add(innerSubscriber);
          subscribeToResult(this, ish, value, index, innerSubscriber);
      };
      MergeMapSubscriber.prototype._complete = function () {
          this.hasCompleted = true;
          if (this.active === 0 && this.buffer.length === 0) {
              this.destination.complete();
          }
          this.unsubscribe();
      };
      MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(innerValue);
      };
      MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
          var buffer = this.buffer;
          this.remove(innerSub);
          this.active--;
          if (buffer.length > 0) {
              this._next(buffer.shift());
          }
          else if (this.active === 0 && this.hasCompleted) {
              this.destination.complete();
          }
      };
      return MergeMapSubscriber;
  }(OuterSubscriber));

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function identity$1(x) {
      return x;
  }

  /** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
  function mergeAll(concurrent) {
      if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
      }
      return mergeMap(identity$1, concurrent);
  }

  /** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
  function merge() {
      var observables = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          observables[_i] = arguments[_i];
      }
      var concurrent = Number.POSITIVE_INFINITY;
      var scheduler = null;
      var last = observables[observables.length - 1];
      if (isScheduler(last)) {
          scheduler = observables.pop();
          if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
              concurrent = observables.pop();
          }
      }
      else if (typeof last === 'number') {
          concurrent = observables.pop();
      }
      if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
          return observables[0];
      }
      return mergeAll(concurrent)(fromArray(observables, scheduler));
  }

  /**
   * Creates an Observable using OpenLayers event pattern that emits events coming from the given event target.
   *
   * @example **Subscribe on view center change events**
   * const map = ol.Map({ ... })
   * const changes = Observable.fromOlEvent(map.getView(), 'change:center')
   *
   * changes.subscribe(({ coordinate }) => console.log(coordinate))
   *
   * @param {ol.Object} target OpenLayers event target.
   * @param {string|Object[]} eventName The event name of interest, being emitted by the `target`
   *                          or an array of events/selectors like `[{ event: 'event1', selector?: x => x }, ...]`.
   * @param {function(...*): *} [selector] An optional function to post-process results. It takes the arguments
   *    from the event handler and should return a single value.
   * @return {Observable<T>}
   * @memberOf {Observable}
   */

  function fromOlEvent(target, eventName, selector) {
    if (isArray$1(eventName)) {
      return merge.apply(void 0, _toConsumableArray(eventName.map(function (elem) {
        var eventName, selector;

        if (_typeof(elem) === 'object') {
          eventName = elem.event;
          selector = elem.selector;
        } else {
          eventName = elem;
        }

        return fromOlEvent(target, eventName, selector);
      })));
    }

    return fromEventPattern(function (handler) {
      return target.on(eventName, handler);
    }, function (handler) {
      return target.un(eventName, handler);
    }, selector);
  }

  /*!
   * merge-descriptors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  /**
   * Module exports.
   * @public
   */

  var mergeDescriptors = merge$1;

  /**
   * Module variables.
   * @private
   */

  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

  /**
   * Merge the property descriptors of `src` into `dest`
   *
   * @param {object} dest Object to add descriptors to
   * @param {object} src Object to clone descriptors from
   * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
   * @returns {object} Reference to dest
   * @public
   */

  function merge$1(dest, src, redefine) {
    if (!dest) {
      throw new TypeError('argument dest is required')
    }

    if (!src) {
      throw new TypeError('argument src is required')
    }

    if (redefine === undefined) {
      // Default to true
      redefine = true;
    }

    Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
      if (!redefine && hasOwnProperty$1.call(dest, name)) {
        // Skip desriptor
        return
      }

      // Copy descriptor
      var descriptor = Object.getOwnPropertyDescriptor(src, name);
      Object.defineProperty(dest, name, descriptor);
    });

    return dest
  }

  /**
   * @param {...Object} args
   * @returns {Object}
   */

  function multiMergeDescriptors() {
    var redefine;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (_typeof(args[args.length - 1]) !== 'object') {
      redefine = args.pop();
    }

    return args.slice(1).reduce(function (dest, src, i) {
      return mergeDescriptors(dest, src, redefine);
    }, args[0]);
  }

  // 7.3.20 SpeciesConstructor(O, defaultConstructor)


  var SPECIES$2 = _wks('species');
  var _speciesConstructor = function (O, D) {
    var C = _anObject(O).constructor;
    var S;
    return C === undefined || (S = _anObject(C)[SPECIES$2]) == undefined ? D : _aFunction(S);
  };

  var process = _global.process;
  var setTask = _global.setImmediate;
  var clearTask = _global.clearImmediate;
  var MessageChannel = _global.MessageChannel;
  var Dispatch = _global.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var defer, channel, port;
  var run = function () {
    var id = +this;
    // eslint-disable-next-line no-prototype-builtins
    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };
  var listener = function (event) {
    run.call(event.data);
  };
  // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
  if (!setTask || !clearTask) {
    setTask = function setImmediate(fn) {
      var args = [];
      var i = 1;
      while (arguments.length > i) args.push(arguments[i++]);
      queue[++counter] = function () {
        // eslint-disable-next-line no-new-func
        _invoke(typeof fn == 'function' ? fn : Function(fn), args);
      };
      defer(counter);
      return counter;
    };
    clearTask = function clearImmediate(id) {
      delete queue[id];
    };
    // Node.js 0.8-
    if (_cof(process) == 'process') {
      defer = function (id) {
        process.nextTick(_ctx(run, id, 1));
      };
    // Sphere (JS game engine) Dispatch API
    } else if (Dispatch && Dispatch.now) {
      defer = function (id) {
        Dispatch.now(_ctx(run, id, 1));
      };
    // Browsers with MessageChannel, includes WebWorkers
    } else if (MessageChannel) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = _ctx(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
      defer = function (id) {
        _global.postMessage(id + '', '*');
      };
      _global.addEventListener('message', listener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in _domCreate('script')) {
      defer = function (id) {
        _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
          _html.removeChild(this);
          run.call(id);
        };
      };
    // Rest old browsers
    } else {
      defer = function (id) {
        setTimeout(_ctx(run, id, 1), 0);
      };
    }
  }
  var _task = {
    set: setTask,
    clear: clearTask
  };

  var macrotask = _task.set;
  var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
  var process$1 = _global.process;
  var Promise$1 = _global.Promise;
  var isNode = _cof(process$1) == 'process';

  var _microtask = function () {
    var head, last, notify;

    var flush = function () {
      var parent, fn;
      if (isNode && (parent = process$1.domain)) parent.exit();
      while (head) {
        fn = head.fn;
        head = head.next;
        try {
          fn();
        } catch (e) {
          if (head) notify();
          else last = undefined;
          throw e;
        }
      } last = undefined;
      if (parent) parent.enter();
    };

    // Node.js
    if (isNode) {
      notify = function () {
        process$1.nextTick(flush);
      };
    // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
    } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
      var toggle = true;
      var node = document.createTextNode('');
      new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
      notify = function () {
        node.data = toggle = !toggle;
      };
    // environments with maybe non-completely correct, but existent Promise
    } else if (Promise$1 && Promise$1.resolve) {
      // Promise.resolve without an argument throws an error in LG WebOS 2
      var promise = Promise$1.resolve(undefined);
      notify = function () {
        promise.then(flush);
      };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
    } else {
      notify = function () {
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(_global, flush);
      };
    }

    return function (fn) {
      var task = { fn: fn, next: undefined };
      if (last) last.next = task;
      if (!head) {
        head = task;
        notify();
      } last = task;
    };
  };

  // 25.4.1.5 NewPromiseCapability(C)


  function PromiseCapability(C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = _aFunction(resolve);
    this.reject = _aFunction(reject);
  }

  var f$7 = function (C) {
    return new PromiseCapability(C);
  };

  var _newPromiseCapability = {
  	f: f$7
  };

  var _perform = function (exec) {
    try {
      return { e: false, v: exec() };
    } catch (e) {
      return { e: true, v: e };
    }
  };

  var navigator = _global.navigator;

  var _userAgent = navigator && navigator.userAgent || '';

  var _promiseResolve = function (C, x) {
    _anObject(C);
    if (_isObject(x) && x.constructor === C) return x;
    var promiseCapability = _newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var task = _task.set;
  var microtask = _microtask();




  var PROMISE = 'Promise';
  var TypeError$1 = _global.TypeError;
  var process$2 = _global.process;
  var versions = process$2 && process$2.versions;
  var v8 = versions && versions.v8 || '';
  var $Promise = _global[PROMISE];
  var isNode$1 = _classof(process$2) == 'process';
  var empty$1 = function () { /* empty */ };
  var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
  var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;

  var USE_NATIVE$1 = !!function () {
    try {
      // correct subclassing with @@species support
      var promise = $Promise.resolve(1);
      var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
        exec(empty$1, empty$1);
      };
      // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
      return (isNode$1 || typeof PromiseRejectionEvent == 'function')
        && promise.then(empty$1) instanceof FakePromise
        // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
        // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
        // we can't detect it synchronously, so just check versions
        && v8.indexOf('6.6') !== 0
        && _userAgent.indexOf('Chrome/66') === -1;
    } catch (e) { /* empty */ }
  }();

  // helpers
  var isThenable = function (it) {
    var then;
    return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };
  var notify = function (promise, isReject) {
    if (promise._n) return;
    promise._n = true;
    var chain = promise._c;
    microtask(function () {
      var value = promise._v;
      var ok = promise._s == 1;
      var i = 0;
      var run = function (reaction) {
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (promise._h == 2) onHandleUnhandled(promise);
              promise._h = 1;
            }
            if (handler === true) result = value;
            else {
              if (domain) domain.enter();
              result = handler(value); // may throw
              if (domain) {
                domain.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject(TypeError$1('Promise-chain cycle'));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (e) {
          if (domain && !exited) domain.exit();
          reject(e);
        }
      };
      while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
      promise._c = [];
      promise._n = false;
      if (isReject && !promise._h) onUnhandled(promise);
    });
  };
  var onUnhandled = function (promise) {
    task.call(_global, function () {
      var value = promise._v;
      var unhandled = isUnhandled(promise);
      var result, handler, console;
      if (unhandled) {
        result = _perform(function () {
          if (isNode$1) {
            process$2.emit('unhandledRejection', value, promise);
          } else if (handler = _global.onunhandledrejection) {
            handler({ promise: promise, reason: value });
          } else if ((console = _global.console) && console.error) {
            console.error('Unhandled promise rejection', value);
          }
        });
        // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
        promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
      } promise._a = undefined;
      if (unhandled && result.e) throw result.v;
    });
  };
  var isUnhandled = function (promise) {
    return promise._h !== 1 && (promise._a || promise._c).length === 0;
  };
  var onHandleUnhandled = function (promise) {
    task.call(_global, function () {
      var handler;
      if (isNode$1) {
        process$2.emit('rejectionHandled', promise);
      } else if (handler = _global.onrejectionhandled) {
        handler({ promise: promise, reason: promise._v });
      }
    });
  };
  var $reject = function (value) {
    var promise = this;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise; // unwrap
    promise._v = value;
    promise._s = 2;
    if (!promise._a) promise._a = promise._c.slice();
    notify(promise, true);
  };
  var $resolve = function (value) {
    var promise = this;
    var then;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise; // unwrap
    try {
      if (promise === value) throw TypeError$1("Promise can't be resolved itself");
      if (then = isThenable(value)) {
        microtask(function () {
          var wrapper = { _w: promise, _d: false }; // wrap
          try {
            then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
          } catch (e) {
            $reject.call(wrapper, e);
          }
        });
      } else {
        promise._v = value;
        promise._s = 1;
        notify(promise, false);
      }
    } catch (e) {
      $reject.call({ _w: promise, _d: false }, e); // wrap
    }
  };

  // constructor polyfill
  if (!USE_NATIVE$1) {
    // 25.4.3.1 Promise(executor)
    $Promise = function Promise(executor) {
      _anInstance(this, $Promise, PROMISE, '_h');
      _aFunction(executor);
      Internal.call(this);
      try {
        executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
      } catch (err) {
        $reject.call(this, err);
      }
    };
    // eslint-disable-next-line no-unused-vars
    Internal = function Promise(executor) {
      this._c = [];             // <- awaiting reactions
      this._a = undefined;      // <- checked in isUnhandled reactions
      this._s = 0;              // <- state
      this._d = false;          // <- done
      this._v = undefined;      // <- value
      this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
      this._n = false;          // <- notify
    };
    Internal.prototype = _redefineAll($Promise.prototype, {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function then(onFulfilled, onRejected) {
        var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail = typeof onRejected == 'function' && onRejected;
        reaction.domain = isNode$1 ? process$2.domain : undefined;
        this._c.push(reaction);
        if (this._a) this._a.push(reaction);
        if (this._s) notify(this, false);
        return reaction.promise;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function (onRejected) {
        return this.then(undefined, onRejected);
      }
    });
    OwnPromiseCapability = function () {
      var promise = new Internal();
      this.promise = promise;
      this.resolve = _ctx($resolve, promise, 1);
      this.reject = _ctx($reject, promise, 1);
    };
    _newPromiseCapability.f = newPromiseCapability = function (C) {
      return C === $Promise || C === Wrapper
        ? new OwnPromiseCapability(C)
        : newGenericPromiseCapability(C);
    };
  }

  _export(_export.G + _export.W + _export.F * !USE_NATIVE$1, { Promise: $Promise });
  _setToStringTag($Promise, PROMISE);
  _setSpecies(PROMISE);
  Wrapper = _core[PROMISE];

  // statics
  _export(_export.S + _export.F * !USE_NATIVE$1, PROMISE, {
    // 25.4.4.5 Promise.reject(r)
    reject: function reject(r) {
      var capability = newPromiseCapability(this);
      var $$reject = capability.reject;
      $$reject(r);
      return capability.promise;
    }
  });
  _export(_export.S + _export.F * (_library || !USE_NATIVE$1), PROMISE, {
    // 25.4.4.6 Promise.resolve(x)
    resolve: function resolve(x) {
      return _promiseResolve(_library && this === Wrapper ? $Promise : this, x);
    }
  });
  _export(_export.S + _export.F * !(USE_NATIVE$1 && _iterDetect(function (iter) {
    $Promise.all(iter)['catch'](empty$1);
  })), PROMISE, {
    // 25.4.4.1 Promise.all(iterable)
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = _perform(function () {
        var values = [];
        var index = 0;
        var remaining = 1;
        _forOf(iterable, false, function (promise) {
          var $index = index++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          C.resolve(promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[$index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.e) reject(result.v);
      return capability.promise;
    },
    // 25.4.4.4 Promise.race(iterable)
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var reject = capability.reject;
      var result = _perform(function () {
        _forOf(iterable, false, function (promise) {
          C.resolve(promise).then(capability.resolve, reject);
        });
      });
      if (result.e) reject(result.v);
      return capability.promise;
    }
  });

  _export(_export.P + _export.R, 'Promise', { 'finally': function (onFinally) {
    var C = _speciesConstructor(this, _core.Promise || _global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(
      isFunction ? function (x) {
        return _promiseResolve(C, onFinally()).then(function () { return x; });
      } : onFinally,
      isFunction ? function (e) {
        return _promiseResolve(C, onFinally()).then(function () { throw e; });
      } : onFinally
    );
  } });

  // https://github.com/tc39/proposal-promise-try




  _export(_export.S, 'Promise', { 'try': function (callbackfn) {
    var promiseCapability = _newPromiseCapability.f(this);
    var result = _perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  } });

  var promise = _core.Promise;

  var promise$1 = promise;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      promise$1.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new promise$1(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  /** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
  function isNumeric$1(val) {
      return !isArray$3(val) && (val - parseFloat(val) + 1) >= 0;
  }

  /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
  function interval(period, scheduler) {
      if (period === void 0) {
          period = 0;
      }
      if (scheduler === void 0) {
          scheduler = async;
      }
      if (!isNumeric$1(period) || period < 0) {
          period = 0;
      }
      if (!scheduler || typeof scheduler.schedule !== 'function') {
          scheduler = async;
      }
      return new Observable(function (subscriber) {
          subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
          return subscriber;
      });
  }
  function dispatch(state) {
      var subscriber = state.subscriber, counter = state.counter, period = state.period;
      subscriber.next(counter);
      this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function EmptyErrorImpl() {
      Error.call(this);
      this.message = 'no elements in sequence';
      this.name = 'EmptyError';
      return this;
  }
  EmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
  var EmptyError = EmptyErrorImpl;

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  function filter$1(predicate, thisArg) {
      return function filterOperatorFunction(source) {
          return source.lift(new FilterOperator(predicate, thisArg));
      };
  }
  var FilterOperator = /*@__PURE__*/ (function () {
      function FilterOperator(predicate, thisArg) {
          this.predicate = predicate;
          this.thisArg = thisArg;
      }
      FilterOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
      };
      return FilterOperator;
  }());
  var FilterSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(FilterSubscriber, _super);
      function FilterSubscriber(destination, predicate, thisArg) {
          var _this = _super.call(this, destination) || this;
          _this.predicate = predicate;
          _this.thisArg = thisArg;
          _this.count = 0;
          return _this;
      }
      FilterSubscriber.prototype._next = function (value) {
          var result;
          try {
              result = this.predicate.call(this.thisArg, value, this.count++);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          if (result) {
              this.destination.next(value);
          }
      };
      return FilterSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function ArgumentOutOfRangeErrorImpl() {
      Error.call(this);
      this.message = 'argument out of range';
      this.name = 'ArgumentOutOfRangeError';
      return this;
  }
  ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
  var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

  /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
  var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });
  function empty$2(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : EMPTY;
  }
  function emptyScheduled(scheduler) {
      return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
  }

  /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
  function take(count) {
      return function (source) {
          if (count === 0) {
              return empty$2();
          }
          else {
              return source.lift(new TakeOperator(count));
          }
      };
  }
  var TakeOperator = /*@__PURE__*/ (function () {
      function TakeOperator(total) {
          this.total = total;
          if (this.total < 0) {
              throw new ArgumentOutOfRangeError;
          }
      }
      TakeOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new TakeSubscriber(subscriber, this.total));
      };
      return TakeOperator;
  }());
  var TakeSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(TakeSubscriber, _super);
      function TakeSubscriber(destination, total) {
          var _this = _super.call(this, destination) || this;
          _this.total = total;
          _this.count = 0;
          return _this;
      }
      TakeSubscriber.prototype._next = function (value) {
          var total = this.total;
          var count = ++this.count;
          if (count <= total) {
              this.destination.next(value);
              if (count === total) {
                  this.destination.complete();
                  this.unsubscribe();
              }
          }
      };
      return TakeSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  function defaultIfEmpty(defaultValue) {
      if (defaultValue === void 0) {
          defaultValue = null;
      }
      return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
  }
  var DefaultIfEmptyOperator = /*@__PURE__*/ (function () {
      function DefaultIfEmptyOperator(defaultValue) {
          this.defaultValue = defaultValue;
      }
      DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
      };
      return DefaultIfEmptyOperator;
  }());
  var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
      __extends(DefaultIfEmptySubscriber, _super);
      function DefaultIfEmptySubscriber(destination, defaultValue) {
          var _this = _super.call(this, destination) || this;
          _this.defaultValue = defaultValue;
          _this.isEmpty = true;
          return _this;
      }
      DefaultIfEmptySubscriber.prototype._next = function (value) {
          this.isEmpty = false;
          this.destination.next(value);
      };
      DefaultIfEmptySubscriber.prototype._complete = function () {
          if (this.isEmpty) {
              this.destination.next(this.defaultValue);
          }
          this.destination.complete();
      };
      return DefaultIfEmptySubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
  function tap(nextOrObserver, error, complete) {
      return function tapOperatorFunction(source) {
          return source.lift(new DoOperator(nextOrObserver, error, complete));
      };
  }
  var DoOperator = /*@__PURE__*/ (function () {
      function DoOperator(nextOrObserver, error, complete) {
          this.nextOrObserver = nextOrObserver;
          this.error = error;
          this.complete = complete;
      }
      DoOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
      };
      return DoOperator;
  }());
  var TapSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(TapSubscriber, _super);
      function TapSubscriber(destination, observerOrNext, error, complete) {
          var _this = _super.call(this, destination) || this;
          _this._tapNext = noop$1;
          _this._tapError = noop$1;
          _this._tapComplete = noop$1;
          _this._tapError = error || noop$1;
          _this._tapComplete = complete || noop$1;
          if (isFunction$1(observerOrNext)) {
              _this._context = _this;
              _this._tapNext = observerOrNext;
          }
          else if (observerOrNext) {
              _this._context = observerOrNext;
              _this._tapNext = observerOrNext.next || noop$1;
              _this._tapError = observerOrNext.error || noop$1;
              _this._tapComplete = observerOrNext.complete || noop$1;
          }
          return _this;
      }
      TapSubscriber.prototype._next = function (value) {
          try {
              this._tapNext.call(this._context, value);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          this.destination.next(value);
      };
      TapSubscriber.prototype._error = function (err) {
          try {
              this._tapError.call(this._context, err);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          this.destination.error(err);
      };
      TapSubscriber.prototype._complete = function () {
          try {
              this._tapComplete.call(this._context);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          return this.destination.complete();
      };
      return TapSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START _tap,_util_EmptyError PURE_IMPORTS_END */
  var throwIfEmpty = function (errorFactory) {
      if (errorFactory === void 0) {
          errorFactory = defaultErrorFactory;
      }
      return tap({
          hasValue: false,
          next: function () { this.hasValue = true; },
          complete: function () {
              if (!this.hasValue) {
                  throw errorFactory();
              }
          }
      });
  };
  function defaultErrorFactory() {
      return new EmptyError();
  }

  /** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */
  function first(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function (source) { return source.pipe(predicate ? filter$1(function (v, i) { return predicate(v, i, source); }) : identity$1, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); })); };
  }

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  function skipWhile(predicate) {
      return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
  }
  var SkipWhileOperator = /*@__PURE__*/ (function () {
      function SkipWhileOperator(predicate) {
          this.predicate = predicate;
      }
      SkipWhileOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
      };
      return SkipWhileOperator;
  }());
  var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(SkipWhileSubscriber, _super);
      function SkipWhileSubscriber(destination, predicate) {
          var _this = _super.call(this, destination) || this;
          _this.predicate = predicate;
          _this.skipping = true;
          _this.index = 0;
          return _this;
      }
      SkipWhileSubscriber.prototype._next = function (value) {
          var destination = this.destination;
          if (this.skipping) {
              this.tryCallPredicate(value);
          }
          if (!this.skipping) {
              destination.next(value);
          }
      };
      SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
          try {
              var result = this.predicate(value, this.index++);
              this.skipping = Boolean(result);
          }
          catch (err) {
              this.destination.error(err);
          }
      };
      return SkipWhileSubscriber;
  }(Subscriber));

  var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  /* global setTimeout, clearTimeout */

  var dist = function debounce(fn) {
    var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var lastCallAt = void 0;
    var deferred = void 0;
    var timer = void 0;
    var pendingArgs = [];
    return function debounced() {
      var currentWait = getWait(wait);
      var currentTime = new Date().getTime();

      var isCold = !lastCallAt || currentTime - lastCallAt > currentWait;

      lastCallAt = currentTime;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (isCold && options.leading) {
        return options.accumulate ? Promise.resolve(fn.call(this, [args])).then(function (result) {
          return result[0];
        }) : Promise.resolve(fn.call.apply(fn, [this].concat(args)));
      }

      if (deferred) {
        clearTimeout(timer);
      } else {
        deferred = defer$1();
      }

      pendingArgs.push(args);
      timer = setTimeout(flush.bind(this), currentWait);

      if (options.accumulate) {
        var _ret = function () {
          var argsIndex = pendingArgs.length - 1;
          return {
            v: deferred.promise.then(function (results) {
              return results[argsIndex];
            })
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof$1(_ret)) === "object") return _ret.v;
      }

      return deferred.promise;
    };

    function flush() {
      var thisDeferred = deferred;
      clearTimeout(timer);

      Promise.resolve(options.accumulate ? fn.call(this, pendingArgs) : fn.apply(this, pendingArgs[pendingArgs.length - 1])).then(thisDeferred.resolve, thisDeferred.reject);

      pendingArgs = [];
      deferred = null;
    }
  };

  function getWait(wait) {
    return typeof wait === 'function' ? wait() : wait;
  }

  function defer$1() {
    var deferred = {};
    deferred.promise = new Promise(function (resolve, reject) {
      deferred.resolve = resolve;
      deferred.reject = reject;
    });
    return deferred;
  }

  /**
   * Simple Identity map with refs count
   */
  var IdentityMap =
  /*#__PURE__*/
  function () {
    function IdentityMap() {
      _classCallCheck(this, IdentityMap);

      _defineProperty(this, "pools", create$1(null));
    }

    _createClass(IdentityMap, [{
      key: "_preparePool",

      /**
       * @param {string} pool
       * @private
       */
      value: function _preparePool(pool) {
        this.pools[pool] || (this.pools[pool] = create$1(null));
      }
      /**
       * @param {string} id
       * @param {mixed} value
       * @param {string} pool
       */

    }, {
      key: "set",
      value: function set(id, value) {
        var pool = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
        if (value == null) return;

        this._preparePool(pool);

        this.pools[pool][id] = {
          value: value,
          refs: 1
        };
      }
      /**
       * @param {string} id
       * @param {string} pool
       */

    }, {
      key: "get",
      value: function get(id) {
        var pool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

        this._preparePool(pool);

        var rec = this.pools[pool][id];
        if (!rec || rec.value == null) return;
        rec.refs++;
        this.pools[pool][id] = rec;
        return rec.value;
      }
      /**
       * @param {string} id
       * @param {string} pool
       */

    }, {
      key: "unset",
      value: function unset(id) {
        var pool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

        this._preparePool(pool);

        var rec = this.pools[pool][id];
        if (!rec || rec.value == null) return;
        rec.refs--;

        if (rec.refs === 0) {
          delete this.pools[pool][id];
        } else {
          this.pools[pool][id] = rec;
        }
      }
      /**
       * @param {string} id
       * @param {string} pool
       * @return {boolean}
       */

    }, {
      key: "has",
      value: function has(id) {
        var pool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

        this._preparePool(pool);

        return !!this.pools[pool][id];
      }
      /**
       * @param {string} pool
       * @return {string[]}
       */

    }, {
      key: "ids",
      value: function ids() {
        var pool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';

        this._preparePool(pool);

        return keys$1(this.pools[pool]);
      }
      /**
       * @param {string} id
       * @param {string} pool
       * @return {*}
       */

    }, {
      key: "refs",
      value: function refs(id) {
        var pool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

        this._preparePool(pool);

        return this.has(id, pool) ? this.pools[pool][id].refs : undefined;
      }
    }]);

    return IdentityMap;
  }();

  // const IDENTITY_MAP_PROP = Symbol('identityMap')

  var IDENTITY_MAP_PROP = 'identityMap';
  /**
   * @alias module:mixin/ident-map
   * @title identMap
   * @vueProto
   */

  var identMap = {
    IDENTITY_MAP_PROP: IDENTITY_MAP_PROP,
    props: {
      /**
       * Unique key for saving to identity map
       * @type {string|number}
       * @experimental
       */
      ident: [String, Number]
    },
    methods: {
      /**
       * @param parts
       * @return {string|undefined}
       * @protected
       */
      makeSelfIdent: function makeSelfIdent() {
        if (!this.ident) return;

        for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
          parts[_key] = arguments[_key];
        }

        return this.makeIdent.apply(this, [this.ident].concat(parts));
      },

      /**
       * @param parts
       * @return {string}
       */
      makeIdent: function makeIdent() {
        for (var _len2 = arguments.length, parts = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          parts[_key2] = arguments[_key2];
        }

        return parts.filter(identity).join('.');
      }
    },
    created: function created() {
      initIdentityMap.call(this);
    }
  };
  /**
   * @private
   */

  function initIdentityMap() {
    var _this = this;

    if (!this[IDENTITY_MAP_PROP]) {
      Vue[IDENTITY_MAP_PROP] = Vue.prototype[IDENTITY_MAP_PROP] = new IdentityMap();
    }

    defineProperties$1(this, {
      $identityMap: {
        enumerable: true,
        get: function get$$1() {
          return _this[IDENTITY_MAP_PROP];
        }
      }
    });
  }

  var noop$2 = function noop() {};
  /**
   * RxJS subscriptions manager.
   */


  var rxSubs = {
    methods: {
      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {},

      /**
       * @return {void}
       * @protected
       */
      unsubscribeAll: function unsubscribeAll() {
        this._rxSubs.forEach(function (x) {
          return x.unsubscribe();
        });

        this._rxSubs = [];
      },

      /**
       * @param {Observable<T>} observable
       * @param {function} [next] Next handler or Observer object.
       * @param {function} [error] Error handler.
       * @param {function} [complete] Complete handler.
       * @return {Subscription}
       * @protected
       */
      subscribeTo: function subscribeTo(observable) {
        var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$2;

        var _error = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop$2;

        var complete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop$2;

        _error = function error$$1(err) {

          _error(err);
        };

        var subs = observable.subscribe(next, _error, complete);

        this._rxSubs.push(subs);

        return subs;
      }
    },
    beforeCreate: function beforeCreate() {
      /**
       * @type {Subscription[]}
       * @private
       */
      this._rxSubs = [];
    },
    destroyed: function destroyed() {
      this.unsubscribeAll();
    }
  };

  // const SERVICES_PROP = Symbol('services')

  var SERVICES_PROP = 'services';
  /**
   * Service container mixin
   */

  var services = {
    inject: {
      $services: SERVICES_PROP // todo works only in Vue 2.5.x
      // $services: {from: SERVICES_PROP, default: Object.create(null)},

    },
    provide: function provide() {
      return _defineProperty({}, SERVICES_PROP, this.getServices());
    },
    methods: {
      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return multiMergeDescriptors({}, this.$services || {});
      }
    },
    beforeCreate: function beforeCreate() {
      var source = this.$parent;

      while (source) {
        if (source._provided != null && source._provided[SERVICES_PROP] != null) {
          break;
        }

        source = source.$parent;
      }

      if (source == null || source._provided[SERVICES_PROP] == null) {
        delete this.$options.inject.$services;
      }
    }
  };

  var VM_PROP = 'vm';
  var INSTANCE_PROMISE_POOL = 'instance_promise';
  /**
   * @vueProps
   */

  var props$1 = {};
  /**
   * @vueMethods
   */

  var methods$2 = {
    /**
     * @return {Promise<void>}
     * @protected
     */
    beforeInit: function beforeInit() {},

    /**
     * @return {Promise} Resolves when initialization completes
     * @protected
     */
    init: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      regenerator.mark(function _callee() {
        var createPromise, ident;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                ident = this.makeSelfIdent();

                if (ident && this.$identityMap.has(ident, INSTANCE_PROMISE_POOL)) {
                  createPromise = this.$identityMap.get(ident, INSTANCE_PROMISE_POOL);
                } else {
                  createPromise = promise$1.resolve(this.createOlObject());

                  if (ident) {
                    this.$identityMap.set(ident, createPromise, INSTANCE_PROMISE_POOL);
                  }
                }

                _context.next = 4;
                return createPromise;

              case 4:
                this._olObject = _context.sent;
                this._olObject[VM_PROP] || (this._olObject[VM_PROP] = []);

                if (!this._olObject[VM_PROP].includes(this)) {
                  // for loaded from IdentityMap
                  this._olObject[VM_PROP].push(this);
                }

                ++this.rev;

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function init() {
        return _init.apply(this, arguments);
      };
    }(),

    /**
     * @return {*|Promise<T>}
     * @protected
     * @abstract
     */
    createOlObject: function createOlObject() {
      throw new Error('Not implemented method');
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      var _this = this;

      var ident = this.makeSelfIdent();

      if (ident) {
        this.$identityMap.unset(ident, INSTANCE_PROMISE_POOL);
      }

      if (this._olObject) {
        this._olObject[VM_PROP] = this._olObject[VM_PROP].filter(function (vm) {
          return vm !== _this;
        });
        this._olObject = undefined;
      }
    },

    /**
     * Redefine for easy call in child components
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      return services.methods.getServices.call(this);
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     * @abstract
     */
    mount: function mount() {
      throw new Error('Not implemented method');
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     * @abstract
     */
    unmount: function unmount() {
      throw new Error('Not implemented method');
    },

    /**
     * Refresh internal ol objects
     * @return {Promise<void>}
     */
    refresh: function refresh() {
      var _this2 = this;

      if (this.$olObject == null) return promise$1.resolve();
      return new promise$1(function (resolve) {
        var done = function done() {
          ++_this2.rev;
          resolve();
        };

        if (_this2.$olObject && isFunction(_this2.$olObject.changed)) {
          _this2.$olObject.once('change', done);

          _this2.$olObject.changed();
        } else {
          done();
        }
      });
    },

    /**
     * Internal usage only in components that doesn't support refreshing.
     * @return {Promise<void>}
     * @protected
     */
    remount: function remount() {
      var _this3 = this;

      if (this.$olObject == null) return promise$1.resolve();
      return promise$1.resolve(this.unmount()).then(function () {
        return _this3.mount();
      });
    },

    /**
     * Only for internal purpose to support watching for properties
     * for which OpenLayers doesn't provide setters.
     * @return {Promise}
     * @protected
     */
    recreate: function recreate() {
      var _this4 = this;

      if (this.$olObject == null) return promise$1.resolve();
      return promise$1.resolve(this.unmount()).then(function () {
        return _this4.deinit();
      }).then(function () {
        return _this4.init();
      }).then(function () {
        return _this4.mount();
      });
    }
  };
  /**
   * Basic ol component mixin.
   *
   * @title olCmp
   * @vueProto
   * @alias module:mixin/ol-cmp
   *
   * @fires module:mixin/ol-cmp#created
   * @fires module:mixin/ol-cmp#mounted
   * @fires module:mixin/ol-cmp#destroyed
   */

  var cmp = {
    VM_PROP: VM_PROP,
    INSTANCE_PROMISE_POOL: INSTANCE_PROMISE_POOL,
    mixins: [identMap, rxSubs, services],
    props: props$1,
    methods: methods$2,

    /**
     * @this module:mixin/ol-cmp
     */
    data: function data() {
      return (
        /** @lends module:mixin/ol-cmp# */
        {
          rev: 0
        }
      );
    },
    created: function created() {
      var _this5 = this;

      /**
       * @type {*}
       * @private
       */
      this._olObject = undefined;
      /**
       * @type {Promise<Vue<T>>}
       * @private
       */

      this._createPromise = promise$1.resolve(this.beforeInit()).then(this.init).then(function () {
        // logdbg('created', this.$options.name)
        _this5.$emit('created', _this5);

        return _this5;
      });
      /**
       * @type {Promise<Vue<T>>}
       * @private
       */

      this._mountPromise = interval(100).pipe(skipWhile(function () {
        return !_this5._mounted;
      }), first(), map$3(function () {
        return _this5;
      })).toPromise(promise$1);

      defineProperties$1(this, {
        $olObject: {
          enumerable: true,
          get: function get$$1() {
            return _this5._olObject;
          }
        },
        $createPromise: {
          enumerable: true,
          get: function get$$1() {
            return _this5._createPromise;
          }
        },
        $mountPromise: {
          enumerable: true,
          get: function get$$1() {
            return _this5._mountPromise;
          }
        }
      }); // bind debounced functions at runtime
      // for each instance to avoid interfering between
      // different instances


      this.scheduleRefresh = dist(function () {
        return this.refresh();
      }, 10);
      this.scheduleRemount = dist(function () {
        return this.remount();
      }, 10);
      this.scheduleRecreate = dist(function () {
        return this.recreate();
      }, 10);
    },
    mounted: function mounted() {
      var _this6 = this;

      this.$createPromise.then(this.mount).then(function () {
        _this6._mounted = true;

        _this6.$emit('mounted', _this6); // logdbg('mounted', this.$options.name)

      });
    },
    destroyed: function destroyed() {
      var _this7 = this;

      this.$mountPromise.then(this.unmount).then(this.deinit).then(function () {
        _this7.$emit('destroyed', _this7); // logdbg('destroyed', this.$options.name)

      });
    }
  };
  /**
   * Emitted when underlying **OpenLayers** instance created.
   * @event module:mixin/ol-cmp#created
   * @type {void}
   */

  /**
   * Emitted when underlying **OpenLayers** instance mounted to parent.
   * @event module:mixin/ol-cmp#mounted
   * @type {void}
   */

  /**
   * Emitted when underlying **OpenLayers** instance destroyed.
   * @event module:mixin/ol-cmp#destroyed
   * @type {void}
   */

  /**
   * Constructs watch hash for multiple properties.
   * @param {string[]} props
   * @param {function|Object} watcherFactory
   */
  function makeWatchers(props, watcherFactory) {
    return props.reduce(function (hash, prop) {
      hash[prop] = watcherFactory(prop);
      return hash;
    }, {});
  }
  function extractChildren(slots) {
    var slotNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return keys$1(slots).reduce(function (all, name) {
      if (!slotNames.length || slotNames.includes(name)) {
        all = all.concat(slots[name]);
      }

      return all;
    }, []);
  }

  /**
   * Renders stub VNode for component.
   */

  var stubVNode = {
    /**
     * @param {function} h
     * @returns {VNode}
     */
    render: function render(h) {
      var options = this.$options.stubVNode || {}; // render as HTML comment

      if (options.empty) {
        var vnode = h();

        if (typeof options.empty === 'string') {
          vnode.text = options.empty;
        } else if (typeof options.empty === 'function') {
          vnode.text = options.empty.call(this);
        }

        return vnode;
      }

      var children;

      if (options.slots === false) {
        children = undefined;
      } else {
        children = extractChildren(this.$slots, options.slots);
      }

      var attrs = typeof options.attrs === 'function' ? options.attrs.call(this) : options.attrs;
      var data = {
        attrs: attrs,
        style: {
          display: 'none !important'
        }
      };
      return h(options.tag || 'i', data, children);
    }
  };

  /**
   * Basic ol component with stub VNode, i.e. virtual component
   */

  var cmp$1 = {
    mixins: [stubVNode, cmp],
    methods: {
      /**
       * @return {Promise}
       * @protected
       */
      init: function init() {
        return cmp.methods.init.call(this);
      },

      /**
       * @return {void|Promise<void>}
       * @protected
       */
      deinit: function deinit() {
        return cmp.methods.deinit.call(this);
      },

      /**
       * @return {*}
       * @protected
       * @abstract
       */
      createOlObject: function createOlObject() {
        throw new Error('Not implemented method');
      },

      /**
       * Redefine for easy call in child components
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return cmp.methods.getServices.call(this);
      },

      /**
       * Refresh internal ol objects
       * @return {Promise}
       */
      refresh: function refresh() {
        return cmp.methods.refresh.call(this);
      }
    }
  };

  /**
   * Basic mixin for ol components that depends on map instance
   */

  var useMapCmp = {
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeInit: function beforeInit() {
        var _this = this;

        return interval(100).pipe(skipWhile(function () {
          return !_this.$map;
        }), first(), map$3(function () {
          return _this;
        })).toPromise(promise$1);
      }
    }
  };

  var props$2 = {
    /**
     * Coordinates in the map view projection.
     * @type {number[]|Coordinate}
     */
    coordinates: {
      type: Array,
      required: true,
      validator: function validator(val) {
        return val.length;
      }
    }
  };
  var computed$1 = {
    /**
     * @type {string}
     * @abstract
     * @readonly
     */
    type: function type() {
      throw new Error('Not implemented computed property');
    },

    /**
     * @type {number[]|Extent|undefined}
     */
    extent: function extent$$1() {
      if (this.extentViewProj && this.resolvedDataProjection) {
        return this.extentToDataProj(this.extentViewProj);
      }
    },

    /**
     * @type {number[]|Extent|undefined}
     */
    extentViewProj: function extentViewProj() {
      if (this.rev && this.$geometry) {
        return this.$geometry.getExtent();
      }
    },

    /**
     * @type {number[]|Coordinate|undefined}
     */
    point: function point() {
      if (this.pointViewProj && this.resolvedDataProjection) {
        return this.pointToDataProj(this.pointViewProj);
      }
    },

    /**
     * @type {Array<number>}
     */
    pointViewProj: function pointViewProj() {
      if (this.rev && this.$geometry) {
        return findPointOnSurface(this.$geometry);
      }
    },

    /**
     * @type {Array|undefined}
     */
    coordinatesViewProj: function coordinatesViewProj() {
      if (this.rev && this.$geometry) {
        return this.$geometry.getCoordinates();
      }
    }
  };
  var methods$3 = {
    /**
     * @return {Geometry|Promise<Geometry>}
     * @protected
     */
    createOlObject: function createOlObject() {
      return this.createGeometry();
    },

    /**
     * @return {Geometry|Promise<Geometry>}
     * @protected
     * @abstract
     */
    createGeometry: function createGeometry() {
      throw new Error('Not implemented method');
    },

    /**
     * @return {Coordinate}
     */
    getCoordinates: function getCoordinates() {
      hasGeometry(this);
      return this.toDataProj(this.$geometry.getCoordinates());
    },

    /**
     * @param {Coordinate} coordinates
     */
    setCoordinates: function setCoordinates(coordinates) {
      hasGeometry(this);
      this.$geometry.setCoordinates(this.toViewProj(coordinates));
    },

    /**
     * @return {Promise}
     * @throws {AssertionError}
     * @protected
     */
    init: function init() {
      this.setupTransformFunctions();
      return cmp$1.methods.init.call(this);
    },

    /**
     * @protected
     */
    setupTransformFunctions: function setupTransformFunctions() {
      var _this = this;

      // define helper methods based on geometry type
      var transform = transforms[this.type].transform;
      /**
       * @method
       * @param {Array} coordinates
       * @return {number[]}
       * @protected
       */

      this.toDataProj = function (coordinates) {
        return transform(coordinates, _this.viewProjection, _this.resolvedDataProjection);
      };
      /**
       * @method
       * @param {Array} coordinates
       * @return {number[]}
       * @protected
       */


      this.toViewProj = function (coordinates) {
        return transform(coordinates, _this.resolvedDataProjection, _this.viewProjection);
      };
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      return cmp$1.methods.deinit.call(this);
    },

    /**
     * @return {Promise}
     */
    refresh: function refresh() {
      return cmp$1.methods.refresh.call(this);
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(cmp$1.methods.getServices.call(this), {
        get geometry() {
          return vm.$geometry;
        }

      });
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      this.$geometryContainer && this.$geometryContainer.setGeometry(this);
      this.subscribeAll();
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.unsubscribeAll();
      this.$geometryContainer && this.$geometryContainer.setGeometry(undefined);
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      subscribeToGeomChanges.call(this);
    }
  };
  var watch$1 = {
    coordinates: function coordinates(value) {
      if (!this.$geometry || !this.$view) return; // compares in data projection

      var isEq = isEqualGeom({
        coordinates: value,
        extent: extent.boundingExtent(value)
      }, {
        coordinates: this.getCoordinates(),
        extent: this.extent
      });

      if (!isEq) {
        this.setCoordinates(value);
      }
    },
    resolvedDataProjection: function resolvedDataProjection() {
      if (this.$geometry) {
        this.setupTransformFunctions();
        this.setCoordinates(this.coordinates);
      }
    }
  };
  var geometry$3 = {
    mixins: [cmp$1, useMapCmp, projTransforms],
    props: props$2,
    computed: computed$1,
    watch: watch$1,
    methods: methods$3,
    stubVNode: {
      empty: function empty() {
        return this.$options.name;
      }
    },
    created: function created() {
      var _this2 = this;

      defineProperties$1(this, {
        /**
         * @type {Geometry|undefined}
         */
        $geometry: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$olObject;
          }
        },
        $map: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.map;
          }
        },
        $view: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.view;
          }
        },
        $geometryContainer: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.geometryContainer;
          }
        }
      });
    }
  };
  /**
   * @return {void}
   * @private
   */

  function subscribeToGeomChanges() {
    var _this3 = this;

    hasGeometry(this);
    var ft = 100;
    var changes = fromOlEvent(this.$geometry, 'change', function () {
      return {
        coordinates: _this3.getCoordinates(),
        extent: _this3.extent
      };
    }).pipe(throttleTime(ft), distinctUntilChanged(isEqualGeom), map$3(function (_ref) {
      var coordinates = _ref.coordinates;
      return {
        prop: 'coordinates',
        value: coordinates
      };
    }));
    this.subscribeTo(changes, function (_ref2) {
      var prop = _ref2.prop,
          value = _ref2.value;
      ++_this3.rev;

      _this3.$emit("update:".concat(prop), value);
    });
  }
  /**
   * @param {{coordinates: number[], extent: number[]}} a
   * @param {{coordinates: number[], extent: number[]}} b
   * @returns {boolean}
   */


  function isEqualGeom(a, b) {
    return isEqual(a.extent, b.extent) ? isEqual(a.coordinates, b.coordinates) : false;
  }

  var methods$4 = {
    /**
     * @return {{
     *     getGeometry: function(): Geometry|undefined,
     *     setGeometry: function(Geometry|undefined)
     *   }|undefined}
     * @protected
     */
    getGeometryTarget: function getGeometryTarget() {
      throw new Error('Not implemented method');
    },

    /**
     * @return {Geometry|undefined}
     */
    getGeometry: function getGeometry() {
      return this._geometry;
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return {
        get geometryContainer() {
          return vm;
        }

      };
    },

    /**
     * @param {Geometry|Vue|Object|undefined} geom
     * @return {void}
     * @throws {AssertionError}
     */
    setGeometry: function setGeometry(geom) {
      if (geom instanceof Vue) {
        geom = geom.$geometry;
      } else if (isPlainObject(geom)) {
        geom = this.readGeometryInDataProj(geom);
      }

      if (geom !== this._geometry) {
        this._geometry = geom;
      }

      var geomTarget = this.getGeometryTarget();

      if (geomTarget && geom !== geomTarget.getGeometry()) {
        geomTarget.setGeometry(geom);
      }
    }
  };
  var geometryContainer = {
    mixins: [projTransforms],
    methods: methods$4,
    created: function created() {
      /**
       * @type {Geometry|undefined}
       * @private
       */
      this._geometry = undefined;

      defineProperties$1(this, {
        $geometry: {
          enumerable: true,
          get: this.getGeometry
        }
      });
    }
  };

  /**
   * Creates Observable from OpenLayers change:* event
   * @param {ol.Object} target
   * @param {string|string[]} [prop]
   * @param {boolean|function(a, b):boolean|undefined} [distinct] Distinct values by isEqual fn or by custom comparator
   * @param {number|undefined} [throttle] Throttle values by passed amount of ms.
   * @param {function(target: ol.Object, prop: string):*|undefined} [selector] Custom selector
   * @return {Observable<{prop: string, value: *}>}
   */

  function fromOlChangeEvent(target, prop, distinct, throttle, selector) {
    if (isArray$1(prop)) {
      return merge.apply(void 0, _toConsumableArray(prop.map(function (p) {
        return fromOlChangeEvent(target, p);
      })));
    }

    selector = selector || function (target, prop) {
      return target.get(prop);
    };

    var event = "change:".concat(prop);
    var observable = fromOlEvent(target, event, function () {
      return selector(target, prop);
    });
    var operations = [];

    if (throttle != null) {
      operations.push(throttleTime(throttle));
    }

    if (distinct) {
      isFunction(distinct) || (distinct = isEqual);
      operations.push(distinctUntilChanged(distinct));
    }

    operations.push(map$3(function (value) {
      return {
        prop: prop,
        value: value
      };
    }));
    return observable.pipe.apply(observable, operations);
  }

  /**
   * @module rx-ext
   */

  var rxExt = /*#__PURE__*/Object.freeze({
    observableFromOlChangeEvent: fromOlChangeEvent,
    observableFromOlEvent: fromOlEvent
  });

  var props$3 = {
    attributions: [String, Array],
    logo: String,
    projection: String,
    wrapX: {
      type: Boolean,
      default: true
    }
  };
  var methods$5 = {
    /**
     * @return {Source|Promise<Source>}
     * @protected
     */
    createOlObject: function createOlObject() {
      return this.createSource();
    },

    /**
     * @return {Source|Promise<Source>}
     * @protected
     * @abstract
     */
    createSource: function createSource() {
      throw new Error('Not implemented method');
    },

    /**
     * @return {Promise}
     * @protected
     */
    init: function init() {
      return cmp$1.methods.init.call(this);
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      return cmp$1.methods.deinit.call(this);
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(cmp$1.methods.getServices.call(this), {
        get source() {
          return vm.$source;
        }

      });
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      this.$sourceContainer && this.$sourceContainer.setSource(this);
      this.subscribeAll();
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.unsubscribeAll();
      this.$sourceContainer && this.$sourceContainer.setSource(undefined);
    },

    /**
     * @return {Promise<void>}
     */
    refresh: function refresh() {
      var _this = this;

      if (this.$source && !isFunction(this.$source.clear)) {
        return cmp$1.methods.refresh.call(this);
      }

      return new promise$1(function (resolve) {
        var done = function done() {
          ++_this.rev;
          resolve();
        };

        if (_this.$source) {
          _this.$source.once('change', done);

          _this.$source.clear();
        } else {
          done();
        }
      });
    }
  };
  var watch$2 = {
    attributions: function attributions(value) {
      this.$source && this.$source.setAttributions(value);
    }
  };
  var source = {
    mixins: [cmp$1, useMapCmp],
    props: props$3,
    methods: methods$5,
    watch: watch$2,
    stubVNode: {
      empty: function empty() {
        return this.$options.name;
      }
    },
    created: function created() {
      var _this2 = this;

      defineProperties$1(this, {
        /**
         * @type {Source|undefined}
         */
        $source: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$olObject;
          }
        },
        $map: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.map;
          }
        },
        $view: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.view;
          }
        },
        $sourceContainer: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.sourceContainer;
          }
        }
      });
    }
  };

  /**
   * @vueProps
   */

  var props$4 = {
    crossOrigin: String,
    projection: {
      type: String,
      default: EPSG_3857
    }
    /**
     * @vueMethods
     */

  };
  var methods$6 = {
    /**
     * @return {Promise}
     * @protected
     */
    init: function init() {
      return source.methods.init.call(this);
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      return source.methods.deinit.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      source.methods.mount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      source.methods.unmount.call(this);
    },
    subscribeAll: function subscribeAll() {
      subscribeToSourceEvents.call(this);
    }
  };
  /**
   * @vueProto
   * @alias module:mixin/image-source
   */

  var imageSource = {
    mixins: [source],
    props: props$4,
    methods: methods$6
  };

  function subscribeToSourceEvents() {
    var _this = this;

    hasSource(this);
    var events = fromOlEvent(this.$source, ['imageloadend', 'imageloaderror', 'imageloadstart']);
    this.subscribeTo(events, function (evt) {
      return _this.$emit(evt.type, evt);
    });
  }

  /**
   * Basic style mixin.
   */

  var methods$7 = {
    /**
     * @return {OlStyle|Promise<OlStyle>}
     * @protected
     */
    createOlObject: function createOlObject() {
      return this.createStyle();
    },

    /**
     * @return {OlStyle|Promise<OlStyle>}
     * @protected
     * @abstract
     */
    createStyle: function createStyle() {
      throw new Error('Not implemented method');
    },

    /**
     * @return {Promise}
     * @protected
     */
    init: function init() {
      return cmp$1.methods.init.call(this);
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      return cmp$1.methods.deinit.call(this);
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(cmp$1.methods.getServices.call(this), {
        get style() {
          return vm.$style;
        }

      });
    },

    /**
     * @return {Promise}
     */
    refresh: function refresh() {
      var _this = this;

      if (this.$olObject == null) return promise$1.resolve();
      return this.remount().then(function () {
        if (!_this.$map) {
          return;
        }

        _this.$map.render();

        return fromOlEvent(_this.$map, 'postcompose').pipe(first()).toPromise();
      });
    }
  };
  var style = {
    mixins: [cmp$1, useMapCmp],
    methods: methods$7,
    stubVNode: {
      empty: function empty() {
        return this.$options.name;
      }
    },
    created: function created() {
      var _this2 = this;

      defineProperties$1(this, {
        $style: {
          enumerable: true,
          get: function get() {
            return _this2.$olObject;
          }
        },
        $map: {
          enumerable: true,
          get: function get() {
            return _this2.$services && _this2.$services.map;
          }
        },
        $view: {
          enumerable: true,
          get: function get() {
            return _this2.$services && _this2.$services.view;
          }
        },
        $stylesContainer: {
          enumerable: true,
          get: function get() {
            return _this2.$services && _this2.$services.stylesContainer;
          }
        }
      });
    }
  };

  var props$5 = {};
  var methods$8 = {
    /**
     * @return {Promise}
     * @protected
     */
    init: function init() {
      return style.methods.init.call(this);
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      return style.methods.deinit.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      this.$stylesContainer && this.$stylesContainer.setImage(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.$stylesContainer && this.$stylesContainer.setImage(undefined);
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices: function getServices() {
      return style.methods.getServices.call(this);
    },

    /**
     * @return {Promise}
     */
    refresh: function refresh() {
      // recreate style
      return this.recreate();
    }
  };
  var watch$3 = {};
  var imageStyle = {
    mixins: [style],
    props: props$5,
    methods: methods$8,
    watch: watch$3,
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          class: this.$options.name
        };
      }
    }
  };

  var props$6 = {
    id: {
      type: [String, Number],
      default: function _default() {
        return v4_1();
      }
    },
    active: {
      type: Boolean,
      default: true
    },

    /**
     * Priority of interactions in the event handling stream.
     * The higher the value, the sooner it will handle map event.
     * @type {number}
     */
    priority: {
      type: Number,
      default: 0
    }
  };
  var methods$9 = {
    /**
     * @return {Promise<Interaction>}
     * @protected
     */
    createOlObject: function () {
      var _createOlObject = _asyncToGenerator(
      /*#__PURE__*/
      regenerator.mark(function _callee() {
        var interaction$$1;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.createInteraction();

              case 2:
                interaction$$1 = _context.sent;
                interaction$$1.setActive(this.active);
                interaction$$1.setProperties({
                  id: this.id,
                  priority: this.priority
                });
                return _context.abrupt("return", interaction$$1);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function createOlObject() {
        return _createOlObject.apply(this, arguments);
      };
    }(),

    /**
     * @return {Interaction|Promise<Interaction>}
     * @protected
     * @abstract
     */
    createInteraction: function createInteraction() {
      throw new Error('Not implemented method');
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(cmp$1.methods.getServices.call(this), {
        get interaction() {
          return vm.$interaction;
        }

      });
    },

    /**
     * @return {Promise} Resolves when initialization completes
     * @protected
     */
    init: function init() {
      return cmp$1.methods.init.call(this);
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      return cmp$1.methods.deinit.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      this.$interactionsContainer && this.$interactionsContainer.addInteraction(this);
      this.subscribeAll();
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.unsubscribeAll();
      this.$interactionsContainer && this.$interactionsContainer.removeInteraction(this);
    },

    /**
     * @return {Promise}
     */
    refresh: function refresh() {
      return cmp$1.methods.refresh.call(this);
    }
  };
  var watch$4 = {
    active: function active(value) {
      if (this.$interaction && value !== this.$interaction.getActive()) {
        this.$interaction.setActive(value);
      }
    },
    priority: function priority(value) {
      if (!this.$interactionsContainer) return;
      this.$interaction.set('priority', value);
      this.$interactionsContainer.sortInteractions();
    }
  };
  var interaction$1 = {
    mixins: [cmp$1, useMapCmp],
    props: props$6,
    methods: methods$9,
    watch: watch$4,
    stubVNode: {
      empty: function empty() {
        return this.$options.name;
      }
    },
    created: function created() {
      var _this = this;

      defineProperties$1(this, {
        /**
         * @type {Interaction|undefined}
         */
        $interaction: {
          enumerable: true,
          get: function get() {
            return _this.$olObject;
          }
        },
        $map: {
          enumerable: true,
          get: function get() {
            return _this.$services && _this.$services.map;
          }
        },
        $view: {
          enumerable: true,
          get: function get() {
            return _this.$services && _this.$services.view;
          }
        },
        $interactionsContainer: {
          enumerable: true,
          get: function get() {
            return _this.$services && _this.$services.interactionsContainer;
          }
        }
      });
    }
  };

  var methods$a = {
    /**
     * @return {IndexedCollectionAdapter}
     * @protected
     */
    getInteractionsTarget: function getInteractionsTarget() {
      throw new Error('Not implemented method');
    },

    /**
     * @param {Interaction|Vue} interaction
     * @return {void}
     */
    addInteraction: function addInteraction(interaction$$1) {
      interaction$$1 = interaction$$1 instanceof Vue ? interaction$$1.$interaction : interaction$$1;
      instanceOf(interaction$$1, Interaction);

      if (this.getInteractionsTarget().has(interaction$$1) === false) {
        this.getInteractionsTarget().add(interaction$$1);
        this.sortInteractions();
      }
    },

    /**
     * @param {Interaction|Vue} interaction
     * @return {void}
     */
    removeInteraction: function removeInteraction(interaction$$1) {
      interaction$$1 = interaction$$1 instanceof Vue ? interaction$$1.$interaction : interaction$$1;
      if (!interaction$$1) return;

      if (this.getInteractionsTarget().has(interaction$$1)) {
        this.getInteractionsTarget().remove(interaction$$1);
        this.sortInteractions();
      }
    },

    /**
     * @return {Interaction[]}
     */
    getInteractions: function getInteractions() {
      return this.getInteractionsTarget().elements;
    },

    /**
     * @param {string|number} id
     * @return {Interaction|undefined}
     */
    getInteractionById: function getInteractionById(id) {
      return this.getInteractionsTarget().findByKey(id);
    },

    /**
     * @return {void}
     */
    sortInteractions: function sortInteractions(sorter) {
      sorter || (sorter = this.getDefaultInteractionsSorter());
      this.getInteractionsTarget().sort(sorter);
    },

    /**
     * @return {function}
     * @protected
     */
    getDefaultInteractionsSorter: function getDefaultInteractionsSorter() {
      return function () {
        return 0;
      };
    },

    /**
     * @return {void}
     */
    clearInteractions: function clearInteractions() {
      this.getInteractionsTarget().clear();
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return {
        get interactionsContainer() {
          return vm;
        }

      };
    }
  };
  var interactionsContainer = {
    methods: methods$a
  };

  var methods$b = {
    /**
     * @return {{
     *     setSource: function(Source): void,
     *     getSource: function(): Source
     *   }|undefined}
     * @protected
     */
    getSourceTarget: function getSourceTarget() {
      throw new Error('Not implemented method');
    },

    /**
     * @return {Source|undefined}
     */
    getSource: function getSource() {
      return this._source;
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return {
        get sourceContainer() {
          return vm;
        }

      };
    },

    /**
     * @param {Source|Vue|undefined} source
     * @return {void}
     */
    setSource: function setSource(source) {
      source = source instanceof Vue ? source.$source : source;

      if (source !== this._source) {
        this._source = source;
      }
      /**
       * @type {Layer|Builder}
       */


      var sourceTarget = this.getSourceTarget();

      if (sourceTarget && source !== sourceTarget.getSource()) {
        sourceTarget.setSource(source);
      }
    }
  };
  var sourceContainer = {
    methods: methods$b,
    created: function created() {
      /**
       * @type {Source|undefined}
       * @private
       */
      this._source = undefined;
    }
  };

  var props$7 = {
    id: {
      type: [String, Number],
      default: function _default() {
        return v4_1();
      }
    },

    /**
     * The bounding extent for layer rendering defined in the map view projection.
     * The layer will not be rendered outside of this extent.
     * @default undefined
     * @type {Extent|number[]|undefined}
     */
    extent: {
      type: Array,
      validator: function validator(value) {
        return value.length === 4;
      }
    },
    minResolution: Number,
    maxResolution: Number,
    opacity: {
      type: Number,
      default: 1
    },
    overlay: {
      type: Boolean,
      default: false
    },
    visible: {
      type: Boolean,
      default: true
    },
    zIndex: Number
  };
  var methods$c = {
    /**
     * @return {Promise<Layer>}
     * @protected
     */
    createOlObject: function () {
      var _createOlObject = _asyncToGenerator(
      /*#__PURE__*/
      regenerator.mark(function _callee() {
        var layer;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.createLayer();

              case 2:
                layer = _context.sent;
                layer.set('id', this.id);
                return _context.abrupt("return", layer);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function createOlObject() {
        return _createOlObject.apply(this, arguments);
      };
    }(),

    /**
     * @return {Layer|Promise<Layer>}
     * @protected
     * @abstract
     */
    createLayer: function createLayer() {
      throw new Error('Not implemented method');
    },

    /**
     * @return {Promise<Vue<Layer>>}
     * @protected
     */
    init: function init() {
      return cmp$1.methods.init.call(this);
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      return cmp$1.methods.deinit.call(this);
    },

    /**
     * @param {number[]} pixel
     * @return {boolean}
     */
    isAtPixel: function isAtPixel(pixel) {
      var _this = this;

      hasMap(this);
      return this.$map.forEachLayerAtPixel(pixel, function (l) {
        return l === _this.$layer;
      });
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(cmp$1.methods.getServices.call(this), sourceContainer.methods.getServices.call(this), {
        get layer() {
          return vm.$layer;
        }

      });
    },

    /**
     * @return {{
     *     setSource: function(Source): void,
     *     getSource: function(): Source
     *   }|undefined}
     * @protected
     */
    getSourceTarget: function getSourceTarget() {
      return this.$layer;
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      if (this.overlay && this.$map) {
        this.setMap(this.$map);
      } else if (this.$layersContainer) {
        this.$layersContainer.addLayer(this);
      }

      this.subscribeAll();
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.unsubscribeAll();

      if (this.overlay) {
        this.setMap(undefined);
      } else if (this.$layersContainer) {
        this.$layersContainer.removeLayer(this);
      }
    },

    /**
     * Updates layer state
     * @return {Promise}
     */
    refresh: function refresh() {
      return cmp$1.methods.refresh.call(this);
    },

    /**
     * @param {Map|Vue|undefined} map
     */
    setMap: function setMap(map$$1) {
      hasLayer(this);
      map$$1 = map$$1 instanceof Vue ? map$$1.$map : map$$1;
      this.$layer.setMap(map$$1);
    },
    subscribeAll: function subscribeAll() {
      subscribeToLayerEvents.call(this);
    }
  };
  var watch$5 = {
    id: function id(value) {
      if (this.$layer && value !== this.$layer.get('id')) {
        this.$layer.set('id', value);
      }
    },
    maxResolution: function maxResolution(value) {
      if (this.$layer && value !== this.$layer.getMaxResolution()) {
        this.$layer.setMaxResolution(value);
      }
    },
    minResolution: function minResolution(value) {
      if (this.$layer && value !== this.$layer.getMinResolution()) {
        this.$layer.setMinResolution(value);
      }
    },
    opacity: function opacity(value) {
      if (this.$layer && value !== this.$layer.getOpacity()) {
        this.$layer.setOpacity(value);
      }
    },
    visible: function visible(value) {
      if (this.$layer && value !== this.$layer.getVisible()) {
        this.$layer.setVisible(value);
      }
    },
    zIndex: function zIndex(value) {
      if (this.$layer && value !== this.$layer.getZIndex()) {
        this.$layer.setZIndex(value);
      }
    },
    extent: function extent$$1(value) {
      if (this.$layer && !isEqual(value, this.$layer.getExtent())) {
        this.$layer.setExtent(value);
      }
    }
  };
  var layer = {
    mixins: [cmp$1, useMapCmp, sourceContainer],
    props: props$7,
    methods: methods$c,
    watch: watch$5,
    stubVNode: {
      attrs: function attrs() {
        return {
          id: [this.$options.name, this.id].join('-'),
          class: this.$options.name
        };
      }
    },
    created: function created() {
      var _this2 = this;

      defineProperties$1(this, {
        /**
         * @type {Layer|undefined}
         */
        $layer: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$olObject;
          }
        },
        $map: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.map;
          }
        },
        $view: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.view;
          }
        },
        $layersContainer: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.layersContainer;
          }
        }
      });
    }
  };

  function subscribeToLayerEvents() {
    var _this3 = this;

    hasLayer(this);
    var events = fromOlEvent(this.$layer, ['postcompose', 'precompose', 'render']);
    this.subscribeTo(events, function (evt) {
      return _this3.$emit(evt.type, evt);
    });
  }

  var methods$d = {
    /**
     * @return {IndexedCollectionAdapter}
     * @protected
     */
    getLayersTarget: function getLayersTarget() {
      throw new Error('Not implemented method');
    },

    /**
     * @param {Layer|Vue} layer
     * @return {void}
     */
    addLayer: function addLayer(layer) {
      layer = layer instanceof Vue ? layer.$layer : layer;
      instanceOf(layer, BaseLayer);

      if (this.getLayersTarget().has(layer) === false) {
        this.getLayersTarget().add(layer);
      }
    },

    /**
     * @param {Layer|Vue} layer
     * @return {void}
     */
    removeLayer: function removeLayer(layer) {
      layer = layer instanceof Vue ? layer.$layer : layer;
      if (!layer) return;

      if (this.getLayersTarget().has(layer)) {
        this.getLayersTarget().remove(layer);
      }
    },

    /**
     * @return {Layer[]}
     */
    getLayers: function getLayers() {
      return this.getLayersTarget().elements;
    },

    /**
     * @param {string|number} id
     * @return {Layer|undefined}
     */
    getLayerById: function getLayerById(id) {
      return this.getLayersTarget().findByKey(id);
    },

    /**
     * @return {void}
     */
    clearLayers: function clearLayers() {
      this.getLayersTarget().clear();
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return {
        get layersContainer() {
          return vm;
        }

      };
    }
  };
  var layersContainer = {
    methods: methods$d
  };

  var methods$e = {
    /**
     * @return {IndexedCollectionAdapter}
     * @protected
     */
    getOverlaysTarget: function getOverlaysTarget() {
      throw new Error('Not implemented method');
    },

    /**
     * @param {Overlay|Vue} overlay
     * @return {void}
     */
    addOverlay: function addOverlay(overlay) {
      overlay = overlay instanceof Vue ? overlay.$overlay : overlay;
      instanceOf(overlay, Overlay);

      if (this.getOverlaysTarget().has(overlay) === false) {
        this.getOverlaysTarget().add(overlay);
      }
    },

    /**
     * @param {Overlay|Vue} overlay
     * @return {void}
     */
    removeOverlay: function removeOverlay(overlay) {
      overlay = overlay instanceof Vue ? overlay.$overlay : overlay;
      if (!overlay) return;

      if (this.getOverlaysTarget().has(overlay)) {
        this.getOverlaysTarget().remove(overlay);
      }
    },

    /**
     * @return {Overlay[]}
     */
    getOverlays: function getOverlays() {
      return this.getOverlaysTarget().elements;
    },

    /**
     * @param {string|number} id
     * @return {Overlay|undefined}
     */
    getOverlayById: function getOverlayById(id) {
      return this.getOverlaysTarget().findByKey(id);
    },

    /**
     * @return {void}
     */
    clearOverlays: function clearOverlays() {
      this.getOverlaysTarget().clear();
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return {
        get overlaysContainer() {
          return vm;
        }

      };
    }
  };
  var overlaysContainer = {
    methods: methods$e
  };

  var stylesContainer = {
    created: function created() {
      /**
       * @type {Style[]|StyleFunction|Vue|undefined}
       * @private
       */
      this._styles = undefined;
    },
    methods: {
      /**
       * Default style factory
       * @return {Style[]|StyleFunction|undefined}
       * @protected
       */
      getDefaultStyles: function getDefaultStyles() {},

      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get stylesContainer() {
            return vm;
          }

        };
      },

      /**
       * @return {Style[]|StyleFunction|Vue|undefined}
       */
      getStyles: function getStyles() {
        return this._styles;
      },

      /**
       * @param {Style|StyleFunction|Vue|undefined} style
       * @return {void}
       */
      addStyle: function addStyle(style) {
        var currentStyles = this.getStyles();
        var olStyle = style instanceof Vue ? style.$style : style;

        if (isFunction(olStyle)) {

          currentStyles = style;
        } else {
          if (!isArray$1(currentStyles)) {

            currentStyles = [];
          }

          style = style instanceof Vue ? style : {
            $style: style,
            condition: true
          };

          if (!currentStyles.includes(style)) {
            currentStyles.push(style);
          }
        }

        this.setStyle(currentStyles);
      },

      /**
       * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|StyleFunction|Vue|undefined} styles
       * @return {void}
       */
      setStyle: function setStyle(styles) {
        if (styles === this._styles) return;
        this._styles = styles;
        var styleTarget = this.getStyleTarget();
        if (!styleTarget) return;

        if (this._styles === null || this._styles) {
          styleTarget.setStyle(this.createStyleFunc());
        } else {
          styleTarget.setStyle(undefined);
        }
      },

      /**
       * @param {Style|StyleFunction|Vue|undefined} style
       * @return {void}
       */
      removeStyle: function removeStyle(style) {
        var currentStyles = this.getStyles();

        if (currentStyles === style) {
          currentStyles = undefined;
        } else if (isArray$1(currentStyles)) {
          currentStyles = currentStyles.filter(function (s) {
            return style instanceof Vue ? s !== style : s.$style !== style;
          });
          currentStyles.length || (currentStyles = undefined);
        }

        this.setStyle(currentStyles);
      },

      /**
       * Returns OL object that can be styled (i.e. has setStyle/getStyle methods) or undefined
       * @return {*}
       * @protected
       * @abstract
       */
      getStyleTarget: function getStyleTarget() {
        throw new Error('Not implemented method');
      },

      /**
       * Style function factory
       * @returns {StyleFunction}
       * @protected
       */
      createStyleFunc: function createStyleFunc() {
        var vm = this;
        var defaultStyles = this.getDefaultStyles();
        return function __styleTargetStyleFunc(feature, resolution) {
          if (!feature.getGeometry()) return;
          var styles = vm.getStyles();
          /* eslint-disable brace-style */
          // handle provided styles
          // styles - StyleFunction or vl-style-func

          if (styles && (isFunction(styles) || isFunction(styles.$style))) {
            var styleFunc = isFunction(styles) ? styles : styles.$style;
            styles = styleFunc(feature, resolution);
          } // styles is array of { $style: Style, condition: (bool|function():bool) }
          else if (isArray$1(styles)) {
              styles = reduce(styles, function (newStyles, _ref) {
                var $style = _ref.$style,
                    condition$$1 = _ref.condition;

                if (condition$$1 == null || condition$$1 === true || isFunction(condition$$1) && condition$$1(feature, resolution)) {
                  newStyles.push($style);
                }

                return newStyles;
              }, []);
            }
          /* eslint-enable brace-style */
          // not empty or null style


          if (styles === null || isArray$1(styles) && styles.length) {
            return styles;
          } // fallback to default style


          styles = defaultStyles;

          if (styles) {
            return isFunction(styles) ? styles(feature, resolution) : styles;
          }
        };
      }
    }
  };

  /*!
  OpenLayers tile url function to load tile seeded with TileCache url scheme

  @package ol-tilecache
  @author Vladimir Vershinin <ghettovoice@gmail.com>
  @version 3.0.1
  @licence MIT
  @copyright (c) 2016-2018, Vladimir Vershinin <ghettovoice@gmail.com>
  */
  /**
   * This file is part of ol-tilecache package.
   * @module ol-tilecache
   * @license MIT
   * @author Vladimir Vershinin
   */

  /**
   * Left zero pad.
   *
   * @param {string | number} num
   * @param {number} places
   * @returns {string}
   */

  function zeroPad(num, places) {
    var zero = places - num.toString().length + 1;
    return (new Array(parseInt(zero > 0 && zero, 10)).join("0") + num).toString().slice(-places);
  }
  /**
   * The % operator in JavaScript returns the remainder of a / b, but differs from
   * some other languages in that the result will have the same sign as the
   * dividend. For example, -1 % 8 == -1, whereas in some other languages
   * (such as Python) the result would be 7. This function emulates the more
   * correct modulo behavior, which is useful for certain applications such as
   * calculating an offset index in a circular list.
   *
   * @param {number} a The dividend.
   * @param {number} b The divisor.
   * @return {number} a % b where the result is between 0 and b (either 0 <= x < b
   *     or b < x <= 0, depending on the sign of b).
   * @link https://closure-library.googlecode.com/git-history/docs/local_closure_goog_math_math.js.source.html#line73
   */


  function modulo(a, b) {
    var m = a % b;
    return m * b < 0 ? m + b : m;
  }

  function isArray$4(value) {
    return Object.prototype.toString.call(value) === '[object Array]';
  }

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  /**
   * This file is part of ol-tilecache package.
   * @module ol-tilecache
   * @license MIT
   * @author Vladimir Vershinin
   */

  /**
   * @param {TileGrid} tileGrid
   * @param {number[]} extent
   * @param {number} z
   * @return {{minX, minY, maxX, maxY}}
   */


  function calculateTileRangeForZ(tileGrid, extent$$1, z) {
    var resolution = tileGrid.getResolution(z);

    var _getTileCoordForXYAnd = getTileCoordForXYAndResolution(tileGrid, extent$$1[0], extent$$1[1], resolution, false),
        _getTileCoordForXYAnd2 = slicedToArray(_getTileCoordForXYAnd, 2),
        minX = _getTileCoordForXYAnd2[0],
        minY = _getTileCoordForXYAnd2[1];

    var _getTileCoordForXYAnd3 = getTileCoordForXYAndResolution(tileGrid, extent$$1[2], extent$$1[3], resolution, true),
        _getTileCoordForXYAnd4 = slicedToArray(_getTileCoordForXYAnd3, 2),
        maxX = _getTileCoordForXYAnd4[0],
        maxY = _getTileCoordForXYAnd4[1];

    return {
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  }
  /**
   * @param {TileGrid} tileGrid
   * @param {number} x
   * @param {number} y
   * @param {number} resolution
   * @param {boolean} reverseIntersectionPolicy
   * @return {number[]}
   */


  function getTileCoordForXYAndResolution(tileGrid, x, y, resolution, reverseIntersectionPolicy) {
    var z = tileGrid.getZForResolution(resolution);
    var scale = resolution / tileGrid.getResolution(z);
    var origin = tileGrid.getOrigin(z);
    var tileSize = tileGrid.getTileSize(z);

    if (!isArray$4(tileSize)) {
      tileSize = [tileSize, tileSize];
    }

    var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
    var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
    var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
    var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
    var tileCoordX = scale * xFromOrigin / tileSize[0];
    var tileCoordY = scale * yFromOrigin / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = Math.ceil(tileCoordX) - 1;
      tileCoordY = Math.ceil(tileCoordY) - 1;
    } else {
      tileCoordX = Math.floor(tileCoordX);
      tileCoordY = Math.floor(tileCoordY);
    }

    return [tileCoordX, tileCoordY];
  }
  /**
   * @param {{minX, minY, maxX, maxY}} tileRange
   * @return {number}
   */


  function getTileRangeHeight(tileRange) {
    return tileRange.maxY - tileRange.minY + 1;
  }
  /**
   * This file is part of ol-tilecache package.
   * @module ol-tilecache
   * @license MIT
   * @author Vladimir Vershinin
   */


  var zRegEx = /{z}/g;
  var zPadRegEx = /{0z}/g;
  var xRegEx = /{x\d?}/g;
  var yRegEx = /{y\d?}/g;
  var dashYRegEx = /{-y\d?}/g;
  var EPSG3857_EXTENT = [-20037508.342789244, -20037508.342789244, 20037508.342789244, 20037508.342789244];
  /**
   * Basic create factory.
   *
   * @param {string} url Url template
   * @param {TileGrid} [tileGrid] Tile grid.
   * @param {Extent|number[]} [extent] Tile grid extent.
   * @returns {function(tileCoord: TileCoord)}
   * @static
   * @public
   */

  function createTileUrlFunction(url) {
    var tileGrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tilegrid.createXYZ();
    var extent$$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG3857_EXTENT;
    return createTileUrlFunctionFromTemplates(expandUrl(url), tileGrid, extent$$1);
  }
  /**
   * Creates tile URL function from single template.
   *
   * @param {string} template Source url
   * @param {TileGrid} [tileGrid] Tile grid.
   * @param {Extent|number[]} [extent] Tile grid extent.
   * @returns {function(tileCoord: TileCoord)}
   * @private
   */


  function createTileUrlFunctionFromTemplate(template) {
    var tileGrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tilegrid.createXYZ();
    var extent$$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG3857_EXTENT;
    return (
      /**
       * @param {TileCoord} tileCoord Tile Coordinate.
       * @return {string | undefined} Tile URL.
       */
      function (tileCoord) {
        if (tileCoord != null) {
          return template.replace(zRegEx, zoomReplacer(tileCoord[0])).replace(zPadRegEx, zoomReplacer(tileCoord[0], true)).replace(xRegEx, coordReplacer(tileCoord[1])).replace(yRegEx, function (part) {
            var y = -tileCoord[2] - 1;
            return coordReplacer(y)(part);
          }).replace(dashYRegEx, function (part) {
            var z = tileCoord[0]; // The {-y} placeholder requires a tile grid with extent

            var range = calculateTileRangeForZ(tileGrid, extent$$1, z);
            var y = getTileRangeHeight(range) + tileCoord[2];
            return coordReplacer(y)(part);
          });
        }
      }
    );
  }
  /**
   * Creates tile URL function from multiple templates.
   *
   * @param {string[]} templates Url templates
   * @param {TileGrid} [tileGrid] Tile grid.
   * @param {Extent | number[]} [extent] Tile grid extent.
   * @returns {function(tileCoord: TileCoord)}
   * @private
   */


  function createTileUrlFunctionFromTemplates(templates) {
    var tileGrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tilegrid.createXYZ();
    var extent$$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG3857_EXTENT;
    return createTileUrlFunctionFromTileUrlFunctions(templates.map(function (tileUrlFunction) {
      return createTileUrlFunctionFromTemplate(tileUrlFunction, tileGrid, extent$$1);
    }));
  }
  /**
   * @param zoom
   * @param pad
   * @returns {function}
   * @private
   */


  function zoomReplacer(zoom, pad) {
    return function () {
      return pad ? zeroPad(zoom, 2) : zoom.toString();
    };
  }
  /**
   * @param coord
   * @returns {function}
   * @private
   */


  function coordReplacer(coord) {
    return function (part) {
      var match = part.match(/\d/);

      if (match) {
        return zeroPad(coord, 9).slice((match[0] - 1) * 3, match[0] * 3);
      }

      return coord.toString();
    };
  }
  /**
   * @param {string} url
   * @returns {Array.<string>}
   * @private
   */


  function expandUrl(url) {
    var urls = [];
    var match = /{(\d)-(\d)}/.exec(url) || /{([a-z])-([a-z])}/.exec(url);

    if (match) {
      var startCharCode = match[1].charCodeAt(0);
      var stopCharCode = match[2].charCodeAt(0);

      for (var charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
        urls.push(url.replace(match[0], String.fromCharCode(charCode)));
      }
    } else {
      urls.push(url);
    }

    return urls;
  }
  /**
   * @param {Array.<function(tileCoord: TileCoord)>} tileUrlFunctions
   * @returns {function(tileCoord: TileCoord)}
   * @private
   */


  function createTileUrlFunctionFromTileUrlFunctions(tileUrlFunctions) {
    if (tileUrlFunctions.length === 1) {
      return tileUrlFunctions[0];
    }

    return (
      /**
       * @param {TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {Projection} projection Projection.
       * @return {string | undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
        if (tileCoord != null) {
          var h = (tileCoord[1] << tileCoord[0]) + tileCoord[2];
          var index = modulo(h, tileUrlFunctions.length);
          return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
        }
      }
    );
  }
  /**
   * This file is part of ol-tilecache package.
   * @module ol-tilecache
   * @license MIT
   * @author Vladimir Vershinin
   */
  // for backward compatibility


  if (typeof window !== 'undefined' && window.ol) {
    window.ol.tileCacheUrlFn = {
      createTileUrlFunction: createTileUrlFunction,
      createTileUrlFunctionFromTemplate: createTileUrlFunctionFromTemplate,
      createTileUrlFunctionFromTemplates: createTileUrlFunctionFromTemplates
    };
  }

  /**
   * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
   * @param {Extent} extent Extent.
   * @param {number=} maxZoom Maximum zoom level (default is
   *     ol.DEFAULT_MAX_ZOOM).
   * @param {number|Size=} tileSize Tile size (default uses
   *     ol.DEFAULT_TILE_SIZE).
   * @return {!Array.<number>} Resolutions array.
   * @see https://github.com/openlayers/openlayers/blob/master/src/ol/tilegrid.js#L104
   */

  function resolutionsFromExtent(extent$$1) {
    var maxZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_ZOOM;
    var tileSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TILE_SIZE;
    tileSize = size.toSize(tileSize);
    var height = extent.getHeight(extent$$1);
    var width = extent.getWidth(extent$$1);
    var maxResolution = Math.max(width / tileSize[0], height / tileSize[1]);
    var length = maxZoom + 1;
    var resolutions = new Array(length);

    for (var z = 0; z < length; ++z) {
      resolutions[z] = maxResolution / Math.pow(2, z);
    }

    return resolutions;
  }
  /**
   * @param {Extent} extent Extent.
   * @param {number=} maxZoom Maximum zoom level (default is MAX_ZOOM).
   * @param {number|Size=} tileSize Tile size (default uses TILE_SIZE).
   * @param {string} [corner] Extent corner (default is EXTENT_CORNER.TOP_LEFT).
   * @return {TileGrid} TileGrid instance.
   * @see https://github.com/openlayers/openlayers/blob/master/src/ol/tilegrid.js#L58
   */

  function createGridForExtent(extent$$1) {
    var maxZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_ZOOM;
    var tileSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TILE_SIZE;
    var corner = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EXTENT_CORNER.TOP_LEFT;
    var resolutions = resolutionsFromExtent(extent$$1, maxZoom, tileSize);
    return new TileGrid({
      extent: extent$$1,
      origin: getExtentCorner(extent$$1, corner),
      resolutions: resolutions,
      tileSize: tileSize
    });
  }
  /**
   * @param {ProjectionLike} projection Projection.
   * @param {number=} maxZoom Maximum zoom level (default is
   *     ol.DEFAULT_MAX_ZOOM).
   * @param {number|Size=} tileSize Tile size (default uses ol.DEFAULT_TILE_SIZE).
   * @param {string} corner Extent corner (default is
   *     ol.extent.Corner.BOTTOM_LEFT).
   * @return {TileGrid} TileGrid instance.
   * @see https://github.com/openlayers/openlayers/blob/master/src/ol/tilegrid.js#L135
   */

  function createGridForProjection(projection) {
    var maxZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_ZOOM;
    var tileSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TILE_SIZE;
    var corner = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EXTENT_CORNER.BOTTOM_LEFT;
    return createGridForExtent(createExtentFromProjection(projection), maxZoom, tileSize, corner);
  }

  var withUrl = {
    props: {
      url: {
        type: String
      }
    },
    computed: {
      /**
       * @type {string}
       */
      urlTmpl: function urlTmpl() {
        return replaceTokens(this.url, pick(this, this.urlTokens));
      },

      /**
       * @type {string[]}
       */
      urlTokens: function urlTokens() {
        return [];
      }
    }
  };

  var props$8 = {
    cacheSize: {
      type: Number,
      default: CACHE_SIZE
    },
    crossOrigin: String,
    maxZoom: {
      type: Number,
      default: MAX_ZOOM
    },
    minZoom: {
      type: Number,
      default: MIN_ZOOM
    },
    opaque: Boolean,
    projection: {
      type: String,
      default: EPSG_3857
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: REPROJ_ERR_THRESHOLD
    },
    tilePixelRatio: {
      type: Number,
      default: PIXEL_RATIO
    },
    tileSize: {
      type: Array,
      default: function _default() {
        return [TILE_SIZE, TILE_SIZE];
      },
      validator: function validator(value) {
        return value.length === 2;
      }
    },
    tileLoadFunction: Function,
    url: {
      type: [String, Function],
      required: true
    },

    /**
     * Duration of the opacity transition for rendering. To disable the opacity transition, pass `0`.
     * @type {number}
     */
    transition: Number
  };
  var computed$2 = {
    /**
     * @type {string}
     */
    urlTmpl: function urlTmpl() {
      if (!isString(this.url)) {
        return '';
      }

      return replaceTokens(this.url, pick(this, this.urlTokens));
    }
  };
  var methods$f = {
    /**
     * @return {TileGrid}
     * @protected
     */
    createTileGrid: function createTileGrid() {
      hasView(this);
      return tilegrid.createXYZ({
        extent: createExtentFromProjection(this.$view.getProjection()),
        maxZoom: this.maxZoom,
        minZoom: this.minZoom,
        tileSize: this.tileSize
      });
    },

    /**
     * @return {TileUrlFunction}
     * @protected
     */
    createUrlFunc: function createUrlFunc() {
      // custom url function provided
      if (isFunction(this.url)) {
        return this.url;
      }

      hasView(this); // or use url function from ol-tilecache

      return createTileUrlFunction(this.urlTmpl, this._tileGrid, createExtentFromProjection(this.$view.getProjection()));
    },

    /**
     * @return {Promise}
     * @protected
     */
    init: function init() {
      /**
       * @type {TileGrid}
       * @protected
       */
      this._tileGrid = this.createTileGrid();
      return source.methods.init.call(this);
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      this._tileGrid = undefined;
      return source.methods.deinit.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      source.methods.mount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      source.methods.mount.call(this);
    },
    subscribeAll: function subscribeAll() {
      subscribeToSourceEvents$1.call(this);
    }
  };
  var watch$6 = {
    url: function url() {
      if (this.$source) {
        this.$source.setTileUrlFunction(this.createUrlFunc());
        this.scheduleRefresh();
      }
    }
  };
  var tileSource = {
    mixins: [source, withUrl],
    props: props$8,
    computed: computed$2,
    methods: methods$f,
    watch: watch$6
  };

  function subscribeToSourceEvents$1() {
    var _this = this;

    hasSource(this);
    var events = fromOlEvent(this.$source, ['tileloadstart', 'tileloadend', 'tileloaderror']);
    this.subscribeTo(events, function (evt) {
      return _this.$emit(evt.type, evt);
    });
  }

  var props$9 = {
    /**
     * When set to `true`, feature batches will be recreated during animations.
     * @type {boolean}
     * @default false
     */
    updateWhileAnimating: Boolean,

    /**
     * When set to `true`, feature batches will be recreated during interactions.
     * @type {boolean}
     * @default false
     */
    updateWhileInteracting: Boolean,

    /**
     * @type {number|undefined}
     */
    renderBuffer: {
      type: Number,
      default: 100
    },

    /**
     * @type {RenderOrderFunction|undefined}
     */
    renderOrder: Function,

    /**
     * @type {boolean}
     */
    declutter: Boolean
  };
  var methods$g = {
    /**
     * @return {Promise<Vue<Layer>>}
     * @protected
     */
    init: function init() {
      return layer.methods.init.call(this);
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      return layer.methods.deinit.call(this);
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      return multiMergeDescriptors(layer.methods.getServices.call(this), stylesContainer.methods.getServices.call(this));
    },

    /**
     * @return {Vector|undefined}
     * @protected
     */
    getStyleTarget: function getStyleTarget() {
      return this.$layer;
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      layer.methods.mount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      layer.methods.unmount.call(this);
    },
    subscribeAll: function subscribeAll() {
      layer.methods.subscribeAll.call(this);
    }
  };
  var vectorLayer = {
    mixins: [layer, stylesContainer],
    props: props$9,
    methods: methods$g
  };

  /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
  function debounceTime(dueTime, scheduler) {
      if (scheduler === void 0) {
          scheduler = async;
      }
      return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
  }
  var DebounceTimeOperator = /*@__PURE__*/ (function () {
      function DebounceTimeOperator(dueTime, scheduler) {
          this.dueTime = dueTime;
          this.scheduler = scheduler;
      }
      DebounceTimeOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
      };
      return DebounceTimeOperator;
  }());
  var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(DebounceTimeSubscriber, _super);
      function DebounceTimeSubscriber(destination, dueTime, scheduler) {
          var _this = _super.call(this, destination) || this;
          _this.dueTime = dueTime;
          _this.scheduler = scheduler;
          _this.debouncedSubscription = null;
          _this.lastValue = null;
          _this.hasValue = false;
          return _this;
      }
      DebounceTimeSubscriber.prototype._next = function (value) {
          this.clearDebounce();
          this.lastValue = value;
          this.hasValue = true;
          this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
      };
      DebounceTimeSubscriber.prototype._complete = function () {
          this.debouncedNext();
          this.destination.complete();
      };
      DebounceTimeSubscriber.prototype.debouncedNext = function () {
          this.clearDebounce();
          if (this.hasValue) {
              var lastValue = this.lastValue;
              this.lastValue = null;
              this.hasValue = false;
              this.destination.next(lastValue);
          }
      };
      DebounceTimeSubscriber.prototype.clearDebounce = function () {
          var debouncedSubscription = this.debouncedSubscription;
          if (debouncedSubscription !== null) {
              this.remove(debouncedSubscription);
              debouncedSubscription.unsubscribe();
              this.debouncedSubscription = null;
          }
      };
      return DebounceTimeSubscriber;
  }(Subscriber));
  function dispatchNext$1(subscriber) {
      subscriber.debouncedNext();
  }

  /**
   * Wraps OpenLayers collection to provide indexed access to elements.
   */

  var IndexedCollectionAdapter =
  /*#__PURE__*/
  function () {
    /**
     * @param {Collection} collection
     * @param {function} getElementKey
     */
    function IndexedCollectionAdapter(collection, getElementKey) {
      var _this = this;

      _classCallCheck(this, IndexedCollectionAdapter);

      /**
       * @type {Collection}
       * @private
       */
      this._adaptee = collection;
      /**
       * @type {Function}
       * @private
       */

      this._getElementKey = getElementKey;
      /**
       * @type {Object<mixed, number>}
       * @private
       */

      this._index = create$1(null);

      this._adaptee.forEach(function (element) {
        return _this._addToIndex(_this._getElementKey(element), element);
      });
    }
    /**
     * @return {Collection}
     */


    _createClass(IndexedCollectionAdapter, [{
      key: "forEach",

      /**
       * @param {function} iteratee
       */
      value: function forEach$$1(iteratee) {
        forEach(this.elements, iteratee);
      }
      /**
       * @param {*} element
       */

    }, {
      key: "add",
      value: function add(element) {
        var key = this._getElementKey(element);

        if (key != null) {
          this._adaptee.push(element);

          this._index[key] = element;
        }
      }
      /**
       * @param {*} element
       */

    }, {
      key: "remove",
      value: function remove(element) {
        if (this._adaptee.remove(element)) {
          this._removeFromIndex(this._getElementKey(element));
        }
      }
      /**
       * @param {*} element
       * @return {boolean}
       */

    }, {
      key: "has",
      value: function has(element) {
        return !!this.findByKey(this._getElementKey(element));
      }
      /**
       * @return {void}
       */

    }, {
      key: "clear",
      value: function clear() {
        this._adaptee.clear();

        this._resetIndex();
      }
      /**
       * @param {*} key
       * @return {*|undefined}
       */

    }, {
      key: "findByKey",
      value: function findByKey(key) {
        return key && this._index[key];
      }
      /**
       * @param {function} sorter
       */

    }, {
      key: "sort",
      value: function sort(sorter) {
        this.elements.sort(sorter);
      }
      /**
       * @private
       */

    }, {
      key: "_resetIndex",
      value: function _resetIndex() {
        this._index = create$1(null);
      }
      /**
       * @param {string} key
       * @param {*} element
       * @private
       */

    }, {
      key: "_addToIndex",
      value: function _addToIndex(key, element) {
        if (key == null) {
          return false;
        }

        this._index[key] = element;
        element.on('propertychange', this._handleElementChange, this);
        return true;
      }
      /**
       * @param {string} key
       * @private
       */

    }, {
      key: "_removeFromIndex",
      value: function _removeFromIndex(key) {
        var element = this.findByKey(key);

        if (element) {
          element.un('propertychange', this._handleElementChange, this);
          delete this._index[key];
        }

        return !!element;
      }
      /**
       * Updates index
       * @param {*} target
       * @private
       */

    }, {
      key: "_handleElementChange",
      value: function _handleElementChange(_ref) {
        var target = _ref.target;

        var key = this._getElementKey(target); // remove by old key


        if (this.findByKey(key) !== target) {
          for (var k in this._index) {
            if (this._index[k] === target) {
              this._removeFromIndex(k);

              break;
            }
          }
        }

        this._addToIndex(key, target);
      }
    }, {
      key: "adaptee",
      get: function get$$1() {
        return this._adaptee;
      }
    }, {
      key: "elements",
      get: function get$$1() {
        return this._adaptee.getArray();
      }
    }]);

    return IndexedCollectionAdapter;
  }();
  /**
   * Wraps vector source to provide collection like API.
   */

  var SourceCollectionAdapter =
  /*#__PURE__*/
  function () {
    /**
     * @param {Vector} source
     */
    function SourceCollectionAdapter(source) {
      _classCallCheck(this, SourceCollectionAdapter);

      /**
       * @type {Vector}
       * @private
       */
      this._adaptee = source;
    }
    /**
     * @return {Vector}
     */


    _createClass(SourceCollectionAdapter, [{
      key: "forEach",

      /**
       * @param {function} iteratee
       */
      value: function forEach$$1(iteratee) {
        this.elements.forEach(iteratee);
      }
      /**
       * @param {Feature} feature
       */

    }, {
      key: "add",
      value: function add(feature) {
        this._adaptee.addFeature(feature);
      }
      /**
       * @param {Feature} feature
       */

    }, {
      key: "remove",
      value: function remove(feature) {
        this._adaptee.removeFeature(feature);
      }
      /**
       * @param {Feature} feature
       * @return {boolean}
       */

    }, {
      key: "has",
      value: function has(feature) {
        return !!this.findByKey(feature.getId());
      }
      /**
       * @return {void}
       */

    }, {
      key: "clear",
      value: function clear() {
        this._adaptee.clear();
      }
      /**
       * @param {*} key
       * @return {Feature|undefined}
       */

    }, {
      key: "findByKey",
      value: function findByKey(key) {
        return this._adaptee.getFeatureById(key);
      }
      /**
       * @param {function} sorter
       */

    }, {
      key: "sort",
      value: function sort(sorter) {
        throw new Error('Not supported');
      }
    }, {
      key: "adaptee",
      get: function get$$1() {
        return this._adaptee;
      }
      /**
       * @return {Array<Feature>}
       */

    }, {
      key: "elements",
      get: function get$$1() {
        return this._adaptee.getFeatures();
      }
    }]);

    return SourceCollectionAdapter;
  }();

  var props$a = {
    useSpatialIndex: {
      type: Boolean,
      default: true
    }
  };
  var computed$3 = {
    featuresViewProj: function featuresViewProj() {
      if (this.rev && this.resolvedDataProjection && this.$source) {
        return this.getFeatures().map(this.writeFeatureInViewProj.bind(this));
      }

      return [];
    }
  };
  var methods$h = {
    /**
     * @return {void}
     */
    clear: function clear() {
      featuresContainer.methods.clearFeatures.call(this);
    },

    /**
     * @return {SourceCollectionAdapter}
     * @protected
     */
    getFeaturesTarget: function getFeaturesTarget() {
      if (this._featuresTarget == null && this.$source) {
        this._featuresTarget = new SourceCollectionAdapter(this.$source);
      }

      return this._featuresTarget;
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices: function getServices() {
      return multiMergeDescriptors(source.methods.getServices.call(this), featuresContainer.methods.getServices.call(this));
    },

    /**
     * @return {Promise}
     * @protected
     */
    init: function init() {
      return source.methods.init.call(this);
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      return source.methods.deinit.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      source.methods.mount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.clear();
      source.methods.unmount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      subscribeToSourceChanges.call(this);
    },

    /**
     * @param feature
     * @return {ReadonlyArray<any>}
     * @protected
     */
    writeFeatureInDataProj: function writeFeatureInDataProj(feature) {
      return projTransforms.methods.writeFeatureInDataProj.call(this, feature);
    },

    /**
     * @param feature
     * @return {ReadonlyArray<any>}
     * @protected
     */
    writeGeometryInViewProj: function writeGeometryInViewProj(feature) {
      return projTransforms.methods.writeFeatureInViewProj.call(this, feature);
    }
  };
  var vectorSource = {
    mixins: [source, featuresContainer, projTransforms],
    props: props$a,
    computed: computed$3,
    methods: methods$h,
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          class: this.$options.name
        };
      }
    }
  };

  function subscribeToSourceChanges() {
    var _this = this;

    hasSource(this);
    var add = fromOlEvent(this.$source, 'addfeature').pipe(tap(function (_ref) {
      var feature = _ref.feature;

      _this.addFeature(feature);
    }));
    var remove = fromOlEvent(this.$source, 'removefeature').pipe(tap(function (_ref2) {
      var feature = _ref2.feature;

      _this.removeFeature(feature);
    }));
    var changeFeature = fromOlEvent(this.$source, 'changefeature');
    var events = merge(add, remove, changeFeature);
    this.subscribeTo(events, function (evt) {
      ++_this.rev;

      _this.$emit(evt.type, evt);
    }); // emit event to allow `sync` modifier

    this.subscribeTo(events.pipe(debounceTime(100)), function () {
      _this.$emit('update:features', _this.getFeatures().map(_this.writeFeatureInDataProj.bind(_this)));
    });
  }

  var methods$i = {
    /**
     * @param {Fill|Vue|undefined} fill
     * @return {void}
     * @protected
     */
    setFill: function setFill(fill) {
      fill = fill instanceof Vue ? fill.$style : fill;

      if (fill !== this._fill) {
        this._fill = fill;
      }

      if (this.$style && fill !== this.$style.getFill()) {
        this.$style.setFill(fill);
        this.scheduleRefresh();
      }
    },

    /**
     * @param {Stroke|Vue|undefined} stroke
     * @return {void}
     * @protected
     */
    setStroke: function setStroke(stroke) {
      stroke = stroke instanceof Vue ? stroke.$style : stroke;

      if (stroke !== this._stroke) {
        this._stroke = stroke;
      }

      if (this.$style && stroke !== this.$style.getStroke()) {
        this.$style.setStroke(stroke);
        this.scheduleRefresh();
      }
    }
  };
  var withFillStrokeStyle = {
    methods: methods$i,
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          class: this.$options.name
        };
      }
    },
    created: function created() {
      /**
       * @type {Fill|undefined}
       * @private
       */
      this._fill = undefined;
      /**
       * @type {Stroke|undefined}
       * @private
       */

      this._stroke = undefined;
    }
  };

  /* MIT license */

  var conversions = {
    rgb2hsl: rgb2hsl,
    rgb2hsv: rgb2hsv,
    rgb2hwb: rgb2hwb,
    rgb2cmyk: rgb2cmyk,
    rgb2keyword: rgb2keyword,
    rgb2xyz: rgb2xyz,
    rgb2lab: rgb2lab,
    rgb2lch: rgb2lch,

    hsl2rgb: hsl2rgb,
    hsl2hsv: hsl2hsv,
    hsl2hwb: hsl2hwb,
    hsl2cmyk: hsl2cmyk,
    hsl2keyword: hsl2keyword,

    hsv2rgb: hsv2rgb,
    hsv2hsl: hsv2hsl,
    hsv2hwb: hsv2hwb,
    hsv2cmyk: hsv2cmyk,
    hsv2keyword: hsv2keyword,

    hwb2rgb: hwb2rgb,
    hwb2hsl: hwb2hsl,
    hwb2hsv: hwb2hsv,
    hwb2cmyk: hwb2cmyk,
    hwb2keyword: hwb2keyword,

    cmyk2rgb: cmyk2rgb,
    cmyk2hsl: cmyk2hsl,
    cmyk2hsv: cmyk2hsv,
    cmyk2hwb: cmyk2hwb,
    cmyk2keyword: cmyk2keyword,

    keyword2rgb: keyword2rgb,
    keyword2hsl: keyword2hsl,
    keyword2hsv: keyword2hsv,
    keyword2hwb: keyword2hwb,
    keyword2cmyk: keyword2cmyk,
    keyword2lab: keyword2lab,
    keyword2xyz: keyword2xyz,

    xyz2rgb: xyz2rgb,
    xyz2lab: xyz2lab,
    xyz2lch: xyz2lch,

    lab2xyz: lab2xyz,
    lab2rgb: lab2rgb,
    lab2lch: lab2lch,

    lch2lab: lch2lab,
    lch2xyz: lch2xyz,
    lch2rgb: lch2rgb
  };


  function rgb2hsl(rgb) {
    var r = rgb[0]/255,
        g = rgb[1]/255,
        b = rgb[2]/255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        delta = max - min,
        h, s, l;

    if (max == min)
      h = 0;
    else if (r == max)
      h = (g - b) / delta;
    else if (g == max)
      h = 2 + (b - r) / delta;
    else if (b == max)
      h = 4 + (r - g)/ delta;

    h = Math.min(h * 60, 360);

    if (h < 0)
      h += 360;

    l = (min + max) / 2;

    if (max == min)
      s = 0;
    else if (l <= 0.5)
      s = delta / (max + min);
    else
      s = delta / (2 - max - min);

    return [h, s * 100, l * 100];
  }

  function rgb2hsv(rgb) {
    var r = rgb[0],
        g = rgb[1],
        b = rgb[2],
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        delta = max - min,
        h, s, v;

    if (max == 0)
      s = 0;
    else
      s = (delta/max * 1000)/10;

    if (max == min)
      h = 0;
    else if (r == max)
      h = (g - b) / delta;
    else if (g == max)
      h = 2 + (b - r) / delta;
    else if (b == max)
      h = 4 + (r - g) / delta;

    h = Math.min(h * 60, 360);

    if (h < 0)
      h += 360;

    v = ((max / 255) * 1000) / 10;

    return [h, s, v];
  }

  function rgb2hwb(rgb) {
    var r = rgb[0],
        g = rgb[1],
        b = rgb[2],
        h = rgb2hsl(rgb)[0],
        w = 1/255 * Math.min(r, Math.min(g, b)),
        b = 1 - 1/255 * Math.max(r, Math.max(g, b));

    return [h, w * 100, b * 100];
  }

  function rgb2cmyk(rgb) {
    var r = rgb[0] / 255,
        g = rgb[1] / 255,
        b = rgb[2] / 255,
        c, m, y, k;

    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  }

  function rgb2keyword(rgb) {
    return reverseKeywords[JSON.stringify(rgb)];
  }

  function rgb2xyz(rgb) {
    var r = rgb[0] / 255,
        g = rgb[1] / 255,
        b = rgb[2] / 255;

    // assume sRGB
    r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
    g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
    b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

    var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
    var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
    var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

    return [x * 100, y *100, z * 100];
  }

  function rgb2lab(rgb) {
    var xyz = rgb2xyz(rgb),
          x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l, a, b;

    x /= 95.047;
    y /= 100;
    z /= 108.883;

    x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
    y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
    z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

    l = (116 * y) - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);

    return [l, a, b];
  }

  function rgb2lch(args) {
    return lab2lch(rgb2lab(args));
  }

  function hsl2rgb(hsl) {
    var h = hsl[0] / 360,
        s = hsl[1] / 100,
        l = hsl[2] / 100,
        t1, t2, t3, rgb, val;

    if (s == 0) {
      val = l * 255;
      return [val, val, val];
    }

    if (l < 0.5)
      t2 = l * (1 + s);
    else
      t2 = l + s - l * s;
    t1 = 2 * l - t2;

    rgb = [0, 0, 0];
    for (var i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * - (i - 1);
      t3 < 0 && t3++;
      t3 > 1 && t3--;

      if (6 * t3 < 1)
        val = t1 + (t2 - t1) * 6 * t3;
      else if (2 * t3 < 1)
        val = t2;
      else if (3 * t3 < 2)
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      else
        val = t1;

      rgb[i] = val * 255;
    }

    return rgb;
  }

  function hsl2hsv(hsl) {
    var h = hsl[0],
        s = hsl[1] / 100,
        l = hsl[2] / 100,
        sv, v;

    if(l === 0) {
        // no need to do calc on black
        // also avoids divide by 0 error
        return [0, 0, 0];
    }

    l *= 2;
    s *= (l <= 1) ? l : 2 - l;
    v = (l + s) / 2;
    sv = (2 * s) / (l + s);
    return [h, sv * 100, v * 100];
  }

  function hsl2hwb(args) {
    return rgb2hwb(hsl2rgb(args));
  }

  function hsl2cmyk(args) {
    return rgb2cmyk(hsl2rgb(args));
  }

  function hsl2keyword(args) {
    return rgb2keyword(hsl2rgb(args));
  }


  function hsv2rgb(hsv) {
    var h = hsv[0] / 60,
        s = hsv[1] / 100,
        v = hsv[2] / 100,
        hi = Math.floor(h) % 6;

    var f = h - Math.floor(h),
        p = 255 * v * (1 - s),
        q = 255 * v * (1 - (s * f)),
        t = 255 * v * (1 - (s * (1 - f))),
        v = 255 * v;

    switch(hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  }

  function hsv2hsl(hsv) {
    var h = hsv[0],
        s = hsv[1] / 100,
        v = hsv[2] / 100,
        sl, l;

    l = (2 - s) * v;
    sl = s * v;
    sl /= (l <= 1) ? l : 2 - l;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  }

  function hsv2hwb(args) {
    return rgb2hwb(hsv2rgb(args))
  }

  function hsv2cmyk(args) {
    return rgb2cmyk(hsv2rgb(args));
  }

  function hsv2keyword(args) {
    return rgb2keyword(hsv2rgb(args));
  }

  // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
  function hwb2rgb(hwb) {
    var h = hwb[0] / 360,
        wh = hwb[1] / 100,
        bl = hwb[2] / 100,
        ratio = wh + bl,
        i, v, f, n;

    // wh + bl cant be > 1
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }

    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;
    if ((i & 0x01) != 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh);  // linear interpolation

    switch (i) {
      default:
      case 6:
      case 0: r = v; g = n; b = wh; break;
      case 1: r = n; g = v; b = wh; break;
      case 2: r = wh; g = v; b = n; break;
      case 3: r = wh; g = n; b = v; break;
      case 4: r = n; g = wh; b = v; break;
      case 5: r = v; g = wh; b = n; break;
    }

    return [r * 255, g * 255, b * 255];
  }

  function hwb2hsl(args) {
    return rgb2hsl(hwb2rgb(args));
  }

  function hwb2hsv(args) {
    return rgb2hsv(hwb2rgb(args));
  }

  function hwb2cmyk(args) {
    return rgb2cmyk(hwb2rgb(args));
  }

  function hwb2keyword(args) {
    return rgb2keyword(hwb2rgb(args));
  }

  function cmyk2rgb(cmyk) {
    var c = cmyk[0] / 100,
        m = cmyk[1] / 100,
        y = cmyk[2] / 100,
        k = cmyk[3] / 100,
        r, g, b;

    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  }

  function cmyk2hsl(args) {
    return rgb2hsl(cmyk2rgb(args));
  }

  function cmyk2hsv(args) {
    return rgb2hsv(cmyk2rgb(args));
  }

  function cmyk2hwb(args) {
    return rgb2hwb(cmyk2rgb(args));
  }

  function cmyk2keyword(args) {
    return rgb2keyword(cmyk2rgb(args));
  }


  function xyz2rgb(xyz) {
    var x = xyz[0] / 100,
        y = xyz[1] / 100,
        z = xyz[2] / 100,
        r, g, b;

    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

    // assume sRGB
    r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
      : r = (r * 12.92);

    g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
      : g = (g * 12.92);

    b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
      : b = (b * 12.92);

    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);

    return [r * 255, g * 255, b * 255];
  }

  function xyz2lab(xyz) {
    var x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

    x /= 95.047;
    y /= 100;
    z /= 108.883;

    x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
    y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
    z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

    l = (116 * y) - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);

    return [l, a, b];
  }

  function xyz2lch(args) {
    return lab2lch(xyz2lab(args));
  }

  function lab2xyz(lab) {
    var l = lab[0],
        a = lab[1],
        b = lab[2],
        x, y, z, y2;

    if (l <= 8) {
      y = (l * 100) / 903.3;
      y2 = (7.787 * (y / 100)) + (16 / 116);
    } else {
      y = 100 * Math.pow((l + 16) / 116, 3);
      y2 = Math.pow(y / 100, 1/3);
    }

    x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

    z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

    return [x, y, z];
  }

  function lab2lch(lab) {
    var l = lab[0],
        a = lab[1],
        b = lab[2],
        hr, h, c;

    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  }

  function lab2rgb(args) {
    return xyz2rgb(lab2xyz(args));
  }

  function lch2lab(lch) {
    var l = lch[0],
        c = lch[1],
        h = lch[2],
        a, b, hr;

    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  }

  function lch2xyz(args) {
    return lab2xyz(lch2lab(args));
  }

  function lch2rgb(args) {
    return lab2rgb(lch2lab(args));
  }

  function keyword2rgb(keyword) {
    return cssKeywords[keyword];
  }

  function keyword2hsl(args) {
    return rgb2hsl(keyword2rgb(args));
  }

  function keyword2hsv(args) {
    return rgb2hsv(keyword2rgb(args));
  }

  function keyword2hwb(args) {
    return rgb2hwb(keyword2rgb(args));
  }

  function keyword2cmyk(args) {
    return rgb2cmyk(keyword2rgb(args));
  }

  function keyword2lab(args) {
    return rgb2lab(keyword2rgb(args));
  }

  function keyword2xyz(args) {
    return rgb2xyz(keyword2rgb(args));
  }

  var cssKeywords = {
    aliceblue:  [240,248,255],
    antiquewhite: [250,235,215],
    aqua: [0,255,255],
    aquamarine: [127,255,212],
    azure:  [240,255,255],
    beige:  [245,245,220],
    bisque: [255,228,196],
    black:  [0,0,0],
    blanchedalmond: [255,235,205],
    blue: [0,0,255],
    blueviolet: [138,43,226],
    brown:  [165,42,42],
    burlywood:  [222,184,135],
    cadetblue:  [95,158,160],
    chartreuse: [127,255,0],
    chocolate:  [210,105,30],
    coral:  [255,127,80],
    cornflowerblue: [100,149,237],
    cornsilk: [255,248,220],
    crimson:  [220,20,60],
    cyan: [0,255,255],
    darkblue: [0,0,139],
    darkcyan: [0,139,139],
    darkgoldenrod:  [184,134,11],
    darkgray: [169,169,169],
    darkgreen:  [0,100,0],
    darkgrey: [169,169,169],
    darkkhaki:  [189,183,107],
    darkmagenta:  [139,0,139],
    darkolivegreen: [85,107,47],
    darkorange: [255,140,0],
    darkorchid: [153,50,204],
    darkred:  [139,0,0],
    darksalmon: [233,150,122],
    darkseagreen: [143,188,143],
    darkslateblue:  [72,61,139],
    darkslategray:  [47,79,79],
    darkslategrey:  [47,79,79],
    darkturquoise:  [0,206,209],
    darkviolet: [148,0,211],
    deeppink: [255,20,147],
    deepskyblue:  [0,191,255],
    dimgray:  [105,105,105],
    dimgrey:  [105,105,105],
    dodgerblue: [30,144,255],
    firebrick:  [178,34,34],
    floralwhite:  [255,250,240],
    forestgreen:  [34,139,34],
    fuchsia:  [255,0,255],
    gainsboro:  [220,220,220],
    ghostwhite: [248,248,255],
    gold: [255,215,0],
    goldenrod:  [218,165,32],
    gray: [128,128,128],
    green:  [0,128,0],
    greenyellow:  [173,255,47],
    grey: [128,128,128],
    honeydew: [240,255,240],
    hotpink:  [255,105,180],
    indianred:  [205,92,92],
    indigo: [75,0,130],
    ivory:  [255,255,240],
    khaki:  [240,230,140],
    lavender: [230,230,250],
    lavenderblush:  [255,240,245],
    lawngreen:  [124,252,0],
    lemonchiffon: [255,250,205],
    lightblue:  [173,216,230],
    lightcoral: [240,128,128],
    lightcyan:  [224,255,255],
    lightgoldenrodyellow: [250,250,210],
    lightgray:  [211,211,211],
    lightgreen: [144,238,144],
    lightgrey:  [211,211,211],
    lightpink:  [255,182,193],
    lightsalmon:  [255,160,122],
    lightseagreen:  [32,178,170],
    lightskyblue: [135,206,250],
    lightslategray: [119,136,153],
    lightslategrey: [119,136,153],
    lightsteelblue: [176,196,222],
    lightyellow:  [255,255,224],
    lime: [0,255,0],
    limegreen:  [50,205,50],
    linen:  [250,240,230],
    magenta:  [255,0,255],
    maroon: [128,0,0],
    mediumaquamarine: [102,205,170],
    mediumblue: [0,0,205],
    mediumorchid: [186,85,211],
    mediumpurple: [147,112,219],
    mediumseagreen: [60,179,113],
    mediumslateblue:  [123,104,238],
    mediumspringgreen:  [0,250,154],
    mediumturquoise:  [72,209,204],
    mediumvioletred:  [199,21,133],
    midnightblue: [25,25,112],
    mintcream:  [245,255,250],
    mistyrose:  [255,228,225],
    moccasin: [255,228,181],
    navajowhite:  [255,222,173],
    navy: [0,0,128],
    oldlace:  [253,245,230],
    olive:  [128,128,0],
    olivedrab:  [107,142,35],
    orange: [255,165,0],
    orangered:  [255,69,0],
    orchid: [218,112,214],
    palegoldenrod:  [238,232,170],
    palegreen:  [152,251,152],
    paleturquoise:  [175,238,238],
    palevioletred:  [219,112,147],
    papayawhip: [255,239,213],
    peachpuff:  [255,218,185],
    peru: [205,133,63],
    pink: [255,192,203],
    plum: [221,160,221],
    powderblue: [176,224,230],
    purple: [128,0,128],
    rebeccapurple: [102, 51, 153],
    red:  [255,0,0],
    rosybrown:  [188,143,143],
    royalblue:  [65,105,225],
    saddlebrown:  [139,69,19],
    salmon: [250,128,114],
    sandybrown: [244,164,96],
    seagreen: [46,139,87],
    seashell: [255,245,238],
    sienna: [160,82,45],
    silver: [192,192,192],
    skyblue:  [135,206,235],
    slateblue:  [106,90,205],
    slategray:  [112,128,144],
    slategrey:  [112,128,144],
    snow: [255,250,250],
    springgreen:  [0,255,127],
    steelblue:  [70,130,180],
    tan:  [210,180,140],
    teal: [0,128,128],
    thistle:  [216,191,216],
    tomato: [255,99,71],
    turquoise:  [64,224,208],
    violet: [238,130,238],
    wheat:  [245,222,179],
    white:  [255,255,255],
    whitesmoke: [245,245,245],
    yellow: [255,255,0],
    yellowgreen:  [154,205,50]
  };

  var reverseKeywords = {};
  for (var key in cssKeywords) {
    reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
  }

  var convert = function() {
     return new Converter();
  };

  for (var func in conversions) {
    // export Raw versions
    convert[func + "Raw"] =  (function(func) {
      // accept array or plain args
      return function(arg) {
        if (typeof arg == "number")
          arg = Array.prototype.slice.call(arguments);
        return conversions[func](arg);
      }
    })(func);

    var pair = /(\w+)2(\w+)/.exec(func),
        from$1 = pair[1],
        to = pair[2];

    // export rgb2hsl and ["rgb"]["hsl"]
    convert[from$1] = convert[from$1] || {};

    convert[from$1][to] = convert[func] = (function(func) { 
      return function(arg) {
        if (typeof arg == "number")
          arg = Array.prototype.slice.call(arguments);
        
        var val = conversions[func](arg);
        if (typeof val == "string" || val === undefined)
          return val; // keyword

        for (var i = 0; i < val.length; i++)
          val[i] = Math.round(val[i]);
        return val;
      }
    })(func);
  }


  /* Converter does lazy conversion and caching */
  var Converter = function() {
     this.convs = {};
  };

  /* Either get the values for a space or
    set the values for a space, depending on args */
  Converter.prototype.routeSpace = function(space, args) {
     var values = args[0];
     if (values === undefined) {
        // color.rgb()
        return this.getValues(space);
     }
     // color.rgb(10, 10, 10)
     if (typeof values == "number") {
        values = Array.prototype.slice.call(args);        
     }

     return this.setValues(space, values);
  };
    
  /* Set the values for a space, invalidating cache */
  Converter.prototype.setValues = function(space, values) {
     this.space = space;
     this.convs = {};
     this.convs[space] = values;
     return this;
  };

  /* Get the values for a space. If there's already
    a conversion for the space, fetch it, otherwise
    compute it */
  Converter.prototype.getValues = function(space) {
     var vals = this.convs[space];
     if (!vals) {
        var fspace = this.space,
            from = this.convs[fspace];
        vals = convert[fspace][space](from);

        this.convs[space] = vals;
     }
    return vals;
  };

  ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
     Converter.prototype[space] = function(vals) {
        return this.routeSpace(space, arguments);
     };
  });

  var colorConvert = convert;

  var parseColor = function (cstr) {
      var m, conv, parts, alpha;
      if (m = /^((?:rgb|hs[lv]|cmyk|xyz|lab)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
          var name = m[1];
          var base = name.replace(/a$/, '');
          var size$$1 = base === 'cmyk' ? 4 : 3;
          conv = colorConvert[base];
          
          parts = m[2].replace(/^\s+|\s+$/g, '')
              .split(/\s*,\s*/)
              .map(function (x, i) {
                  if (/%$/.test(x) && i === size$$1) {
                      return parseFloat(x) / 100;
                  }
                  else if (/%$/.test(x)) {
                      return parseFloat(x);
                  }
                  return parseFloat(x);
              })
          ;
          if (name === base) parts.push(1);
          alpha = parts[size$$1] === undefined ? 1 : parts[size$$1];
          parts = parts.slice(0, size$$1);
          
          conv[base] = function () { return parts };
      }
      else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
          var base = cstr.replace(/^#/,'');
          var size$$1 = base.length;
          conv = colorConvert.rgb;
          parts = base.split(size$$1 === 3 ? /(.)/ : /(..)/);
          parts = parts.filter(Boolean)
              .map(function (x) {
                  if (size$$1 === 3) {
                      return parseInt(x + x, 16);
                  }
                  else {
                      return parseInt(x, 16)
                  }
              })
          ;
          alpha = 1;
          conv.rgb = function () { return parts };
          if (!parts[0]) parts[0] = 0;
          if (!parts[1]) parts[1] = 0;
          if (!parts[2]) parts[2] = 0;
      }
      else {
          conv = colorConvert.keyword;
          conv.keyword = function () { return cstr };
          parts = cstr;
          alpha = 1;
      }
      
      var res = {
          rgb: undefined,
          hsl: undefined,
          hsv: undefined,
          cmyk: undefined,
          keyword: undefined,
          hex: undefined
      };
      try { res.rgb = conv.rgb(parts); } catch (e) {}
      try { res.hsl = conv.hsl(parts); } catch (e) {}
      try { res.hsv = conv.hsv(parts); } catch (e) {}
      try { res.cmyk = conv.cmyk(parts); } catch (e) {}
      try { res.keyword = conv.keyword(parts); } catch (e) {}
      
      if (res.rgb) res.hex = '#' + res.rgb.map(function (x) {
          var s = x.toString(16);
          if (s.length === 1) return '0' + s;
          return s;
      }).join('');
      
      if (res.rgb) res.rgba = res.rgb.concat(alpha);
      if (res.hsl) res.hsla = res.hsl.concat(alpha);
      if (res.hsv) res.hsva = res.hsv.concat(alpha);
      if (res.cmyk) res.cmyka = res.cmyk.concat(alpha);
      
      return res;
  };

  /**
   * @return {VlStyle[]}
   */

  function defaultStyle() {
    return [{
      fillColor: [255, 255, 255, 0.4],
      strokeColor: '#3399CC',
      strokeWidth: 1.25,
      imageRadius: 5
    }];
  }
  /**
   * @return {Object<GEOMETRY_TYPE, VlStyle[]>}
   */

  function defaultEditStyle() {
    /** @type {Object<GEOMETRY_TYPE, VlStyle[]>} */
    var styles = {};
    var white = [255, 255, 255, 1];
    var blue = [0, 153, 255, 1];
    var width = 3;
    styles[GEOMETRY_TYPE.LINE_STRING] = [{
      strokeColor: white,
      strokeWidth: width + 2
    }, {
      strokeColor: blue,
      strokeWidth: width
    }];
    styles[GEOMETRY_TYPE.MULTI_LINE_STRING] = styles[GEOMETRY_TYPE.LINE_STRING];
    styles[GEOMETRY_TYPE.POLYGON] = [{
      fillColor: [255, 255, 255, 0.5]
    }].concat(styles[GEOMETRY_TYPE.LINE_STRING]);
    styles[GEOMETRY_TYPE.MULTI_POLYGON] = styles[GEOMETRY_TYPE.POLYGON];
    styles[GEOMETRY_TYPE.CIRCLE] = styles[GEOMETRY_TYPE.POLYGON].concat(styles[GEOMETRY_TYPE.LINE_STRING]);
    styles[GEOMETRY_TYPE.POINT] = [{
      imageRadius: width * 2,
      fillColor: blue,
      strokeColor: white,
      strokeWidth: width / 2,
      zIndex: Infinity
    }];
    styles[GEOMETRY_TYPE.MULTI_POINT] = styles[GEOMETRY_TYPE.POINT];
    styles[GEOMETRY_TYPE.GEOMETRY_COLLECTION] = styles[GEOMETRY_TYPE.POLYGON].concat(styles[GEOMETRY_TYPE.LINE_STRING], styles[GEOMETRY_TYPE.POINT]);
    return styles;
  }

  var isEmpty$1 = function isEmpty$$1(x) {
    if (x == null) return true;
    if (typeof x === 'number') return false;
    return (typeof x === 'string' || isArray$1(x)) && !x.length || !keys$1(x).length;
  };
  /**
   * @param {VlStyle} vlStyle
   * @return {Style|undefined}
   */


  function createStyle(vlStyle) {
    if (isEmpty$1(vlStyle)) return;
    var olStyle = {
      text: createTextStyle(vlStyle),
      fill: createFillStyle(vlStyle),
      stroke: createStrokeStyle(vlStyle),
      image: createImageStyle(vlStyle),
      geometry: createGeomStyle(vlStyle),
      zIndex: vlStyle.zIndex
    };

    if (!isEmpty$1(olStyle)) {
      return new Style(olStyle);
    }
  }

  var addPrefix = function addPrefix(prefix) {
    return function (str) {
      return prefix + (prefix ? upperFirst(str) : str);
    };
  };
  /**
   * @param {*} color
   * @returns {*}
   */


  function normalizeColor(color) {
    var c = color;

    if (typeof color === 'string') {
      c = parseColor(color).rgba;
    }

    return c;
  }
  /**
   * @param {VlStyle} vlStyle
   * @param {string} [prefix]
   * @returns {Fill|undefined}
   */

  function createFillStyle(vlStyle) {
    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var prefixKey = addPrefix(prefix);
    var keys = ['fillColor'].map(prefixKey);
    var compiledKey = prefixKey('fill'); // check on already compiled style existence

    if (vlStyle[compiledKey] instanceof Fill) return vlStyle[compiledKey];
    var fillStyle = reduce(vlStyle, function (style, value, name) {
      if (keys.includes(name) === false) {
        return style;
      }

      name = lowerFirst(name.replace(new RegExp(prefixKey('fill')), ''));

      if (name === 'color') {
        value = normalizeColor(value);
      }

      style[name] = value;
      return style;
    }, {});

    if (!isEmpty$1(fillStyle)) {
      return new Fill(fillStyle);
    }
  }
  /**
   * @param {VlStyle} vlStyle
   * @param {string} [prefix]
   * @returns {Stroke|undefined}
   */

  function createStrokeStyle(vlStyle) {
    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var prefixKey = addPrefix(prefix);
    var keys = ['strokeColor', 'strokeWidth', 'strokeDash', 'strokeCap', 'strokeJoin'].map(prefixKey);
    var compiledKey = prefixKey('stroke');
    if (vlStyle[compiledKey] instanceof Stroke) return vlStyle[compiledKey];
    var strokeStyle = reduce(vlStyle, function (style, value, name) {
      if (keys.includes(name) === false) {
        return style;
      }

      switch (name) {
        case prefixKey('strokeColor'):
        case prefixKey('strokeWidth'):
          name = lowerFirst(name.replace(new RegExp(prefixKey('stroke')), ''));
          break;

        case prefixKey('strokeDash'):
        case prefixKey('strokeCap'):
        case prefixKey('strokeJoin'):
          name = 'line' + name.replace(new RegExp(prefixKey('stroke')), '');
          break;
      }

      if (name === 'color') {
        value = normalizeColor(value);
      }

      style[name] = value;
      return style;
    }, {});

    if (!isEmpty$1(strokeStyle)) {
      return new Stroke(strokeStyle);
    }
  }
  /**
   * @param {VlStyle} vlStyle
   * @returns {Image|undefined}
   * @todo split to separate circle, regShape, Icon
   */

  function createImageStyle(vlStyle) {
    if (isEmpty$1(vlStyle.imageSrc) && isEmpty$1(vlStyle.image) && isEmpty$1(vlStyle.imagePoints) && !isNumeric(vlStyle.imageRadius)) {
      return;
    }

    if (vlStyle.image instanceof ImageStyle) return vlStyle.image;
    var imageStyle, Ctor;

    if (!isEmpty$1(vlStyle.imageSrc) || !isEmpty$1(vlStyle.image)) {
      // icon construction
      Ctor = Icon; // then create Icon options

      imageStyle = _objectSpread({}, vlStyle, {
        anchor: vlStyle.imageAnchor,
        anchorOrigin: vlStyle.imageAnchorOrigin,
        color: vlStyle.imageColor,
        offset: vlStyle.imageOffset,
        offsetOrigin: vlStyle.imageOffsetOrigin,
        opacity: vlStyle.imageOpacity,
        scale: vlStyle.imageScale,
        rotation: vlStyle.imageRotation,
        size: vlStyle.imageSize,
        img: vlStyle.image,
        imgSize: vlStyle.imageImgSize,
        src: vlStyle.imageSrc,
        crossOrigin: vlStyle.imageCrossOrigin
      });
    } else if (vlStyle.imagePoints != null) {
      // regular shape construction
      Ctor = RegularShape; // create RegularShape options

      imageStyle = _objectSpread({}, vlStyle, {
        points: vlStyle.imagePoints,
        radius: vlStyle.imageRadius,
        radius1: vlStyle.imageRadius1,
        radius2: vlStyle.imageRadius2,
        angle: vlStyle.imageAngle,
        rotation: vlStyle.imageRotation
      });
    } else {
      // circle construction
      Ctor = Circle$1; // create Circle options

      imageStyle = _objectSpread({}, vlStyle, {
        radius: vlStyle.imageRadius
      });
    }

    imageStyle = _objectSpread({}, imageStyle, {
      fill: createFillStyle(vlStyle, 'image') || createFillStyle(vlStyle),
      stroke: createStrokeStyle(vlStyle, 'image') || createStrokeStyle(vlStyle),
      snapToPixel: true
    });

    if (!isEmpty$1(imageStyle)) {
      return new Ctor(imageStyle);
    }
  }
  /**
   * @param {VlStyle} vlStyle
   * @returns {Text|undefined}
   */

  function createTextStyle(vlStyle) {
    // noinspection JSValidateTypes
    if (vlStyle.text == null) return;
    if (vlStyle.text instanceof Text) return vlStyle.text;
    var textStyle = {
      text: vlStyle.text
    };
    var fontSize = vlStyle.textFontSize ? vlStyle.textFontSize + 'px' : undefined;
    var font = ['normal', fontSize, vlStyle.textFont].filter(function (x) {
      return !!x;
    }).join(' ');

    assign$1(textStyle, pick(['textAlign', 'textBaseline'], vlStyle), {
      font: font,
      fill: createFillStyle(vlStyle, 'text') || createFillStyle(vlStyle),
      stroke: createStrokeStyle(vlStyle, 'text') || createStrokeStyle(vlStyle),
      scale: vlStyle.textScale,
      rotation: vlStyle.textRotation,
      offsetX: vlStyle.textOffsetX,
      offsetY: vlStyle.textOffsetY,
      rotateWithView: vlStyle.textRotateWithView,
      padding: vlStyle.textPadding,
      maxAngle: vlStyle.textMaxAngle,
      overflow: vlStyle.textOverflow,
      placement: vlStyle.textPlacement,
      backgroundFill: createFillStyle(vlStyle, 'textBackground'),
      backgroundStroke: createStrokeStyle(vlStyle, 'textBackground')
    });

    if (!isEmpty$1(textStyle)) {
      return new Text(textStyle);
    }
  }
  /**
   * @param {VlStyle} vlStyle
   * @return {Geometry|function|undefined}
   */

  function createGeomStyle(vlStyle) {
    if (isFunction(vlStyle.geom)) {
      return function __styleGeomFunc(feature) {
        return vlStyle.geom(feature, geomHelper);
      };
    }

    return vlStyle.geom;
  }
  /**
   * @typedef {Style|Image|Fill|Stroke|Text|StyleFunction} OlStyle
   */

  /**
   * @typedef {Object} VlStyle
   *
   * Shared
   * @property {string|number[]|undefined} fillColor
   * @property {string|number[]|undefined} strokeColor
   * @property {number|undefined} strokeWidth
   * @property {number[]|undefined} strokeDash
   * @property {string|undefined} strokeCap
   * @property {string|undefined} strokeJoin
   * @property {number|undefined} zIndex
   * @property {Fill|undefined} fill
   * @property {Stroke|undefined} stroke
   *
   * Text only
   * @property {string|Text|undefined} text
   * @property {string|undefined} textFont
   * @property {number|undefined} textFontSize
   * @property {string|number[]|undefined} textFillColor
   * @property {string|number[]|undefined} textStrokeColor
   * @property {number|undefined} textStrokeWidth
   * @property {number[]|undefined} textStrokeDash
   * @property {string|undefined} textStrokeCap
   * @property {string|undefined} textStrokeJoin
   * @property {number|undefined} textScale
   * @property {string|undefined} textAlign
   * @property {number|undefined} textRotation
   * @property {number|undefined} textOffsetX
   * @property {number|undefined} textOffsetY
   * @property {Stroke|undefined} textStroke
   * @property {Fill|undefined} textFill
   * @property {boolean|undefined} textRotateWithView
   * @property {number[]|undefined} textPadding
   * @property {number|undefined} textMaxAngle
   * @property {boolean|undefined} textOverflow
   * @property {string|undefined} textPlacement
   * @property {string|undefined} textBaseline
   * @property {Fill|undefined} textBackgroundFillColor
   * @property {Stroke|undefined} textBackgroundStrokeColor
   * @property {Stroke|undefined} textBackgroundStrokeWidth
   * @property {Stroke|undefined} textBackgroundStrokeDash
   * @property {Stroke|undefined} textBackgroundStrokeCap
   * @property {Stroke|undefined} textBackgroundStrokeJoin
   *
   * Image only
   * @property {Image|undefined} image
   * @property {string|undefined} imageSrc
   * @property {number[]|undefined} imageSize
   * @property {number[]|undefined} imageImgSize
   * @property {number|undefined} imageOffset
   * @property {number[]|undefined} imageAnchor
   * @property {number|undefined} imageScale
   * @property {number|undefined} imageRotation
   * @property {number|undefined} imageRadius
   * @property {number|undefined} imageRadius1
   * @property {number|undefined} imageRadius2
   * @property {number|undefined} imagePoints
   * @property {number|undefined} imageAngle
   * @property {number|undefined} imageOpacity
   * @property {string|number[]|undefined} imageFillColor
   * @property {string|number[]|undefined} imageStrokeColor
   * @property {number|undefined} imageStrokeWidth
   * @property {number[]|undefined} imageStrokeDash
   * @property {string|undefined} imageStrokeCap
   * @property {string|undefined} imageStrokeJoin
   * @property {IconOrigin|undefined} imageAnchorOrigin
   * @property {ColorLike|undefined} imageColor
   * @property {IconOrigin|undefined} imageOffsetOrigin
   * @property {Stroke|undefined} imageStroke
   * @property {Fill|undefined} imageFill
   * @property {string|undefined} imageCrossOrigin
   *
   * @property {Geometry|function|undefined} geom Coordinates should be in map projection
   */

  /**
   * @module ol-ext
   */

  var olExt = /*#__PURE__*/Object.freeze({
    IndexedCollectionAdapter: IndexedCollectionAdapter,
    SourceCollectionAdapter: SourceCollectionAdapter,
    EPSG_4326: EPSG_4326,
    EPSG_3857: EPSG_3857,
    MAX_ZOOM: MAX_ZOOM,
    MIN_ZOOM: MIN_ZOOM,
    TILE_SIZE: TILE_SIZE,
    TILE_FORMAT: TILE_FORMAT,
    ZOOM_FACTOR: ZOOM_FACTOR,
    CACHE_SIZE: CACHE_SIZE,
    PIXEL_RATIO: PIXEL_RATIO,
    CROSS_ORIGIN: CROSS_ORIGIN,
    REPROJ_ERR_THRESHOLD: REPROJ_ERR_THRESHOLD,
    EARTH_RADIUS: EARTH_RADIUS,
    RENDERER_TYPE: RENDERER_TYPE,
    GEOMETRY_TYPE: GEOMETRY_TYPE,
    EXTENT_CORNER: EXTENT_CORNER,
    PROJ_UNIT: PROJ_UNIT,
    OVERLAY_POSITIONING: OVERLAY_POSITIONING,
    WMS_VERSION: WMS_VERSION,
    WMTS_VERSION: WMTS_VERSION,
    WMTS_REQUEST_ENCODING: WMTS_REQUEST_ENCODING,
    WMTS_FORMAT: WMTS_FORMAT,
    LAYER_PROP: LAYER_PROP,
    getExtentCenter: extent.getCenter,
    getExtentWidth: extent.getWidth,
    getExtentHeight: extent.getHeight,
    boundingExtent: extent.boundingExtent,
    createOrUpdateExtent: createOrUpdateExtent,
    getExtentCorner: getExtentCorner,
    createExtentFromProjection: createExtentFromProjection,
    initFeature: initFeature,
    getFeatureId: getFeatureId,
    createGeoJsonFmt: createGeoJsonFmt,
    createTopoJsonFmt: createTopoJsonFmt,
    createMvtFmt: createMvtFmt,
    writeGeoJsonFeature: writeGeoJsonFeature,
    readGeoJsonFeature: readGeoJsonFeature,
    writeGeoJsonGeometry: writeGeoJsonGeometry,
    readGeoJsonGeometry: readGeoJsonGeometry,
    readProjection: readProjection,
    createPointGeom: createPointGeom,
    createLineGeom: createLineGeom,
    createPolygonGeom: createPolygonGeom,
    createMultiPointGeom: createMultiPointGeom,
    createMultiLineGeom: createMultiLineGeom,
    createMultiPolygonGeom: createMultiPolygonGeom,
    createGeomCollection: createGeomCollection,
    createCircularPolygon: createCircularPolygon,
    isMultiGeom: isMultiGeom,
    toSimpleGeom: toSimpleGeom,
    findPointOnSurface: findPointOnSurface,
    loadingAll: loadingstrategy.all,
    loadingBBox: loadingstrategy.bbox,
    loadingTile: loadingstrategy.tile,
    transform: proj.transform,
    transformExtent: proj.transformExtent,
    getProj: proj.get,
    addProj: proj.addProjection,
    createProj: createProj,
    pointToLonLat: pointToLonLat,
    pointFromLonLat: pointFromLonLat,
    transformPoint: transformPoint,
    lineToLonLat: lineToLonLat,
    lineFromLonLat: lineFromLonLat,
    transformLine: transformLine,
    polygonToLonLat: polygonToLonLat,
    polygonFromLonLat: polygonFromLonLat,
    transformPolygon: transformPolygon,
    multiPointToLonLat: multiPointToLonLat,
    multiPointFromLonLat: multiPointFromLonLat,
    transformMultiPoint: transformMultiPoint,
    multiLineToLonLat: multiLineToLonLat,
    multiLineFromLonLat: multiLineFromLonLat,
    transformMultiLine: transformMultiLine,
    multiPolygonToLonLat: multiPolygonToLonLat,
    multiPolygonFromLonLat: multiPolygonFromLonLat,
    transformMultiPolygon: transformMultiPolygon,
    transforms: transforms,
    extentFromLonLat: extentFromLonLat,
    extentToLonLat: extentToLonLat,
    defaultStyle: defaultStyle,
    defaultEditStyle: defaultEditStyle,
    createStyle: createStyle,
    normalizeColor: normalizeColor,
    createFillStyle: createFillStyle,
    createStrokeStyle: createStrokeStyle,
    createImageStyle: createImageStyle,
    createTextStyle: createTextStyle,
    createGeomStyle: createGeomStyle,
    createXyzGrid: tilegrid.createXYZ,
    resolutionsFromExtent: resolutionsFromExtent,
    createGridForExtent: createGridForExtent,
    createGridForProjection: createGridForProjection,
    isCollection: isCollection,
    isVectorSource: isVectorSource,
    isCircle: isCircle
  });

  var _cleanExtParams$1 = function cleanExtParams(params) {
    return reduce(params, function (params, value, key) {
      var filterKeys = ['LAYERS', 'VERSION', 'STYLES', 'FORMAT', 'TRANSPARENT', 'BGCOLOR', 'TIME'];
      key = key.toUpperCase();

      if (filterKeys.includes(key)) {
        return params;
      }

      params[key] = value;
      return params;
    }, {});
  };

  var props$b = {
    /**
     * Extra WMS request parameters
     */
    extParams: Object,
    layers: {
      type: String,
      required: true
    },
    styles: String,
    // WMS Request styles
    version: {
      type: String,
      default: WMS_VERSION
    },
    transparent: {
      type: Boolean,
      default: true
    },
    format: {
      type: String,
      default: 'image/png'
    },
    bgColor: String,
    time: String
  };
  var computed$4 = {
    cleanExtParams: function cleanExtParams() {
      return this.extParams ? _cleanExtParams$1(this.extParams) : undefined;
    },
    allParams: function allParams() {
      return _objectSpread({}, this.cleanExtParams, {
        LAYERS: this.layers,
        STYLES: this.styles,
        VERSION: this.version,
        FORMAT: this.format,
        TRANSPARENT: this.transparent,
        BGCOLOR: this.bgColor,
        TIME: this.time
      });
    }
  };
  var methods$j = {
    /**
     * @param {number[]} coordinate
     * @param {number} [resolution]
     * @param {string} [projection]
     * @param {Object} [params] GetFeatureInfo params. `info_format` at least should be provided.
     *                          If `query_layers` is not provided then the layers specified in the `layers` prop will be used.
     *                          `version` should not be specified here (value from `version` prop will be used).
     * @return {string|undefined}
     */
    getFeatureInfoUrl: function getFeatureInfoUrl(coordinate, resolution, projection) {
      var params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      hasView(this);
      hasSource(this);
      resolution || (resolution = this.$view.getResolution());
      projection || (projection = this.projection);
      params = _objectSpread({}, this.allParams, params);
      return this.$source.getGetFeatureInfoUrl(coordinate, resolution, projection, params);
    }
  };
  var watch$7 = {
    layers: function layers(LAYERS) {
      this.$source && this.$source.updateParams({
        LAYERS: LAYERS
      });
    },
    version: function version(VERSION) {
      this.$source && this.$source.updateParams({
        VERSION: VERSION
      });
    },
    styles: function styles(STYLES) {
      this.$source && this.$source.updateParams({
        STYLES: STYLES
      });
    },
    transparent: function transparent(TRANSPARENT) {
      this.$source && this.$source.updateParams({
        TRANSPARENT: TRANSPARENT
      });
    },
    time: function time(TIME) {
      this.$source && this.$source.updateParams({
        TIME: TIME
      });
    },
    bgColor: function bgColor(BGCOLOR) {
      this.$source && this.$source.updateParams({
        BGCOLOR: BGCOLOR
      });
    },
    extParams: function extParams(value) {
      this.$source && this.$source.updateParams(value ? _cleanExtParams$1(value) : undefined);
    }
  };
  var wmsSource = {
    props: props$b,
    computed: computed$4,
    methods: methods$j,
    watch: watch$7
  };

  var methods$k = {
    /**
     * @return {XYZ}
     * @protected
     */
    createSource: function createSource() {
      return new XYZSource({
        attributions: this.attributions,
        cacheSize: this.cacheSize,
        crossOrigin: this.crossOrigin,
        maxZoom: this.maxZoom,
        minZoom: this.minZoom,
        opaque: this.opaque,
        projection: this.projection,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        tileGrid: this._tileGrid,
        tilePixelRatio: this.tilePixelRatio,
        tileUrlFunction: this.createUrlFunc(),
        tileLoadFunction: this.tileLoadFunction,
        wrapX: this.wrapX,
        transition: this.transition
      });
    }
  };
  var watch$8 = {};
  var xyzSource = {
    mixins: [tileSource],
    methods: methods$k,
    watch: watch$8
  };

  var props$c = {
    url: {
      type: String,
      required: true,
      validator: function validator(value) {
        return !!value.length;
      }
    }
  };
  var methods$l = {
    createSource: function createSource() {
      return new TileArcGISRestSource({
        attributions: this.attributions,
        cacheSize: this.cacheSize,
        crossOrigin: this.crossOrigin,
        params: this.allParams,
        logo: this.logo,
        tileGrid: this._tileGrid,
        projection: this.projection,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        tileLoadFunction: this.tileLoadFunction,
        url: this.urlTmpl,
        wrapX: this.wrapX,
        transition: this.transition
      });
    }
  };
  var script = {
    name: 'vl-source-arcgis-rest',
    mixins: [tileSource, arcgisSource],
    props: props$c,
    methods: methods$l
  };

  /* script */
  var __vue_script__ = script;
  /* template */

  /* style */

  var __vue_inject_styles__ = undefined;
  /* scoped */

  var __vue_scope_id__ = undefined;
  /* module identifier */

  var __vue_module_identifier__ = undefined;
  /* functional template */

  var __vue_is_functional_template__ = undefined;
  /* component normalizer */

  function __vue_normalize__(template, style, script$$1, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source = __vue_normalize__({}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, undefined, undefined);

  function plugin(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin.installed) {
      return;
    }

    plugin.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source, options);

    Vue$$1.component(Source.name, Source);
  }

  var ArcgisRestSource = /*#__PURE__*/Object.freeze({
    default: plugin,
    Source: Source,
    install: plugin
  });

  var BINGMAPS_MAX_ZOOM = 21;
  var BINGMAPS_CULTURE = 'en-us';
  var props$d = {
    /**
     * Enables hidpi tiles.
     * @type {boolean}
     */
    hidpi: {
      type: Boolean,
      default: false
    },

    /**
     * Culture code.
     * @type {string}
     */
    culture: {
      type: String,
      default: BINGMAPS_CULTURE
    },

    /**
     * Bing Maps API key.
     * @type {string}
     */
    apiKey: {
      type: String,
      required: true
    },

    /**
     * Type of imagery.
     * @type {string}
     */
    imagerySet: {
      type: String,
      required: true
    },
    maxZoom: {
      type: Number,
      default: BINGMAPS_MAX_ZOOM
    },
    url: String
  };
  var methods$m = {
    /**
     * @return {BingMaps}
     * @protected
     */
    createSource: function createSource() {
      return new BingMapsSource({
        cacheSize: this.cacheSize,
        hidpi: this.hidpi,
        culture: this.culture,
        key: this.apiKey,
        imagerySet: this.imagerySet,
        maxZoom: this.maxZoom,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        wrapX: this.wrapX,
        transition: this.transition,
        tileLoadFunction: this.tileLoadFunction
      });
    }
  };
  var watch$9 = makeWatchers(['apiKey', 'imagerySet'], function () {
    return function () {
      this.scheduleRecreate();
    };
  });
  var script$1 = {
    name: 'vl-source-bingmaps',
    mixins: [tileSource],
    props: props$d,
    methods: methods$m,
    watch: watch$9
  };

  /* script */
  var __vue_script__$1 = script$1;
  /* template */

  /* style */

  var __vue_inject_styles__$1 = undefined;
  /* scoped */

  var __vue_scope_id__$1 = undefined;
  /* module identifier */

  var __vue_module_identifier__$1 = undefined;
  /* functional template */

  var __vue_is_functional_template__$1 = undefined;
  /* component normalizer */

  function __vue_normalize__$1(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$1 = __vue_normalize__$1({}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, undefined, undefined);

  /**
   * @param {Vue} Vue
   * @param {VueLayersOptions} [options]
   */

  function plugin$1(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$1.installed) {
      return;
    }

    plugin$1.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$1, options);

    Vue$$1.component(Source$1.name, Source$1);
  }

  var BingmapsSource = /*#__PURE__*/Object.freeze({
    default: plugin$1,
    Source: Source$1,
    install: plugin$1
  });

  /**
   * @vueProps
   */

  var props$e = {
    coordinates: {
      type: Array,
      required: true,
      validator: function validator(value) {
        return value.length === 2;
      }
    },
    radius: {
      type: Number,
      default: 0
    }
    /**
     * @vueComputed
     */

  };
  var computed$5 = {
    type: constant(GEOMETRY_TYPE.POINT),

    /**
     * @type {Array|undefined}
     */
    coordinatesViewProj: function coordinatesViewProj() {
      if (this.rev && this.$geometry) {
        return this.$geometry.getCenter();
      }
    }
  };
  /**
   * @vueMethods
   */

  var methods$n = {
    /**
     * @return {Circle}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new Circle(this.toViewProj(this.coordinates), this.radius);
    },

    /**
     * @return {Coordinate}
     */
    getCoordinates: function getCoordinates() {
      hasGeometry(this);
      return this.toDataProj(this.$geometry.getCenter());
    },

    /**
     * @param {Coordinate} coordinate
     */
    setCoordinates: function setCoordinates(coordinate) {
      hasGeometry(this);
      this.$geometry.setCenter(this.toViewProj(coordinate));
    }
  };
  var watch$a = {
    radius: function radius(value) {
      if (!this.$geometry) return;

      if (value !== this.$geometry.getRadius()) {
        this.$geometry.setRadius(value);
      }
    }
  };
  /**
   * @alias module:circle-geom/geom
   * @title vl-geom-circle
   * @vueProto
   */

  var script$2 = {
    name: 'vl-geom-circle',
    mixins: [geometry$3],
    props: props$e,
    computed: computed$5,
    methods: methods$n,
    watch: watch$a
  };

  /* script */
  var __vue_script__$2 = script$2;
  /* template */

  /* style */

  var __vue_inject_styles__$2 = undefined;
  /* scoped */

  var __vue_scope_id__$2 = undefined;
  /* module identifier */

  var __vue_module_identifier__$2 = undefined;
  /* functional template */

  var __vue_is_functional_template__$2 = undefined;
  /* component normalizer */

  function __vue_normalize__$2(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "geom.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Geom = __vue_normalize__$2({}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, undefined, undefined);

  function plugin$2(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$2.installed) {
      return;
    }

    plugin$2.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Geom, options);

    Vue$$1.component(Geom.name, Geom);
  }

  var CircleGeom = /*#__PURE__*/Object.freeze({
    default: plugin$2,
    Geom: Geom,
    install: plugin$2
  });

  var props$f = {
    radius: {
      type: Number,
      default: 5
    }
  };
  var methods$o = {
    /**
     * @return {ol.style.Circle}
     * @protected
     */
    createStyle: function createStyle() {
      return new Circle$1({
        radius: this.radius,
        fill: this._fill,
        stroke: this._stroke
      });
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(imageStyle.methods.getServices.call(this), {
        get stylesContainer() {
          return vm;
        }

      });
    },

    /**
     * @param {ol.style.Fill|Vue|undefined} fill
     * @return {void}
     */
    setFill: function setFill(fill) {
      fill = fill instanceof Vue ? fill.$style : fill;

      if (fill !== this._fill) {
        this._fill = fill;
        this.scheduleRefresh();
      }
    },

    /**
     * @param {ol.style.Stroke|Vue|undefined} stroke
     * @return {void}
     */
    setStroke: function setStroke(stroke) {
      stroke = stroke instanceof Vue ? stroke.$style : stroke;

      if (stroke !== this._stroke) {
        this._stroke = stroke;
        this.scheduleRefresh();
      }
    }
  };
  var watch$b = {
    radius: function radius(value) {
      if (this.$style && !isEqual(value, this.$style.getRadius())) {
        this.scheduleRefresh();
      }
    }
  };
  var script$3 = {
    name: 'vl-style-circle',
    mixins: [imageStyle, withFillStrokeStyle],
    props: props$f,
    methods: methods$o,
    watch: watch$b
  };

  /* script */
  var __vue_script__$3 = script$3;
  /* template */

  /* style */

  var __vue_inject_styles__$3 = undefined;
  /* scoped */

  var __vue_scope_id__$3 = undefined;
  /* module identifier */

  var __vue_module_identifier__$3 = undefined;
  /* functional template */

  var __vue_is_functional_template__$3 = undefined;
  /* component normalizer */

  function __vue_normalize__$3(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "style.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Style$1 = __vue_normalize__$3({}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, undefined, undefined);

  function plugin$3(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$3.installed) {
      return;
    }

    plugin$3.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Style$1, options);

    Vue$$1.component(Style$1.name, Style$1);
  }

  var CircleStyle = /*#__PURE__*/Object.freeze({
    default: plugin$3,
    Style: Style$1,
    install: plugin$3
  });

  var Builder =
  /*#__PURE__*/
  function () {
    function Builder() {
      _classCallCheck(this, Builder);
    }

    _createClass(Builder, [{
      key: "getSource",
      value: function getSource() {
        return this.source;
      }
      /**
       * @param {Vector|undefined} value
       * @returns {Builder}
       */

    }, {
      key: "setSource",
      value: function setSource(value) {
        this.source = value;
        return this;
      }
      /**
       * @param value
       * @returns {Builder}
       */

    }, {
      key: "setAttributions",
      value: function setAttributions(value) {
        this.attributions = value;
        return this;
      }
      /**
       * @param value
       * @returns {Builder}
       */

    }, {
      key: "setDistance",
      value: function setDistance(value) {
        this.distance = value;
        return this;
      }
      /**
       * @param value
       * @returns {Builder}
       */

    }, {
      key: "setGeometryFunction",
      value: function setGeometryFunction(value) {
        this.geometryFunction = value;
        return this;
      }
      /**
       * @param value
       * @returns {Builder}
       */

    }, {
      key: "setLogo",
      value: function setLogo(value) {
        this.logo = value;
        return this;
      }
      /**
       * @param value
       * @returns {Builder}
       */

    }, {
      key: "setProjection",
      value: function setProjection(value) {
        this.projection = value;
        return this;
      }
      /**
       * @param value
       * @returns {Builder}
       */

    }, {
      key: "setWrapX",
      value: function setWrapX(value) {
        this.wrapX = value;
        return this;
      }
      /**
       * @param key
       * @param value
       * @return {void}
       */

    }, {
      key: "set",
      value: function set(key, value) {
        this.values || (this.values = {});
        this.values[key] = value;
      }
      /**
       * @return {Cluster}
       */

    }, {
      key: "build",
      value: function build() {
        ok(this.source, 'source is provided');
        var source = new Cluster({
          attributions: this.attributions,
          distance: this.distance,
          geometryFunction: this.geometryFunction,
          logo: this.logo,
          projection: this.projection,
          source: this.source,
          wrapX: this.wrapX
        });
        source.setProperties(this.values);
        return source;
      }
      /**
       * @return {Promise<Cluster>}
       */

    }, {
      key: "promise",
      value: function promise() {
        var _this = this;

        return interval(100).pipe(skipWhile(function () {
          return !_this.source;
        }), first(), map$3(this.build.bind(this))).toPromise(promise$1);
      }
    }]);

    return Builder;
  }();

  var props$g = {
    distance: {
      type: Number,
      default: 20
    },

    /**
     * Geometry function factory
     * @type {function(): (function(f: ol.Feature): ol.geom.SimpleGeometry|undefined)} geomFuncFactory
     */
    geomFuncFactory: {
      type: Function,
      default: defaultGeomFuncFactory
    }
  };
  var computed$6 = {
    geomFunc: function geomFunc() {
      return this.geomFuncFactory();
    }
  };
  var methods$p = {
    /**
     * @return {Promise<ol.source.Cluster>}
     * @protected
     */
    createSource: function createSource() {
      // partial setup of ol.source.Cluster with the help of SourceBuilder class

      /**
       * @type {SourceBuilder}
       * @private
       */
      this._sourceBuilder = new Builder().setAttributions(this.attributions).setDistance(this.distance).setGeometryFunction(this.geomFunc).setLogo(this.logo).setProjection(this.projection).setWrapX(this.wrapX);
      return this._sourceBuilder.promise();
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices: function getServices() {
      return multiMergeDescriptors(vectorSource.methods.getServices.call(this), sourceContainer.methods.getServices.call(this));
    },

    /**
     * @return {{
     *     setSource: function(ol.source.Source): void,
     *     getSource: function(): ol.source.Source
     *   }|undefined}
     * @protected
     */
    getSourceTarget: function getSourceTarget() {
      return this._sourceBuilder;
    }
  };
  var watch$c = {
    distance: function distance(value) {
      if (this.$source && value !== this.$source.getDistance()) {
        this.$source.setDistance(value);
      }
    }
  };
  var script$4 = {
    name: 'vl-source-cluster',
    mixins: [vectorSource, sourceContainer],
    props: props$g,
    computed: computed$6,
    methods: methods$p,
    watch: watch$c
    /**
     * @returns {function(f: ol.Feature): ol.geom.SimpleGeometry|undefined}
     */

  };

  function defaultGeomFuncFactory() {
    return function (feature) {
      var geometry = feature.getGeometry();
      if (!geometry) return;
      var coordinate = findPointOnSurface(geometry);

      if (coordinate) {
        return createPointGeom(coordinate);
      }
    };
  }

  /* script */
  var __vue_script__$4 = script$4;
  /* template */

  /* style */

  var __vue_inject_styles__$4 = undefined;
  /* scoped */

  var __vue_scope_id__$4 = undefined;
  /* module identifier */

  var __vue_module_identifier__$4 = undefined;
  /* functional template */

  var __vue_is_functional_template__$4 = undefined;
  /* component normalizer */

  function __vue_normalize__$4(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$2 = __vue_normalize__$4({}, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, undefined, undefined);

  function plugin$4(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$4.installed) {
      return;
    }

    plugin$4.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$2, options);

    Vue$$1.component(Source$2.name, Source$2);
  }

  var ClusterSource = /*#__PURE__*/Object.freeze({
    default: plugin$4,
    Source: Source$2,
    install: plugin$4
  });

  var isEnum$1 = _objectPie.f;
  var _objectToArray = function (isEntries) {
    return function (it) {
      var O = _toIobject(it);
      var keys = _objectKeys(O);
      var length = keys.length;
      var i = 0;
      var result = [];
      var key;
      while (length > i) if (isEnum$1.call(O, key = keys[i++])) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      } return result;
    };
  };

  // https://github.com/tc39/proposal-object-values-entries

  var $values = _objectToArray(false);

  _export(_export.S, 'Object', {
    values: function values(it) {
      return $values(it);
    }
  });

  var values = _core.Object.values;

  var values$1 = values;

  var transformType = function transformType(type) {
    return upperFirst(camelCase(type));
  };
  /**
   * @vueProps
   */


  var props$h = {
    /**
     * Target source or collection identifier from IdentityMap.
     * @type {String}
     */
    source: {
      type: String,
      required: true
    },

    /**
     * The maximum distance in pixels between "down" and "up" for a "up" event to be considered a "click" event and
     * actually add a point/vertex to the geometry being drawn. Default is 6 pixels. That value was chosen for the
     * draw interaction to behave correctly on mouse as well as on touch devices.
     * @type {number}
     */
    clickTolerance: {
      type: Number,
      default: 6
    },

    /**
     * Pixel distance for snapping to the drawing finish.
     * @type {number}
     */
    snapTolerance: {
      type: Number,
      default: 12
    },

    /**
     * Drawing type ('Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').
     * @type {string}
     */
    type: {
      type: String,
      required: true,
      validator: function validator(value) {
        return values$1(GEOMETRY_TYPE).includes(transformType(value));
      }
    },

    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * @type {boolean}
     */
    stopClick: {
      type: Boolean,
      default: false
    },

    /**
     * The number of points that can be drawn before a polygon ring or line string is finished.
     * @type {number|undefined}
     */
    maxPoints: Number,

    /**
     * The number of points that must be drawn before a polygon ring or line string can be finished.
     * Default is `3` for polygon rings and `2` for line strings.
     * @type {number|undefined}
     */
    minPoints: Number,

    /**
     * A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether the drawing can be finished.
     * @type {function|undefined}
     */
    finishCondition: Function,

    /**
     * Function that is called when a geometry's coordinates are updated.
     * @type {function|undefined}
     */
    geometryFunction: Function,

    /**
     * Name of the geometry attribute for newly created features.
     * @type {string}
     */
    geometryName: {
      type: String,
      default: 'geometry'
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * By default `ol.events.condition.noModifierKeys`, i.e. a click, adds a vertex or deactivates freehand drawing.
     * @type {function|undefined}
     */
    condition: {
      type: Function,
      default: condition.noModifierKeys
    },

    /**
     * Operate in freehand mode for lines, polygons, and circles. This makes the interaction always operate in
     * freehand mode and takes precedence over any `freehandCondition` option.
     * @type {boolean}
     */
    freehand: {
      type: Boolean,
      default: false
    },

    /**
     * Condition that activates freehand drawing for lines and polygons. This function takes an `ol.MapBrowserEvent` and
     * returns a boolean to indicate whether that event should be handled. The default is `ol.events.condition.shiftKeyOnly`,
     * meaning that the Shift key activates freehand drawing.
     * @type {function|undefined}
     */
    freehandCondition: {
      type: Function,
      default: condition.shiftKeyOnly
    },

    /**
     * Wrap the world horizontally on the sketch overlay.
     * @type {boolean}
     */
    wrapX: {
      type: Boolean,
      default: false
    }
    /**
     * @vueMethods
     */

  };
  var methods$q = {
    /**
     * @return {Promise<Draw>}
     * @protected
     */
    createInteraction: function () {
      var _createInteraction = _asyncToGenerator(
      /*#__PURE__*/
      regenerator.mark(function _callee() {
        var sourceIdent, source, features;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                sourceIdent = this.makeIdent(this.source);
                _context.next = 3;
                return this.$identityMap.get(sourceIdent, this.$options.INSTANCE_PROMISE_POOL);

              case 3:
                source = _context.sent;

                if (isFunction(source.getFeatures)) {
                  features = source.getFeatures();

                  if (isCollection(features)) {
                    source = features;
                  }
                }

                return _context.abrupt("return", new DrawInteraction({
                  source: isVectorSource(source) ? source : undefined,
                  features: isCollection(source) ? source : undefined,
                  clickTolerance: this.clickTolerance,
                  snapTolerance: this.snapTolerance,
                  type: transformType(this.type),
                  stopClick: this.stopClick,
                  maxPoints: this.maxPoints,
                  minPoints: this.minPoints,
                  finishCondition: this.finishCondition,
                  style: this.createStyleFunc(),
                  geometryFunction: this.geometryFunction,
                  geometryName: this.geometryName,
                  condition: this.condition,
                  freehand: this.freehand,
                  freehandCondition: this.freehandCondition,
                  wrapX: this.wrapX
                }));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function createInteraction() {
        return _createInteraction.apply(this, arguments);
      };
    }(),

    /**
     * @return {function(feature: Feature): Style}
     * @protected
     */
    getDefaultStyles: function getDefaultStyles() {
      var defaultStyles = mapValues(defaultEditStyle(), function (styles) {
        return styles.map(createStyle);
      });
      return function __selectDefaultStyleFunc(feature) {
        if (feature.getGeometry()) {
          return defaultStyles[feature.getGeometry().getType()];
        }
      };
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      return multiMergeDescriptors(interaction$1.methods.getServices.call(this), stylesContainer.methods.getServices.call(this));
    },

    /**
     * @return {Interaction|undefined}
     * @protected
     */
    getStyleTarget: function getStyleTarget() {
      return this.$interaction;
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      interaction$1.methods.mount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      interaction$1.methods.unmount.call(this);
    },

    /**
     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles
     * @return {void}
     * @protected
     */
    setStyle: function setStyle(styles) {
      if (styles !== this._styles) {
        this._styles = styles;
        this.scheduleRefresh();
      }
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      subscribeToInteractionChanges.call(this);
    }
  }; // todo other props?

  var watch$d = makeWatchers(['source', 'type'], function () {
    return function () {
      this.scheduleRecreate();
    };
  });
  /**
   * @alias module:draw-interaction/interaction
   * @title vl-interaction-draw
   * @vueProto
   */

  var script$5 = {
    name: 'vl-interaction-draw',
    mixins: [interaction$1, stylesContainer],
    props: props$h,
    methods: methods$q,
    watch: watch$d,
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          class: this.$options.name
        };
      }
    }
    /**
     * @return {void}
     * @private
     */

  };

  function subscribeToInteractionChanges() {
    var _this = this;

    hasInteraction(this);
    var drawEvents = merge(fromOlEvent(this.$interaction, 'drawstart').pipe(map$3(function (evt) {
      initFeature(evt.feature);
      return evt;
    })), fromOlEvent(this.$interaction, 'drawend'));
    this.subscribeTo(drawEvents, function (evt) {
      ++_this.rev;

      _this.$emit(evt.type, evt);
    });
  }

  /* script */
  var __vue_script__$5 = script$5;
  /* template */

  /* style */

  var __vue_inject_styles__$5 = undefined;
  /* scoped */

  var __vue_scope_id__$5 = undefined;
  /* module identifier */

  var __vue_module_identifier__$5 = undefined;
  /* functional template */

  var __vue_is_functional_template__$5 = undefined;
  /* component normalizer */

  function __vue_normalize__$5(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "interaction.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Interaction$1 = __vue_normalize__$5({}, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, undefined, undefined);

  function plugin$5(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$5.installed) {
      return;
    }

    plugin$5.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Interaction$1, options);

    Vue$$1.component(Interaction$1.name, Interaction$1);
  }

  var DrawInteraction$1 = /*#__PURE__*/Object.freeze({
    default: plugin$5,
    Interaction: Interaction$1,
    install: plugin$5
  });

  /**
   * @vueProps
   */

  var props$i =
  /** @lends module:feature/feature# */
  {
    /**
     * Feature identifier.
     * @type {string|number}
     * @default UUID
     * @vueSync
     */
    id: {
      type: [String, Number],
      default: function _default() {
        return v4_1();
      }
    },

    /**
     * All feature properties.
     * @type {Object}
     * @default {}
     * @vueSync
     */
    properties: {
      type: Object,
      default: function _default() {
        return create$1(null);
      }
    }
    /**
     * @vueComputed
     */

  };
  var computed$7 =
  /** @lends module:feature/feature# */
  {
    /**
     * **GeoJSON** encoded geometry.
     * @type {Object|undefined}
     */
    geometry: function geometry() {
      if (this.rev && this.resolvedDataProjection && this.$geometry) {
        return this.writeGeometryInDataProj(this.$geometry);
      }
    },

    /**
     * @return {number[]|undefined}
     */
    point: function point() {
      if (this.pointViewProj && this.resolvedDataProjection) {
        return this.pointToDataProj(this.pointViewProj);
      }
    },
    geometryViewProj: function geometryViewProj() {
      if (this.rev && this.resolvedDataProjection && this.$geometry) {
        return this.writeGeometryInViewProj(this.$geometry);
      }
    },
    pointViewProj: function pointViewProj() {
      if (this.rev && this.$geometry) {
        return findPointOnSurface(this.$geometry);
      }
    }
  };
  /**
   * @vueMethods
   */

  var methods$r =
  /** @lends module:feature/feature# */
  {
    /**
     * Create feature without inner style applying, feature level style
     * will be applied in the layer level style function.
     * @return {Feature}
     * @protected
     */
    createOlObject: function createOlObject() {
      var feature = new Feature(this.properties);
      feature.setId(this.id);
      feature.setGeometry(this.$geometry);
      return feature;
    },

    /**
     * @return {{
     *     getGeometry: function(): (Geometry|undefined),
     *     setGeometry: function((Geometry|undefined)): void
     *   }|Feature|undefined}
     * @protected
     */
    getGeometryTarget: function getGeometryTarget() {
      return this.$feature;
    },

    /**
     * @return {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(cmp.methods.getServices.call(this), geometryContainer.methods.getServices.call(this), stylesContainer.methods.getServices.call(this), {
        get feature() {
          return vm.$feature;
        }

      });
    },

    /**
     * @return {Feature|undefined}
     * @protected
     */
    getStyleTarget: function getStyleTarget() {
      return this.$feature;
    },

    /**
     * Checks if feature lies at `pixel`.
     * @param {number[]} pixel
     * @return {boolean}
     */
    isAtPixel: function isAtPixel(pixel) {
      var _this = this;

      hasMap(this);
      return this.$map.forEachFeatureAtPixel(pixel, function (f) {
        return f === _this.$feature;
      }, {
        layerFilter: function layerFilter(l) {
          return l === _this.$layer;
        }
      });
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      this.$featuresContainer && this.$featuresContainer.addFeature(this);
      this.subscribeAll();
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.unsubscribeAll();
      this.$featuresContainer && this.$featuresContainer.removeFeature(this);
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      subscribeToFeatureChanges.call(this);
    }
  };
  var watch$e = {
    /**
     * @param {string|number} value
     */
    id: function id(value) {
      if (this.$feature && value !== this.$feature.getId()) {
        this.$feature.setId(value);
      }
    },

    /**
     * @param {Object} value
     */
    properties: function properties(value) {
      value = plainProps(value);

      if (this.$feature && !isEqual(value, plainProps(this.$feature.getProperties()))) {
        this.$feature.setProperties(plainProps(value));
      }
    }
  };
  /**
   * A vector object for geographic features with a geometry and other attribute properties,
   * similar to the features in vector file formats like **GeoJSON**.
   *
   * @title vl-feature
   * @alias module:feature/feature
   * @vueProto
   *
   * @vueSlot default [scoped] Default **scoped** slot with current feature state: `id`, `properties`, GeoJSON `geometry`.
   */

  var script$6 = {
    name: 'vl-feature',
    mixins: [cmp, useMapCmp, geometryContainer, stylesContainer, projTransforms],
    props: props$i,
    computed: computed$7,
    methods: methods$r,
    watch: watch$e,
    created: function created() {
      var _this2 = this;

      defineProperties$1(this,
      /** @lends module:feature/feature# */
      {
        /**
         * Reference to `ol.Feature` instance.
         * @type {Feature|undefined}
         */
        $feature: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$olObject;
          }
        },

        /**
         * Reference to parent `Layer` instance.
         * @type {Layer|undefined}
         */
        $layer: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.layer;
          }
        },

        /**
         * Reference to `ol.Map` instance.
         * @type {Map|undefined}
         */
        $map: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.map;
          }
        },

        /**
         * Reference to `ol.View` instance.
         * @type {View|undefined}
         */
        $view: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.view;
          }
        },

        /**
         * Reference to `featuresContainer`.
         * @type {Object|undefined}
         */
        $featuresContainer: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.featuresContainer;
          }
        }
      });
    }
  };
  /**
   * @return {void}
   * @private
   */

  function subscribeToFeatureChanges() {
    var _this3 = this;

    hasFeature(this);

    var getPropValue = function getPropValue(prop) {
      return _this3.$feature.get(prop);
    };

    var ft = 100; // all plain properties

    var propChanges = fromOlEvent(this.$feature, 'propertychange', function (_ref) {
      var key = _ref.key;
      return {
        prop: key,
        value: getPropValue(key)
      };
    }).pipe(throttleTime(ft), distinctUntilChanged(isEqual)); // id, style and other generic changes

    var changes = fromOlEvent(this.$feature, 'change').pipe(map$3(function () {
      return Observable.create(function (obs) {
        if (_this3.$feature.getId() !== _this3.id) {
          obs.next({
            prop: 'id',
            value: _this3.$feature.getId()
          });
        } // todo style?

      });
    }), mergeAll(), throttleTime(ft), distinctUntilChanged(isEqual)); // all changes

    var allChanges = merge(propChanges, changes);
    this.subscribeTo(allChanges, function (_ref2) {
      var prop = _ref2.prop,
          value = _ref2.value;
      ++_this3.rev;

      if (prop === 'id') {
        _this3.$emit("update:".concat(prop), value);
      } else if (prop !== _this3.$feature.getGeometryName()) {
        _this3.$emit('update:properties', assign$1({}, _this3.properties, _defineProperty({}, prop, value)));
      }
    });
  }

  /* script */
  var __vue_script__$6 = script$6;
  /* template */

  var __vue_render__ = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: [_vm.$options.name],
      staticStyle: {
        "display": "none !important"
      },
      attrs: {
        "id": [_vm.$options.name, _vm.id].join('-')
      }
    }, [_vm._t("default", null, {
      id: _vm.id,
      properties: _vm.properties,
      geometry: _vm.geometry,
      point: _vm.point
    })], 2);
  };

  var __vue_staticRenderFns__ = [];
  /* style */

  var __vue_inject_styles__$6 = undefined;
  /* scoped */

  var __vue_scope_id__$6 = undefined;
  /* module identifier */

  var __vue_module_identifier__$6 = undefined;
  /* functional template */

  var __vue_is_functional_template__$6 = false;
  /* component normalizer */

  function __vue_normalize__$6(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "feature.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Feature$1 = __vue_normalize__$6({
    render: __vue_render__,
    staticRenderFns: __vue_staticRenderFns__
  }, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6, __vue_module_identifier__$6, undefined, undefined);

  function plugin$6(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$6.installed) {
      return;
    }

    plugin$6.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Feature$1, options);

    Vue$$1.component(Feature$1.name, Feature$1);
  }

  var Feature$2 = /*#__PURE__*/Object.freeze({
    default: plugin$6,
    Feature: Feature$1,
    install: plugin$6
  });

  var props$j = {
    color: [String, Array]
  };
  var methods$s = {
    /**
     * @return {Fill}
     * @protected
     */
    createStyle: function createStyle() {
      return new Fill({
        color: this.color
      });
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      this.$stylesContainer && this.$stylesContainer.setFill(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.$stylesContainer && this.$stylesContainer.setFill(undefined);
    }
  };
  var watch$f = {
    color: function color(value) {
      if (this.$style && !isEqual(value, this.$style.getColor())) {
        this.$style.setColor(value);
        this.scheduleRefresh();
      }
    }
  };
  var script$7 = {
    name: 'vl-style-fill',
    mixins: [style],
    props: props$j,
    methods: methods$s,
    watch: watch$f
  };

  /* script */
  var __vue_script__$7 = script$7;
  /* template */

  /* style */

  var __vue_inject_styles__$7 = undefined;
  /* scoped */

  var __vue_scope_id__$7 = undefined;
  /* module identifier */

  var __vue_module_identifier__$7 = undefined;
  /* functional template */

  var __vue_is_functional_template__$7 = undefined;
  /* component normalizer */

  function __vue_normalize__$7(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "style.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Style$2 = __vue_normalize__$7({}, __vue_inject_styles__$7, __vue_script__$7, __vue_scope_id__$7, __vue_is_functional_template__$7, __vue_module_identifier__$7, undefined, undefined);

  function plugin$7(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$7.installed) {
      return;
    }

    plugin$7.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Style$2, options);

    Vue$$1.component(Style$2.name, Style$2);
  }

  var FillStyle = /*#__PURE__*/Object.freeze({
    default: plugin$7,
    Style: Style$2,
    install: plugin$7
  });

  var props$k = {
    tracking: {
      type: Boolean,
      default: true
    },
    trackingOptions: Object,

    /**
     * @type {string}
     */
    projection: String // todo add autoCenter, bindToPosition

  };
  var computed$8 = {
    accuracy: function accuracy() {
      if (this.rev && this.$geolocation) {
        return this.$geolocation.getAccuracy();
      }
    },
    altitude: function altitude() {
      if (this.rev && this.$geolocation) {
        return this.$geolocation.getAltitude();
      }
    },
    altitudeAccuracy: function altitudeAccuracy() {
      if (this.rev && this.$geolocation) {
        return this.$geolocation.getAltitudeAccuracy();
      }
    },
    heading: function heading() {
      if (this.rev && this.$geolocation) {
        return this.$geolocation.getHeading();
      }
    },
    speed: function speed() {
      if (this.rev && this.$geolocation) {
        return this.$geolocation.getSpeed();
      }
    },
    position: function position() {
      if (this.rev && this.$geolocation) {
        return this.$geolocation.getPosition();
      }
    },
    positionViewProj: function positionViewProj() {
      if (this.position && this.resolvedDataProjection) {
        return this.pointToViewProj(this.position);
      }
    }
  };
  var methods$t = {
    /**
     * @return {Geolocation}
     * @private
     */
    createOlObject: function createOlObject() {
      return new Geolocation({
        tracking: this.tracking,
        trackingOptions: this.trackingOptions,
        projection: this.resolvedDataProjection
      });
    },

    /**
     * @return {void}
     * @private
     */
    mount: function mount() {
      this.subscribeAll();
    },

    /**
     * @return {void}
     * @private
     */
    unmount: function unmount() {
      hasGeolocation(this);
      this.unsubscribeAll();
      this.$geolocation.setTracking(false);
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      subscribeToGeolocation.call(this);
    }
  };
  var watch$g = {
    /**
     * @param {boolean} value
     */
    tracking: function tracking(value) {
      if (this.$geolocation && value !== this.$geolocation.getTracking()) {
        this.$geolocation.setTracking(value);
      }
    },
    tracingOptions: function tracingOptions(value) {
      this.$geolocation && this.$geolocation.setTrackingOptions(value);
    },
    resolvedDataProjection: function resolvedDataProjection(value) {
      if (this.$geolocation) {
        this.$geolocation.setProjection(value);
      }
    }
  };
  var script$8 = {
    name: 'vl-geoloc',
    mixins: [cmp, useMapCmp, projTransforms],
    props: props$k,
    computed: computed$8,
    methods: methods$t,
    watch: watch$g,
    stubVNode: {
      empty: function empty() {
        return this.$options.name;
      }
    },
    created: function created() {
      var _this = this;

      defineProperties$1(this, {
        /**
         * @type {Geolocation|undefined}
         */
        $geolocation: {
          enumerable: true,
          get: function get() {
            return _this.$olObject;
          }
        },
        $map: {
          enumerable: true,
          get: function get() {
            return _this.$services && _this.$services.map;
          }
        },

        /**
         * Reference to `ol.View` instance.
         * @type {View|undefined}
         */
        $view: {
          enumerable: true,
          get: function get() {
            return _this.$services && _this.$services.view;
          }
        }
      });
    }
  };
  /**
   * @return {void}
   * @private
   */

  function subscribeToGeolocation() {
    var _this2 = this;

    hasGeolocation(this);
    var ft = 100;
    var changes = merge(fromOlChangeEvent(this.$geolocation, ['accuracy', 'altitude', 'altitudeaccuracy', 'heading', 'speed'], true, ft), fromOlChangeEvent(this.$geolocation, 'position', true, ft, function () {
      return _this2.position;
    }));
    this.subscribeTo(changes, function (_ref) {
      var prop = _ref.prop,
          value = _ref.value;
      ++_this2.rev;

      _this2.$emit("update:".concat(prop), value);
    });
  }

  /* script */
  var __vue_script__$8 = script$8;
  /* template */

  var __vue_render__$1 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: [_vm.$options.name],
      staticStyle: {
        "display": "none !important"
      }
    }, [_vm._t("default", null, {
      accuracy: _vm.accuracy,
      altitude: _vm.altitude,
      altitudeAccuracy: _vm.altitudeAccuracy,
      heading: _vm.heading,
      position: _vm.position,
      speed: _vm.speed
    })], 2);
  };

  var __vue_staticRenderFns__$1 = [];
  /* style */

  var __vue_inject_styles__$8 = undefined;
  /* scoped */

  var __vue_scope_id__$8 = undefined;
  /* module identifier */

  var __vue_module_identifier__$8 = undefined;
  /* functional template */

  var __vue_is_functional_template__$8 = false;
  /* component normalizer */

  function __vue_normalize__$8(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "geoloc.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Geoloc = __vue_normalize__$8({
    render: __vue_render__$1,
    staticRenderFns: __vue_staticRenderFns__$1
  }, __vue_inject_styles__$8, __vue_script__$8, __vue_scope_id__$8, __vue_is_functional_template__$8, __vue_module_identifier__$8, undefined, undefined);

  function plugin$8(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$8.installed) {
      return;
    }

    plugin$8.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Geoloc, options);

    Vue$$1.component(Geoloc.name, Geoloc);
  }

  var Geoloc$1 = /*#__PURE__*/Object.freeze({
    default: plugin$8,
    Geoloc: Geoloc,
    install: plugin$8
  });

  var props$l = {
    maxLines: {
      type: Number,
      default: 100
    },
    targetSize: {
      type: Number,
      default: 100
    },
    showLabels: {
      type: Boolean,
      default: false
    },
    lonLabelFormatter: Function,
    latLabelFormatter: Function,
    lonLabelPosition: {
      type: Number,
      default: 0
    },
    latLabelPosition: {
      type: Number,
      default: 1
    },
    intervals: {
      type: Array,
      default: function _default() {
        return [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001];
      }
    }
  };
  var computed$9 = {
    meridians: function meridians() {
      var _this = this;

      if (this.$graticule && this.rev) {
        return map(this.getMeridians(), function (meridian) {
          return _this.lineToDataProj(meridian.getCoordinates());
        });
      }

      return [];
    },
    parallels: function parallels() {
      var _this2 = this;

      if (this.$graticule && this.rev) {
        return map(this.getParallels(), function (parallel) {
          return _this2.lineToDataProj(parallel.getCoordinates());
        });
      }

      return [];
    }
  };
  var methods$u = {
    createOlObject: function createOlObject() {
      return new Graticule({
        maxLines: this.maxLines,
        targetSize: this.targetSize,
        showLabels: this.showLabels,
        strokeStyle: this._strokeStyle,
        lonLabelFormatter: this.lonLabelFormatter,
        latLabelFormatter: this.latLabelFormatter,
        lonLabelPosition: this.lonLabelPosition,
        latLabelPosition: this.latLabelPosition,
        lonLabelStyle: this._lonLabelStyle,
        latLabelStyle: this._latLabelStyle,
        intervals: this.intervals
      });
    },

    /**
     * @return {Promise} Resolves when initialization completes
     * @protected
     */
    init: function init() {
      return cmp.methods.init.call(this);
    },

    /**
     * @return {void|Promise<void>}
     * @protected
     */
    deinit: function deinit() {
      return cmp.methods.deinit.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      this.$map && this.$graticule.setMap(this.$map);
      this.subscribeAll();
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.unsubscribeAll();
      this.$graticule.setMap(undefined);
    },
    getMeridians: function getMeridians() {
      hasGraticule(this);
      return this.$graticule.getMeridians();
    },
    getParallels: function getParallels() {
      hasGraticule(this);
      return this.$graticule.getParallels();
    },
    setStroke: function setStroke(stroke) {
      stroke = stroke instanceof Vue ? stroke.$style : stroke;

      if (stroke !== this._strokeStyle) {
        this._strokeStyle = stroke;
        this.scheduleRefresh();
      }
    },
    setText: function setText(text) {
      text = text instanceof Vue ? text.$style : text;
      var vm;

      if (text) {
        vm = firstEl(text[this.$options.VM_PROP]);
      }

      var vmMatcher = function vmMatcher(vnode) {
        return vnode.componentInstance && vnode.componentInstance === vm;
      };

      if (text == null && this.$slots.lon == null || isArray$1(this.$slots.lon) && this.$slots.lon.some(vmMatcher)) {
        if (text !== this._lonLabelStyle) {
          this._lonLabelStyle = text;
          this.scheduleRefresh();
        }
      } else if (text == null && this.$slots.lat == null || isArray$1(this.$slots.lat) && this.$slots.lat.some(vmMatcher)) {
        if (text !== this._latLabelStyle) {
          this._latLabelStyle = text;
          this.scheduleRefresh();
        }
      }
    },
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(cmp.methods.getServices.call(this), {
        get stylesContainer() {
          return vm;
        }

      });
    },

    /**
     * @return {Promise}
     */
    refresh: function refresh() {
      return this.recreate();
    },
    subscribeAll: function subscribeAll() {
      var _this3 = this;

      hasMap(this);
      var ft = 1000 / 60;
      var postcompose = fromOlEvent(this.$map, 'postcompose').pipe(throttleTime(ft));
      this.subscribeTo(postcompose, function () {
        ++_this3.rev;
      });
    }
  };
  var watch$h = makeWatchers(keys$1(props$l), function () {
    return function () {
      this.scheduleRefresh();
    };
  });
  var script$9 = {
    name: 'vl-graticule',
    mixins: [cmp, useMapCmp, projTransforms],
    props: props$l,
    computed: computed$9,
    methods: methods$u,
    watch: watch$h,
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          class: this.$options.name
        };
      }
    },
    created: function created() {
      var _this4 = this;

      defineProperties$1(this, {
        $graticule: {
          enumerable: true,
          get: function get$$1() {
            return _this4.$olObject;
          }
        },
        $map: {
          enumerable: true,
          get: function get$$1() {
            return _this4.$services && _this4.$services.map;
          }
        },
        $view: {
          enumerable: true,
          get: function get$$1() {
            return _this4.$services && _this4.$services.view;
          }
        }
      });
    }
  };

  /* script */
  var __vue_script__$9 = script$9;
  /* template */

  var __vue_render__$2 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: _vm.$options.name,
      staticStyle: {
        "display": "none !important"
      }
    }, [_vm._t("lon"), _vm._v(" "), _vm._t("lat"), _vm._v(" "), _vm._t("stroke")], 2);
  };

  var __vue_staticRenderFns__$2 = [];
  /* style */

  var __vue_inject_styles__$9 = undefined;
  /* scoped */

  var __vue_scope_id__$9 = undefined;
  /* module identifier */

  var __vue_module_identifier__$9 = undefined;
  /* functional template */

  var __vue_is_functional_template__$9 = false;
  /* component normalizer */

  function __vue_normalize__$9(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "graticule.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Graticule$1 = __vue_normalize__$9({
    render: __vue_render__$2,
    staticRenderFns: __vue_staticRenderFns__$2
  }, __vue_inject_styles__$9, __vue_script__$9, __vue_scope_id__$9, __vue_is_functional_template__$9, __vue_module_identifier__$9, undefined, undefined);

  function plugin$9(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$9.installed) {
      return;
    }

    plugin$9.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Graticule$1, options);

    Vue$$1.component(Graticule$1.name, Graticule$1);
  }

  var Graticule$2 = /*#__PURE__*/Object.freeze({
    default: plugin$9,
    Graticule: Graticule$1,
    install: plugin$9
  });

  var methods$v = {
    createLayer: function createLayer() {
      return new GroupLayer({
        id: this.id,
        minResolution: this.minResolution,
        maxResolution: this.maxResolution,
        opacity: this.opacity,
        visible: this.visible,
        extent: this.extent,
        zIndex: this.zIndex
      });
    },
    getLayersTarget: function getLayersTarget() {
      hasLayer(this);

      if (this._layersTarget == null) {
        this._layersTarget = new IndexedCollectionAdapter(this.$layer.getLayers(), function (layer$$1) {
          return layer$$1.get('id');
        });
      }

      return this._layersTarget;
    },
    getServices: function getServices() {
      return multiMergeDescriptors(layer.methods.getServices.call(this), layersContainer.methods.getServices.call(this));
    }
  };
  var script$a = {
    name: 'vl-layer-group',
    mixins: [layer, layersContainer],
    methods: methods$v
  };

  /* script */
  var __vue_script__$a = script$a;
  /* template */

  /* style */

  var __vue_inject_styles__$a = undefined;
  /* scoped */

  var __vue_scope_id__$a = undefined;
  /* module identifier */

  var __vue_module_identifier__$a = undefined;
  /* functional template */

  var __vue_is_functional_template__$a = undefined;
  /* component normalizer */

  function __vue_normalize__$a(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "layer.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Layer = __vue_normalize__$a({}, __vue_inject_styles__$a, __vue_script__$a, __vue_scope_id__$a, __vue_is_functional_template__$a, __vue_module_identifier__$a, undefined, undefined);

  function plugin$a(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$a.installed) {
      return;
    }

    plugin$a.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Layer, options);

    Vue$$1.component(Layer.name, Layer);
  }

  var GroupLayer$1 = /*#__PURE__*/Object.freeze({
    default: plugin$a,
    Layer: Layer,
    install: plugin$a
  });

  var props$m = {
    src: {
      type: String,
      required: true
    },
    size: {
      type: Array,
      validator: function validator(value) {
        return value.length === 2;
      }
    },
    anchor: {
      type: Array,
      default: function _default() {
        return [0.5, 0.5];
      },
      validator: function validator(value) {
        return value.length === 2;
      }
    },
    anchorOrigin: {
      type: String,
      default: 'top-left' // bottom-left, bottom-right, top-left or top-right

    },
    anchorXUnits: {
      type: String,
      default: 'fraction' // pixels, fraction

    },
    anchorYUnits: {
      type: String,
      default: 'fraction' // pixels, fraction

    },
    color: [Array, String],
    crossOrigin: String,
    offset: {
      type: Array,
      default: function _default() {
        return [0, 0];
      },
      validator: function validator(value) {
        return value.length === 2;
      }
    },
    offsetOrigin: {
      type: String,
      default: 'top-left' // bottom-left, bottom-right, top-left or top-right

    },
    opacity: {
      type: Number,
      default: 1
    },
    scale: {
      type: Number,
      default: 1
    },
    rotateWithView: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: Number,
      default: 0
    }
  };
  var methods$w = {
    /**
     * @return {Icon}
     * @protected
     */
    createStyle: function createStyle() {
      return new Icon({
        anchor: this.anchor,
        anchorOrigin: this.anchorOrigin,
        anchorXUnits: this.anchorXUnits,
        anchorYUnits: this.anchorYUnits,
        color: this.color,
        crossOrigin: this.crossOrigin,
        offset: this.offset,
        offsetOrigin: this.offsetOrigin,
        opacity: this.opacity,
        scale: this.scale,
        rotateWithView: this.rotateWithView,
        rotation: this.rotation,
        size: this.size,
        src: this.src
      });
    }
  }; // todo other watchers

  var watch$i = {
    src: function src(value) {
      if (this.$style && !isEqual(value, this.$style.getSrc())) {
        this.scheduleRefresh();
      }
    },
    size: function size$$1(value) {
      if (this.$style && !isEqual(value, this.$style.getSize())) {
        this.scheduleRefresh();
      }
    },
    anchor: function anchor(value) {
      if (this.$style && !isEqual(value, this.$style.getAnchor())) {
        this.scheduleRefresh();
      }
    },
    scale: function scale(value) {
      if (this.$style && !isEqual(value, this.$style.getScale())) {
        this.scheduleRefresh();
      }
    }
  };
  var script$b = {
    name: 'vl-style-icon',
    mixins: [imageStyle],
    props: props$m,
    methods: methods$w,
    watch: watch$i
  };

  /* script */
  var __vue_script__$b = script$b;
  /* template */

  /* style */

  var __vue_inject_styles__$b = undefined;
  /* scoped */

  var __vue_scope_id__$b = undefined;
  /* module identifier */

  var __vue_module_identifier__$b = undefined;
  /* functional template */

  var __vue_is_functional_template__$b = undefined;
  /* component normalizer */

  function __vue_normalize__$b(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "style.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Style$3 = __vue_normalize__$b({}, __vue_inject_styles__$b, __vue_script__$b, __vue_scope_id__$b, __vue_is_functional_template__$b, __vue_module_identifier__$b, undefined, undefined);

  function plugin$b(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$b.installed) {
      return;
    }

    plugin$b.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Style$3, options);

    Vue$$1.component(Style$3.name, Style$3);
  }

  var IconStyle = /*#__PURE__*/Object.freeze({
    default: plugin$b,
    Style: Style$3,
    install: plugin$b
  });

  /**
   * @vueProps
   */

  var props$n =
  /** @lends module:image-layer/layer# */
  {};
  /**
   * @vueMethods
   */

  var methods$x =
  /** @lends module:image-layer/layer# */
  {
    /**
     * @return {Image}
     * @protected
     */
    createLayer: function createLayer() {
      return new ImageLayer({
        id: this.id,
        minResolution: this.minResolution,
        maxResolution: this.maxResolution,
        opacity: this.opacity,
        visible: this.visible,
        extent: this.extent,
        zIndex: this.zIndex,
        source: this._source
      });
    }
  };
  /**
   * Layer for server-rendered images that are available for arbitrary extents and resolutions.
   *
   * @title vl-layer-image
   * @alias module:image-layer/layer
   * @vueProto
   *
   * @vueSlot default Default slot for `vl-source-*` (image-like only) components.
   */

  var script$c = {
    name: 'vl-layer-image',
    mixins: [layer],
    props: props$n,
    methods: methods$x
  };

  /* script */
  var __vue_script__$c = script$c;
  /* template */

  /* style */

  var __vue_inject_styles__$c = undefined;
  /* scoped */

  var __vue_scope_id__$c = undefined;
  /* module identifier */

  var __vue_module_identifier__$c = undefined;
  /* functional template */

  var __vue_is_functional_template__$c = undefined;
  /* component normalizer */

  function __vue_normalize__$c(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "layer.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Layer$1 = __vue_normalize__$c({}, __vue_inject_styles__$c, __vue_script__$c, __vue_scope_id__$c, __vue_is_functional_template__$c, __vue_module_identifier__$c, undefined, undefined);

  function plugin$c(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$c.installed) {
      return;
    }

    plugin$c.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Layer$1, options);

    Vue$$1.component(Layer$1.name, Layer$1);
  }

  var ImageLayer$1 = /*#__PURE__*/Object.freeze({
    default: plugin$c,
    Layer: Layer$1,
    install: plugin$c
  });

  /**
   * @vueProps
   */

  var props$o =
  /** @lends module:image-static-source/source# */
  {
    /**
     * Image extent in the source projection.
     * @type {number[]}
     */
    extent: {
      type: Array,
      required: true,
      validator: function validator(value) {
        return value.length === 4;
      }
    },

    /**
     * Optional function to load an image given a URL.
     * @type {function|undefined}
     */
    loadFunc: Function,

    /**
     * Image size in pixels.
     * @type {number[]}
     */
    size: {
      type: Array,
      validator: function validator(value) {
        return value.length === 2;
      }
    },

    /**
     * Image URL.
     * @type {string}
     */
    url: {
      type: String,
      required: true,
      validator: function validator(value) {
        return !!value.length;
      }
    }
    /**
     * @vueMethods
     */

  };
  var methods$y =
  /** @lends module:image-static-source/source# */
  {
    /**
     * @return {ImageStatic}
     * @protected
     */
    createSource: function createSource() {
      return new ImageStaticSource({
        attributions: this.attributions,
        crossOrigin: this.crossOrigin,
        imageExtent: this.extent,
        imageLoadFunction: this.loadFunc,
        logo: this.logo,
        projection: this.projection,
        imageSize: this.size,
        url: this.urlTmpl
      });
    }
  };
  var watch$j = makeWatchers(keys$1(props$o), function () {
    return function () {
      this.scheduleRecreate();
    };
  });
  /**
   * A layer source for displaying a single, static image.
   *
   * @vueProto
   * @title vl-source-image-static
   * @alias module:image-static-source/source
   */

  var script$d = {
    name: 'vl-source-image-static',
    mixins: [imageSource, withUrl],
    props: props$o,
    methods: methods$y,
    watch: watch$j
  };

  /* script */
  var __vue_script__$d = script$d;
  /* template */

  /* style */

  var __vue_inject_styles__$d = undefined;
  /* scoped */

  var __vue_scope_id__$d = undefined;
  /* module identifier */

  var __vue_module_identifier__$d = undefined;
  /* functional template */

  var __vue_is_functional_template__$d = undefined;
  /* component normalizer */

  function __vue_normalize__$d(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$3 = __vue_normalize__$d({}, __vue_inject_styles__$d, __vue_script__$d, __vue_scope_id__$d, __vue_is_functional_template__$d, __vue_module_identifier__$d, undefined, undefined);

  function plugin$d(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$d.installed) {
      return;
    }

    plugin$d.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$3, options);

    Vue$$1.component(Source$3.name, Source$3);
  }

  var ImageStaticSource$1 = /*#__PURE__*/Object.freeze({
    default: plugin$d,
    Source: Source$3,
    install: plugin$d
  });

  var props$p = {
    hidpi: {
      type: Boolean,
      default: true
    },
    serverType: {
      type: String,
      validator: function validator(value) {
        return !value | values$1(WMSServerType).includes(value);
      }
    },
    imageLoadFunction: Function,
    ratio: {
      type: Number,
      default: 1.5
    },
    resolutions: Array,
    url: {
      type: String,
      required: true,
      validator: function validator(value) {
        return !!value.length;
      }
    }
  };
  var methods$z = {
    createOlObject: function createOlObject() {
      return new ImageWMS({
        attributions: this.attributions,
        crossOrigin: this.crossOrigin,
        hidpi: this.hidpi,
        serverType: this.serverType,
        imageLoadFunction: this.imageLoadFunction,
        params: this.allParams,
        projection: this.projection,
        ratio: this.ratio,
        resolutions: this.resolutions,
        url: this.urlTmpl
      });
    }
  };
  var script$e = {
    name: 'vl-source-image-wms',
    mixins: [imageSource, withUrl, wmsSource],
    props: props$p,
    methods: methods$z
  };

  /* script */
  var __vue_script__$e = script$e;
  /* template */

  /* style */

  var __vue_inject_styles__$e = undefined;
  /* scoped */

  var __vue_scope_id__$e = undefined;
  /* module identifier */

  var __vue_module_identifier__$e = undefined;
  /* functional template */

  var __vue_is_functional_template__$e = undefined;
  /* component normalizer */

  function __vue_normalize__$e(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$4 = __vue_normalize__$e({}, __vue_inject_styles__$e, __vue_script__$e, __vue_scope_id__$e, __vue_is_functional_template__$e, __vue_module_identifier__$e, undefined, undefined);

  function plugin$e(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$e.installed) {
      return;
    }

    plugin$e.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$4, options);

    Vue$$1.component(Source$4.name, Source$4);
  }

  var ImageWmsSource = /*#__PURE__*/Object.freeze({
    default: plugin$e,
    Source: Source$4,
    install: plugin$e
  });

  var props$q = {};
  var computed$a = {
    type: constant(GEOMETRY_TYPE.LINE_STRING)
  };
  var methods$A = {
    /**
     * @returns {LineString}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new LineString(this.toViewProj(this.coordinates));
    }
  };
  var script$f = {
    name: 'vl-geom-line-string',
    mixins: [geometry$3],
    props: props$q,
    computed: computed$a,
    methods: methods$A
  };

  /* script */
  var __vue_script__$f = script$f;
  /* template */

  /* style */

  var __vue_inject_styles__$f = undefined;
  /* scoped */

  var __vue_scope_id__$f = undefined;
  /* module identifier */

  var __vue_module_identifier__$f = undefined;
  /* functional template */

  var __vue_is_functional_template__$f = undefined;
  /* component normalizer */

  function __vue_normalize__$f(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "geom.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Geom$1 = __vue_normalize__$f({}, __vue_inject_styles__$f, __vue_script__$f, __vue_scope_id__$f, __vue_is_functional_template__$f, __vue_module_identifier__$f, undefined, undefined);

  function plugin$f(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$f.installed) {
      return;
    }

    plugin$f.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Geom$1, options);

    Vue$$1.component(Geom$1.name, Geom$1);
  }

  var LineStringGeom = /*#__PURE__*/Object.freeze({
    default: plugin$f,
    Geom: Geom$1,
    install: plugin$f
  });

  var props$r = {
    /**
     * Options for default controls added to the map by default. Set to `false` to disable all map controls. Object
     * value is used to configure controls.
     * @type {Object|boolean}
     * @todo remove when vl-control-* components will be ready
     */
    controls: {
      type: [Object, Boolean],
      default: true
    },

    /**
     * The element to listen to keyboard events on. For example, if this option is set to `document` the keyboard
     * interactions will always trigger. If this option is not specified, the element the library listens to keyboard
     * events on is the component root element.
     * @type {string|Element|Document}
     */
    keyboardEventTarget: [String, Element, Document],

    /**
     * When set to `true`, tiles will be loaded during animations.
     * @type {boolean}
     */
    loadTilesWhileAnimating: {
      type: Boolean,
      default: false
    },

    /**
     * When set to `true`, tiles will be loaded while interacting with the map.
     * @type {boolean}
     */
    loadTilesWhileInteracting: {
      type: Boolean,
      default: false
    },

    /**
     * The minimum distance in pixels the cursor must move to be detected as a map move event instead of a click.
     * Increasing this value can make it easier to click on the map.
     * @type {Number}
     */
    moveTolerance: {
      type: Number,
      default: 1
    },

    /**
     * The ratio between physical pixels and device-independent pixels (dips) on the device.
     * @type {number}
     */
    pixelRatio: {
      type: Number,
      default: function _default() {
        return window.devicePixelRatio || 1;
      }
    },

    /**
     * Renderer. By default, **Canvas** and **WebGL** renderers are tested for support in that order,
     * and the first supported used. **Note** that the **Canvas** renderer fully supports vector data,
     * but **WebGL** can only render **Point** geometries.
     * @type {string|string[]}
     * @default ['canvas', 'webgl']
     */
    renderer: {
      type: String,
      default: RENDERER_TYPE.CANVAS,
      validator: function validator(value) {
        return values$1(RENDERER_TYPE).includes(value);
      }
    },

    /**
     * Root element `tabindex` attribute value. Value should be provided to allow keyboard events on map.
     * @type {number|string}
     */
    tabindex: [String, Number],

    /**
     * Projection for input/output coordinates in plain data.
     * @type {string}
     */
    dataProjection: String,
    wrapX: {
      type: Boolean,
      default: true
    }
  };
  var computed$b = {
    mapCtor: function mapCtor() {
      switch (this.renderer) {
        case RENDERER_TYPE.WEBGL:
          return WebGLMap;

        case RENDERER_TYPE.CANVAS:
        default:
          return Map;
      }
    }
  };
  var methods$B = {
    /**
     * @return {Map}
     * @protected
     */
    createOlObject: function createOlObject() {
      /* eslint-disable-next-line new-cap */
      var map$$1 = new this.mapCtor({
        loadTilesWhileAnimating: this.loadTilesWhileAnimating,
        loadTilesWhileInteracting: this.loadTilesWhileInteracting,
        pixelRatio: this.pixelRatio,
        moveTolerance: this.moveTolerance,
        keyboardEventTarget: this.keyboardEventTarget,
        controls: this._controls,
        interactions: this._interactions,
        layers: this._layers,
        overlays: this._overlays,
        view: this._view
      });
      map$$1.set('dataProjection', this.dataProjection);

      this._defaultOverlay.setMap(map$$1);

      return map$$1;
    },

    /**
     * @return {IndexedCollectionAdapter}
     * @protected
     */
    getLayersTarget: function getLayersTarget() {
      hasMap(this);

      if (this._layersTarget == null) {
        this._layersTarget = new IndexedCollectionAdapter(this.$map.getLayers(), function (layer$$1) {
          return layer$$1.get('id');
        });
      }

      return this._layersTarget;
    },

    /**
     * @return {IndexedCollectionAdapter}
     * @protected
     */
    getInteractionsTarget: function getInteractionsTarget() {
      hasMap(this);

      if (this._interactionsTarget == null) {
        this._interactionsTarget = new IndexedCollectionAdapter(this.$map.getInteractions(), function (interaction$$1) {
          return interaction$$1.get('id');
        });
      }

      return this._interactionsTarget;
    },

    /**
     * @return {function}
     * @protected
     */
    getDefaultInteractionsSorter: function getDefaultInteractionsSorter() {
      // sort interactions by priority in asc order
      // the higher the priority, the earlier the interaction handles the event
      return function (a, b) {
        var ap = a.get('priority') || 0;
        var bp = b.get('priority') || 0;
        return ap === bp ? 0 : ap - bp;
      };
    },

    /**
     * @return {SourceCollectionAdapter}
     * @protected
     */
    getFeaturesTarget: function getFeaturesTarget() {
      if (this._featuresTarget == null) {
        this._featuresTarget = new IndexedCollectionAdapter(this._defaultOverlayFeatures, function (feature) {
          return getFeatureId(feature);
        });
      }

      return this._featuresTarget;
    },

    /**
     * @return {IndexedCollectionAdapter}
     * @protected
     */
    getOverlaysTarget: function getOverlaysTarget() {
      hasMap(this);

      if (this._overlaysTarget == null) {
        this._overlaysTarget = new IndexedCollectionAdapter(this.$map.getOverlays(), function (overlay) {
          return overlay.getId();
        });
      }

      return this._overlaysTarget;
    },

    /**
     * @param {number[]} pixel
     * @return {number[]} Coordinates in the map view projection.
     */
    getCoordinateFromPixel: function getCoordinateFromPixel(pixel) {
      hasMap(this);
      var coordinate = this.$map.getCoordinateFromPixel(pixel);
      return this.pointToDataProj(coordinate);
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(cmp.methods.getServices.call(this), layersContainer.methods.getServices.call(this), interactionsContainer.methods.getServices.call(this), overlaysContainer.methods.getServices.call(this), featuresContainer.methods.getServices.call(this), {
        get map() {
          return vm.$map;
        },

        get view() {
          return vm.$view;
        },

        get viewContainer() {
          return vm;
        }

      });
    },

    /**
     * Triggers focus on map container.
     * @return {void}
     */
    focus: function focus() {
      this.$el.focus();
    },

    /**
     * @param {number[]} pixel
     * @param {function((Feature), ?Layer): *} callback
     * @param {Object} [opts]
     * @return {*|undefined}
     */
    forEachFeatureAtPixel: function forEachFeatureAtPixel(pixel, callback) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      hasMap(this);
      return this.$map.forEachFeatureAtPixel(pixel, callback, opts);
    },

    /**
     * @param {number[]} pixel
     * @param {function(Layer, ?(number[]|Uint8Array)): *} callback
     * @param {function(Layer): boolean} [layerFilter]
     * @return {*|undefined}
     */
    forEachLayerAtPixel: function forEachLayerAtPixel(pixel, callback, layerFilter) {
      hasMap(this);
      return this.$map.forEachLayerAtPixel(pixel, callback, undefined, layerFilter);
    },

    /**
     * @param {View|Vue|undefined} view
     * @return {void}
     * @protected
     */
    setView: function setView(view) {
      view = view instanceof Vue ? view.$view : view;
      view || (view = new View());

      if (view !== this._view) {
        this._view = view;
      }

      if (this.$map && view !== this.$map.getView()) {
        this.$map.setView(view);
      }
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      hasMap(this);
      this.$map.setTarget(this.$el);
      this.subscribeAll();
      this.updateSize();
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      hasMap(this);
      this.clearLayers();
      this.clearInteractions();
      this.clearOverlays();
      this.unsubscribeAll();
      this.$map.setTarget(undefined);
    },

    /**
     * Updates map size and re-renders map.
     * @return {Promise}
     */
    refresh: function refresh() {
      var _this = this;

      this.updateSize();
      return this.render().then(function () {
        return cmp.methods.refresh.call(_this);
      });
    },

    /**
     * @return {Promise}
     */
    render: function render() {
      var _this2 = this;

      return new promise$1(function (resolve) {
        hasMap(_this2);

        _this2.$map.once('postrender', function () {
          return resolve();
        });

        _this2.$map.render();
      });
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      subscribeToMapEvents.call(this);
    },

    /**
     * Updates map size.
     * @return {void}
     */
    updateSize: function updateSize() {
      hasMap(this);
      this.$map.updateSize();
    }
  };

  var watch$k = _objectSpread({}, makeWatchers(['keyboardEventTarget', 'loadTilesWhileAnimating', 'loadTilesWhileInteracting', 'moveTolerance', 'pixelRatio', 'renderer'], function () {
    return cmp.methods.scheduleRecreate;
  }), {
    controls: function controls(value) {
      if (value === false) {
        this._controls.clear();

        return;
      }

      value = _typeof(value) === 'object' ? value : undefined;

      this._controls.clear();

      this._controls.extend(control.defaults(value).getArray());
    },
    wrapX: function wrapX(value) {
      if (this._defaultOverlay != null) {
        var source$$1 = new VectorSource({
          features: this._defaultOverlayFeatures,
          wrapX: value
        });

        this._defaultOverlay.setSource(source$$1);
      }
    },
    dataProjection: function dataProjection(value) {
      if (this.$map) {
        this.$map.set('dataProjection', value);
        this.scheduleRefresh();
      }
    }
  });
  /**
   * Container for **layers**, **interactions**, **controls** and **overlays**. It responsible for viewport
   * rendering and low level interaction events.
   *
   * @title vl-map
   * @alias module:map/map
   * @vueProto
   *
   * @fires module:map/map#click
   * @fires module:map/map#dblclick
   * @fires module:map/map#singleclick
   * @fires module:map/map#pointerdrag
   * @fires module:map/map#pointermove
   * @fires module:map/map#movestart
   * @fires module:map/map#moveend
   * @fires module:map/map#postrender
   * @fires module:map/map#precompose
   * @fires module:map/map#postcompose
   *
   * @vueSlot default Default slot for all child components.
   */


  var script$g = {
    name: 'vl-map',
    mixins: [cmp, layersContainer, interactionsContainer, overlaysContainer, featuresContainer, projTransforms],
    props: props$r,
    computed: computed$b,
    methods: methods$B,
    watch: watch$k,
    created: function created() {
      var _this3 = this;

      this._view = new View();
      this._controls = this.controls !== false ? control.defaults(_typeof(this.controls) === 'object' ? this.controls : undefined) : new Collection();
      this._interactions = interaction.defaults();
      this._layers = new Collection();
      this._overlays = new Collection(); // prepare default overlay

      this._defaultOverlayFeatures = new Collection();
      this._defaultOverlay = new VectorLayer({
        source: new VectorSource({
          features: this._defaultOverlayFeatures,
          wrapX: this.wrapX
        })
      });

      defineProperties$1(this,
      /** @lends module:map/map# */
      {
        /**
         * OpenLayers map instance.
         * @type {Map|undefined}
         */
        $map: {
          enumerable: true,
          get: function get$$1() {
            return _this3.$olObject;
          }
        },

        /**
         * OpenLayers view instance.
         * @type {View|undefined}
         */
        $view: {
          enumerable: true,
          get: function get$$1() {
            return _this3._view;
          }
        }
      });
    }
  };
  /**
   * Subscribe to OL map events.
   *
   * @return {void}
   * @private
   */

  function subscribeToMapEvents() {
    var _this4 = this;

    hasMap(this);
    hasView(this);
    var ft = 100; // pointer

    var pointerEvents = merge(fromOlEvent(this.$map, ['click', 'dblclick', 'singleclick']), fromOlEvent(this.$map, ['pointerdrag', 'pointermove']).pipe(throttleTime(ft), distinctUntilChanged(function (a, b) {
      return isEqual(a.coordinate, b.coordinate);
    }))).pipe(map$3(function (evt) {
      return _objectSpread({}, evt, {
        coordinate: _this4.pointToDataProj(evt.coordinate)
      });
    })); // other

    var otherEvents = fromOlEvent(this.$map, ['movestart', 'moveend', 'postrender', 'rendercomplete', 'precompose', 'postcompose']);
    var events = merge(pointerEvents, otherEvents);
    this.subscribeTo(events, function (evt) {
      return _this4.$emit(evt.type, evt);
    });
  }
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:map/map#click
   * @type {MapBrowserEvent}
   */

  /**
   * A true double click, with no dragging.
   * @event module:map/map#dblclick
   * @type {MapBrowserEvent}
   */

  /* script */
  var __vue_script__$g = script$g;
  /* template */

  var __vue_render__$3 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: [_vm.$options.name],
      attrs: {
        "tabindex": _vm.tabindex
      }
    }, [_vm._t("default")], 2);
  };

  var __vue_staticRenderFns__$3 = [];
  /* style */

  var __vue_inject_styles__$g = undefined;
  /* scoped */

  var __vue_scope_id__$g = undefined;
  /* module identifier */

  var __vue_module_identifier__$g = undefined;
  /* functional template */

  var __vue_is_functional_template__$g = false;
  /* component normalizer */

  function __vue_normalize__$g(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "map.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Map$1 = __vue_normalize__$g({
    render: __vue_render__$3,
    staticRenderFns: __vue_staticRenderFns__$3
  }, __vue_inject_styles__$g, __vue_script__$g, __vue_scope_id__$g, __vue_is_functional_template__$g, __vue_module_identifier__$g, undefined, undefined);

  /** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */
  function distinctUntilKeyChanged(key, compare) {
      return distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
  }

  /**
   * @vueProps
   */

  var props$s =
  /** @lends module:map/view# */
  {
    /**
     * The center coordinate in the view projection.
     * @type {number[]}
     * @default [0, 0]
     * @vueSync
     */
    center: {
      type: Array,
      default: function _default() {
        return [0, 0];
      },
      validator: function validator(value) {
        return value.length === 2;
      }
    },
    constrainRotation: {
      type: [Boolean, Number],
      default: true
    },
    enableRotation: {
      type: Boolean,
      default: true
    },

    /**
     * The extent that constrains the center defined in the view projection,
     * in other words, center cannot be set outside this extent.
     * @default undefined
     */
    extent: {
      type: Array,
      validator: function validator(value) {
        return value.length === 4;
      }
    },
    maxResolution: Number,
    minResolution: Number,

    /**
     * @default 28
     */
    maxZoom: {
      type: Number,
      default: MAX_ZOOM
    },

    /**
     * @default 0
     */
    minZoom: {
      type: Number,
      default: MIN_ZOOM
    },

    /**
     * @type {string}
     * @default EPSG:3857
     */
    projection: {
      type: String,
      default: EPSG_3857
    },
    resolution: Number,
    resolutions: Array,

    /**
     * The initial rotation for the view in **radians** (positive rotation clockwise).
     * @type {number}
     * @vueSync
     */
    rotation: {
      type: Number,
      default: 0
    },

    /**
     * Zoom level used to calculate the resolution for the view as `int` value. Only used if `resolution` is not defined.
     * @type {number}
     * @default 0
     * @vueSync
     */
    zoom: {
      type: Number,
      default: MIN_ZOOM
    },

    /**
     * @default 2
     */
    zoomFactor: {
      type: Number,
      default: ZOOM_FACTOR
    }
    /**
     * @vueComputed
     */

  };
  var computed$c =
  /** @lends module:map/view# */
  {
    viewZoom: function viewZoom() {
      if (this.rev && this.$view) {
        return Math.round(this.$view.getZoom());
      }

      return this.zoom;
    },
    viewRotation: function viewRotation() {
      if (this.rev && this.$view) {
        return this.$view.getRotation();
      }

      return this.rotation;
    },
    viewResolution: function viewResolution() {
      if (this.rev && this.$view) {
        return this.$view.getResolution();
      }

      return this.resolution;
    },
    viewCenter: function viewCenter() {
      if (this.rev && this.$view) {
        return this.pointToDataProj(this.$view.getCenter());
      }
    },
    viewCenterViewProj: function viewCenterViewProj() {
      if (this.rev && this.$view) {
        return this.$view.getCenter();
      }
    },

    /**
     * @return {ProjectionLike}
     */
    resolvedDataProjection: function resolvedDataProjection() {
      // exclude this.projection from lookup to allow view rendering in projection
      // that differs from data projection
      return coalesce(this.$viewContainer && this.$viewContainer.resolvedDataProjection, this.$options.dataProjection, this.viewProjection);
    }
  };
  /**
   * @vueMethods
   */

  var methods$C =
  /** @lends module:map/view# */
  {
    /**
     * @see {@link https://openlayers.org/en/latest/apidoc/ol.View.html#animate}
     * @param {...(AnimationOptions|function(boolean))} args
     * @return {Promise} Resolves when animation completes
     */
    animate: function animate() {
      var _this = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      hasView(this);
      var cb = noop;

      if (isFunction(args[args.length - 1])) {
        cb = args[args.length - 1];
        args = args.slice(0, args.length - 1);
      }

      args.forEach(function (opts) {
        if (!isArray$1(opts.center)) return;
        opts.center = _this.pointToViewProj(opts.center);
      });
      return new promise$1(function (resolve) {
        var _this$$view;

        return (_this$$view = _this.$view).animate.apply(_this$$view, _toConsumableArray(args).concat([function (complete) {
          cb(complete);
          resolve(complete);
        }]));
      });
    },

    /**
     * @return {View}
     * @protected
     */
    createOlObject: function createOlObject() {
      return new View({
        center: this.pointToViewProj(this.center),
        constrainRotation: this.constrainRotation,
        enableRotation: this.enableRotation,
        extent: this.extent ? this.extentToViewProj(this.extent) : undefined,
        maxResolution: this.maxResolution,
        minResolution: this.minResolution,
        maxZoom: this.maxZoom,
        minZoom: this.minZoom,
        projection: this.projection,
        resolution: this.resolution,
        resolutions: this.resolutions,
        rotation: this.rotation,
        zoom: this.zoom,
        zoomFactor: this.zoomFactor
      });
    },

    /**
     * @see {@link https://openlayers.org/en/latest/apidoc/ol.View.html#fit}
     * @param {Object|Extent|Geometry|Vue} geometryOrExtent
     * @param {FitOptions} [options]
     * @return {Promise} Resolves when view changes
     */
    fit: function fit(geometryOrExtent) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      hasView(this); // transform from GeoJSON, vl-feature to ol.Feature

      if (isPlainObject(geometryOrExtent)) {
        geometryOrExtent = this.readGeometryInDataProj(geometryOrExtent);
      } else if (geometryOrExtent instanceof Vue) {
        geometryOrExtent = geometryOrExtent.$geometry;
      }

      var cb = options.callback || noop;
      return new promise$1(function (resolve) {
        _this2.$view.fit(geometryOrExtent, _objectSpread({}, options, {
          callback: function callback(complete) {
            cb(complete);
            resolve(complete);
          }
        }));
      });
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      this.$viewContainer && this.$viewContainer.setView(this);
      this.subscribeAll();
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.unsubscribeAll();
      this.$viewContainer && this.$viewContainer.setView(undefined);
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      subscribeToViewChanges.call(this);
    }
  };
  var watch$l = {
    center: function center(value) {
      value = this.pointToViewProj(value);

      if (this.$view && !this.$view.getAnimating() && !isEqual(value, this.viewCenterViewProj)) {
        this.$view.setCenter(value);
      }
    },
    resolution: function resolution(value) {
      if (this.$view && !this.$view.getAnimating() && value !== this.viewResolution) {
        this.$view.setResolution(value);
      }
    },
    zoom: function zoom(value) {
      value = Math.round(value);

      if (this.$view && !this.$view.getAnimating() && value !== this.viewZoom) {
        this.$view.setZoom(value);
      }
    },
    rotation: function rotation(value) {
      if (this.$view && !this.$view.getAnimating() && value !== this.viewRotation) {
        this.$view.setRotation(value);
      }
    },
    minZoom: function minZoom(value) {
      if (this.$view && value !== this.$view.getMinZoom()) {
        this.$view.setMinZoom(value);
      }
    },
    maxZoom: function maxZoom(value) {
      if (this.$view && value !== this.$view.getMaxZoom()) {
        this.$view.setMaxZoom(value);
      }
    },
    resolvedDataProjection: function resolvedDataProjection() {
      if (this.$view) {
        this.$view.setCenter(this.pointToViewProj(this.center));
      }
    }
  };
  /**
   * Represents a simple **2D view** of the map. This is the component to act upon to change the **center**,
   * **resolution**, and **rotation** of the map.
   *
   * @title View `vl-view` component
   * @alias module:map/view
   * @vueProto
   *
   * @vueSlot default [scoped] Default scoped slot with current state: center, zoom, rotation & etc.
   */

  var script$h = {
    name: 'vl-view',
    mixins: [cmp, projTransforms],
    props: props$s,
    computed: computed$c,
    methods: methods$C,
    watch: watch$l,
    stubVNode: {
      empty: function empty() {
        return this.$options.name;
      }
    },

    /**
     * @this module:map/view
     */
    created: function created() {
      var _this3 = this;

      defineProperties$1(this,
      /** @lends module:map/view# */
      {
        /**
         * @type {View|undefined}
         */
        $view: {
          enumerable: true,
          get: function get$$1() {
            return _this3.$olObject;
          }
        },
        $viewContainer: {
          enumerable: true,
          get: function get$$1() {
            return _this3.$services && _this3.$services.viewContainer;
          }
        }
      });
    }
  };
  /**
   * Subscribe to OpenLayers significant events
   * @return {void}
   * @private
   */

  function subscribeToViewChanges() {
    var _this4 = this;

    hasView(this);
    var ft = 1000 / 60;
    var resolution = fromOlChangeEvent(this.$view, 'resolution', true, ft);
    var zoom = resolution.pipe(map$3(function () {
      return {
        prop: 'zoom',
        value: Math.round(_this4.$view.getZoom())
      };
    }), distinctUntilKeyChanged('value'));
    var changes = merge(fromOlChangeEvent(this.$view, 'center', true, ft, function () {
      return _this4.pointToDataProj(_this4.$view.getCenter());
    }), fromOlChangeEvent(this.$view, 'rotation', true, ft), resolution, zoom);
    this.subscribeTo(changes, function (_ref) {
      var prop = _ref.prop,
          value = _ref.value;
      ++_this4.rev;

      _this4.$emit("update:".concat(prop), value);
    });
  }

  /* script */
  var __vue_script__$h = script$h;
  /* template */

  var __vue_render__$4 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: [_vm.$options.name],
      staticStyle: {
        "display": "none !important"
      }
    }, [_vm._t("default", null, {
      center: _vm.viewCenter,
      zoom: _vm.viewZoom,
      resolution: _vm.viewResolution,
      rotation: _vm.viewRotation
    })], 2);
  };

  var __vue_staticRenderFns__$4 = [];
  /* style */

  var __vue_inject_styles__$h = undefined;
  /* scoped */

  var __vue_scope_id__$h = undefined;
  /* module identifier */

  var __vue_module_identifier__$h = undefined;
  /* functional template */

  var __vue_is_functional_template__$h = false;
  /* component normalizer */

  function __vue_normalize__$h(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "view.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var View$1 = __vue_normalize__$h({
    render: __vue_render__$4,
    staticRenderFns: __vue_staticRenderFns__$4
  }, __vue_inject_styles__$h, __vue_script__$h, __vue_scope_id__$h, __vue_is_functional_template__$h, __vue_module_identifier__$h, undefined, undefined);

  function plugin$g(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$g.installed) {
      return;
    }

    plugin$g.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Map$1, options);

    assign$1(View$1, options);

    Vue$$1.component(Map$1.name, Map$1);
    Vue$$1.component(View$1.name, View$1);
  }

  var Map$2 = /*#__PURE__*/Object.freeze({
    default: plugin$g,
    Map: Map$1,
    View: View$1,
    install: plugin$g
  });

  var MAPBOX_URL_TEMPLATE = 'https://{a-c}.tiles.mapbox.com/v4/{mapId}/{z}/{x}/{y}{tileNameSuffix}.{tileFormat}?access_token={accessToken}';
  var MAPBOX_ATTRIBUTIONS = '&copy; <a href="https://www.mapbox.com/" target="_blank">MapBox</a>, ' + new Date().getFullYear();
  var props$t = {
    accessToken: {
      type: String,
      required: true
    },
    attributions: {
      type: [String, Array],
      default: MAPBOX_ATTRIBUTIONS
    },
    mapId: {
      type: String,
      required: true
    },
    projection: {
      type: String,
      default: EPSG_3857
    },
    tileFormat: {
      type: String,
      default: TILE_FORMAT
    },
    url: {
      type: String,
      default: MAPBOX_URL_TEMPLATE
    }
  };
  var computed$d = {
    /**
     * @type {string}
     */
    tileNameSuffix: function tileNameSuffix() {
      return _tileNameSuffix(this.tilePixelRatio);
    },

    /**
     * @type {string[]}
     */
    urlTokens: function urlTokens() {
      return ['mapId', 'accessToken', 'tileNameSuffix', 'tileFormat'];
    }
  };
  var script$i = {
    name: 'vl-source-mapbox',
    mixins: [xyzSource],
    props: props$t,
    computed: computed$d
    /**
     * @param {number} [ratio]
     * @returns {number}
     * @private
     */

  };

  function tileRatio(ratio) {
    ratio = coalesce(ratio, 1);
    return ratio > 1 ? 2 : 1;
  }
  /**
   * @param {number} [ratio]
   * @returns {string}
   * @private
   */


  function _tileNameSuffix(ratio) {
    ratio = tileRatio(ratio);
    return ratio > 1 ? ['@', ratio, 'x'].join('') : '';
  }

  /* script */
  var __vue_script__$i = script$i;
  /* template */

  /* style */

  var __vue_inject_styles__$i = undefined;
  /* scoped */

  var __vue_scope_id__$i = undefined;
  /* module identifier */

  var __vue_module_identifier__$i = undefined;
  /* functional template */

  var __vue_is_functional_template__$i = undefined;
  /* component normalizer */

  function __vue_normalize__$i(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$5 = __vue_normalize__$i({}, __vue_inject_styles__$i, __vue_script__$i, __vue_scope_id__$i, __vue_is_functional_template__$i, __vue_module_identifier__$i, undefined, undefined);

  function plugin$h(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$h.installed) {
      return;
    }

    plugin$h.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$5, options);

    Vue$$1.component(Source$5.name, Source$5);
  }

  var MapboxSource = /*#__PURE__*/Object.freeze({
    default: plugin$h,
    Source: Source$5,
    install: plugin$h
  });

  /**
   * @vueProps
   */

  var props$u = {
    /**
     * Source or collection identifier from IdentityMap.
     * @type {String}
     */
    source: {
      type: String,
      required: true
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event will be
     * considered to add or move a vertex to the sketch. Default is `ol.events.condition.primaryAction`.
     * @type {function|undefined}
     */
    condition: {
      type: Function,
      default: condition.primaryAction
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * By default, `ol.events.condition.singleClick` with `ol.events.condition.altKeyOnly` results in a vertex deletion.
     * @type {function|undefined}
     */
    deleteCondition: {
      type: Function,
      default: condition.altKeyOnly
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether a new vertex can be added
     * to the sketch features. Default is `ol.events.condition.always`.
     * @type {function|undefined}
     */
    insertVertexCondition: {
      type: Function,
      default: condition.always
    },

    /**
     * Pixel tolerance for considering the pointer close enough to a segment or vertex for editing.
     * @type {number}
     */
    pixelTolerance: {
      type: Number,
      default: 10
    },

    /**
     * Wrap the world horizontally on the sketch overlay.
     * @type {boolean}
     */
    wrapX: {
      type: Boolean,
      default: false
    }
    /**
     * @vueMethods
     */

  };
  var methods$D = {
    /**
     * @return {Promise<Modify>}
     * @protected
     */
    createInteraction: function () {
      var _createInteraction = _asyncToGenerator(
      /*#__PURE__*/
      regenerator.mark(function _callee() {
        var sourceIdent, source, features;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                sourceIdent = this.makeIdent(this.source);
                _context.next = 3;
                return this.$identityMap.get(sourceIdent, this.$options.INSTANCE_PROMISE_POOL);

              case 3:
                source = _context.sent;

                if (isFunction(source.getFeatures)) {
                  features = source.getFeatures();

                  if (isCollection(features)) {
                    source = features;
                  }
                }

                return _context.abrupt("return", new ModifyInteraction({
                  source: isVectorSource(source) ? source : undefined,
                  features: isCollection(source) ? source : undefined,
                  deleteCondition: this.deleteCondition,
                  insertVertexCondition: this.insertVertexCondition,
                  pixelTolerance: this.pixelTolerance,
                  style: this.createStyleFunc(),
                  wrapX: this.wrapX
                }));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function createInteraction() {
        return _createInteraction.apply(this, arguments);
      };
    }(),

    /**
     * @return {function(feature: Feature): Style}
     * @protected
     */
    getDefaultStyles: function getDefaultStyles() {
      var defaultStyles = mapValues(defaultEditStyle(), function (styles) {
        return styles.map(createStyle);
      });
      return function __selectDefaultStyleFunc(feature) {
        if (feature.getGeometry()) {
          return defaultStyles[feature.getGeometry().getType()];
        }
      };
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      return multiMergeDescriptors(interaction$1.methods.getServices.call(this), stylesContainer.methods.getServices.call(this));
    },

    /**
     * @return {Interaction|undefined}
     * @protected
     */
    getStyleTarget: function getStyleTarget() {
      return this.$interaction;
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      interaction$1.methods.mount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      interaction$1.methods.unmount.call(this);
    },

    /**
     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles
     * @return {void}
     * @protected
     */
    setStyle: function setStyle(styles) {
      if (styles !== this._styles) {
        this._styles = styles;
        this.scheduleRefresh();
      }
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      subscribeToInteractionChanges$1.call(this);
    }
  };
  var watch$m = makeWatchers(['source'], function () {
    return function () {
      this.scheduleRecreate();
    };
  });
  /**
   * @vueProto
   * @alias module:modify-interaction/interaction
   * @title vl-interaction-modify
   */

  var script$j = {
    name: 'vl-interaction-modify',
    mixins: [interaction$1, stylesContainer],
    props: props$u,
    methods: methods$D,
    watch: watch$m
    /**
     * @private
     */

  };

  function subscribeToInteractionChanges$1() {
    var _this = this;

    hasInteraction(this);
    var modifyEvents = fromOlEvent(this.$interaction, ['modifystart', 'modifyend']);
    this.subscribeTo(modifyEvents, function (evt) {
      ++_this.rev;

      _this.$emit(evt.type, evt);
    });
  }

  /* script */
  var __vue_script__$j = script$j;
  /* template */

  /* style */

  var __vue_inject_styles__$j = undefined;
  /* scoped */

  var __vue_scope_id__$j = undefined;
  /* module identifier */

  var __vue_module_identifier__$j = undefined;
  /* functional template */

  var __vue_is_functional_template__$j = undefined;
  /* component normalizer */

  function __vue_normalize__$j(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "interaction.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Interaction$2 = __vue_normalize__$j({}, __vue_inject_styles__$j, __vue_script__$j, __vue_scope_id__$j, __vue_is_functional_template__$j, __vue_module_identifier__$j, undefined, undefined);

  function plugin$i(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$i.installed) {
      return;
    }

    plugin$i.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Interaction$2, options);

    Vue$$1.component(Interaction$2.name, Interaction$2);
  }

  var ModifyInteraction$1 = /*#__PURE__*/Object.freeze({
    default: plugin$i,
    Interaction: Interaction$2,
    install: plugin$i
  });

  var props$v = {};
  var computed$e = {
    type: constant(GEOMETRY_TYPE.MULTI_LINE_STRING)
  };
  var methods$E = {
    /**
     * @returns {MultiLineString}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new MultiLineString(this.toViewProj(this.coordinates));
    }
  };
  var script$k = {
    name: 'vl-geom-multi-line-string',
    mixins: [geometry$3],
    props: props$v,
    computed: computed$e,
    methods: methods$E
  };

  /* script */
  var __vue_script__$k = script$k;
  /* template */

  /* style */

  var __vue_inject_styles__$k = undefined;
  /* scoped */

  var __vue_scope_id__$k = undefined;
  /* module identifier */

  var __vue_module_identifier__$k = undefined;
  /* functional template */

  var __vue_is_functional_template__$k = undefined;
  /* component normalizer */

  function __vue_normalize__$k(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "geom.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Geom$2 = __vue_normalize__$k({}, __vue_inject_styles__$k, __vue_script__$k, __vue_scope_id__$k, __vue_is_functional_template__$k, __vue_module_identifier__$k, undefined, undefined);

  function plugin$j(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$j.installed) {
      return;
    }

    plugin$j.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Geom$2, options);

    Vue$$1.component(Geom$2.name, Geom$2);
  }

  var MultiLineStringGeom = /*#__PURE__*/Object.freeze({
    default: plugin$j,
    Geom: Geom$2,
    install: plugin$j
  });

  var props$w = {};
  var computed$f = {
    type: constant(GEOMETRY_TYPE.MULTI_POINT)
  };
  var methods$F = {
    /**
     * @returns {MultiPoint}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new MultiPoint(this.toViewProj(this.coordinates));
    }
  };
  var script$l = {
    name: 'vl-geom-multi-point',
    mixins: [geometry$3],
    props: props$w,
    computed: computed$f,
    methods: methods$F
  };

  /* script */
  var __vue_script__$l = script$l;
  /* template */

  /* style */

  var __vue_inject_styles__$l = undefined;
  /* scoped */

  var __vue_scope_id__$l = undefined;
  /* module identifier */

  var __vue_module_identifier__$l = undefined;
  /* functional template */

  var __vue_is_functional_template__$l = undefined;
  /* component normalizer */

  function __vue_normalize__$l(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "geom.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Geom$3 = __vue_normalize__$l({}, __vue_inject_styles__$l, __vue_script__$l, __vue_scope_id__$l, __vue_is_functional_template__$l, __vue_module_identifier__$l, undefined, undefined);

  function plugin$k(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$k.installed) {
      return;
    }

    plugin$k.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Geom$3, options);

    Vue$$1.component(Geom$3.name, Geom$3);
  }

  var MultiPointGeom = /*#__PURE__*/Object.freeze({
    default: plugin$k,
    Geom: Geom$3,
    install: plugin$k
  });

  var props$x = {};
  var computed$g = {
    type: constant(GEOMETRY_TYPE.MULTI_POLYGON)
  };
  var methods$G = {
    /**
     * @returns {MultiPolygon}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new MultiPolygon(this.toViewProj(this.coordinates));
    }
  };
  var script$m = {
    name: 'vl-geom-multi-polygon',
    mixins: [geometry$3],
    props: props$x,
    computed: computed$g,
    methods: methods$G
  };

  /* script */
  var __vue_script__$m = script$m;
  /* template */

  /* style */

  var __vue_inject_styles__$m = undefined;
  /* scoped */

  var __vue_scope_id__$m = undefined;
  /* module identifier */

  var __vue_module_identifier__$m = undefined;
  /* functional template */

  var __vue_is_functional_template__$m = undefined;
  /* component normalizer */

  function __vue_normalize__$m(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "geom.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Geom$4 = __vue_normalize__$m({}, __vue_inject_styles__$m, __vue_script__$m, __vue_scope_id__$m, __vue_is_functional_template__$m, __vue_module_identifier__$m, undefined, undefined);

  function plugin$l(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$l.installed) {
      return;
    }

    plugin$l.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Geom$4, options);

    Vue$$1.component(Geom$4.name, Geom$4);
  }

  var MultiPolygonGeom = /*#__PURE__*/Object.freeze({
    default: plugin$l,
    Geom: Geom$4,
    install: plugin$l
  });

  var OSM_ATTRIBUTIONS = '&copy; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
  var OSM_URL_TEMPLATE = 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';
  var OSM_MAX_ZOOM = 19;
  var props$y = {
    attributions: {
      type: [String, Array],
      default: OSM_ATTRIBUTIONS
    },
    maxZoom: {
      type: Number,
      default: OSM_MAX_ZOOM
    },
    url: {
      type: String,
      default: OSM_URL_TEMPLATE
    }
  };
  var methods$H = {
    createSource: function createSource() {
      // always EPSG:3857, size: 256x256, format png
      return new OSMSource({
        url: this.urlTmpl,
        attributions: this.attributions,
        crossOrigin: this.crossOrigin,
        maxZoom: this.maxZoom,
        cacheSize: this.cacheSize,
        opaque: this.opaque,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        wrapX: this.wrapX,
        transition: this.transition
      });
    }
  };
  var script$n = {
    name: 'vl-source-osm',
    mixins: [xyzSource],
    props: props$y,
    methods: methods$H
  };

  /* script */
  var __vue_script__$n = script$n;
  /* template */

  /* style */

  var __vue_inject_styles__$n = undefined;
  /* scoped */

  var __vue_scope_id__$n = undefined;
  /* module identifier */

  var __vue_module_identifier__$n = undefined;
  /* functional template */

  var __vue_is_functional_template__$n = undefined;
  /* component normalizer */

  function __vue_normalize__$n(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$6 = __vue_normalize__$n({}, __vue_inject_styles__$n, __vue_script__$n, __vue_scope_id__$n, __vue_is_functional_template__$n, __vue_module_identifier__$n, undefined, undefined);

  function plugin$m(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$m.installed) {
      return;
    }

    plugin$m.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$6, options);

    Vue$$1.component(Source$6.name, Source$6);
  }

  var OsmSource = /*#__PURE__*/Object.freeze({
    default: plugin$m,
    Source: Source$6,
    install: plugin$m
  });

  var props$z = {
    id: {
      type: [String, Number],
      default: function _default() {
        return v4_1();
      }
    },
    offset: {
      type: Array,
      default: function _default() {
        return [0, 0];
      },
      validator: function validator(value) {
        return value.length === 2;
      }
    },

    /**
     * Coordinates in the map view projection.
     * @type {number[]}
     */
    position: {
      type: Array,
      validator: function validator(value) {
        return value.length === 2;
      },
      required: true
    },
    positioning: {
      type: String,
      default: OVERLAY_POSITIONING.TOP_LEFT,
      validator: function validator(value) {
        return values$1(OVERLAY_POSITIONING).includes(value);
      }
    },
    stopEvent: {
      type: Boolean,
      default: true
    },
    insertFirst: {
      type: Boolean,
      default: true
    },
    autoPan: {
      type: Boolean,
      default: false
    },
    autoPanMargin: {
      type: Number,
      default: 20
    },
    autoPanAnimation: Object
    /**
     * @vueComputed
     */

  };
  var computed$h = {
    positionViewProj: function positionViewProj() {
      if (this.rev && this.$overlay) {
        return this.$overlay.getPosition();
      }
    },
    positionDataProj: function positionDataProj() {
      if (this.rev && this.$overlay) {
        return this.pointToDataProj(this.$overlay.getPosition());
      }
    },
    classes: function classes() {
      return [this.$options.name, this.visible ? 'visible' : undefined].filter(identity);
    }
  };
  /**
   * @vueMethods
   */

  var methods$I =
  /** @lends module:overlay/overlay# */
  {
    /**
     * @return {Overlay}
     * @protected
     */
    createOlObject: function createOlObject() {
      return new Overlay({
        id: this.id,
        offset: this.offset,
        position: this.pointToViewProj(this.position),
        positioning: this.positioning,
        stopEvent: this.stopEvent,
        insertFirst: this.insertFirst,
        autoPan: this.autoPan,
        autoPanMargin: this.autoPanMargin,
        autoPanAnimation: this.autoPanAnimation
      });
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      var _this = this;

      hasOverlay(this);
      this.$overlay.setElement(this.$el);
      this.$overlaysContainer && this.$overlaysContainer.addOverlay(this.$overlay); // reset position to trigger panIntoView

      this.$nextTick(function () {
        _this.$overlay.setPosition(_this.positionViewProj.slice());

        _this.visible = true;
      });
      this.subscribeAll();
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      hasOverlay(this);
      this.unsubscribeAll();
      this.$overlay.setElement(undefined);
      this.$overlaysContainer && this.$overlaysContainer.removeOverlay(this.$overlay);
      this.visible = false;
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      subscribeToOverlayChanges.call(this);
    }
  };
  var watch$n = {
    offset: function offset(value) {
      if (this.$overlay && !isEqual(value, this.$overlay.getOffset())) {
        this.$overlay.setOffset(value);
      }
    },
    position: function position(value) {
      value = this.pointToViewProj(value);

      if (this.$overlay && !isEqual(value, this.positionViewProj)) {
        this.$overlay.setPosition(value);
      }
    },
    positioning: function positioning(value) {
      if (this.$overlay && value !== this.$overlay.getPositioning()) {
        this.$overlay.setPositioning(value);
      }
    },
    resolvedDataProjection: function resolvedDataProjection() {
      if (this.$overlay) {
        this.$overlay.setPosition(this.pointToViewProj(this.position));
      }
    }
  };
  /**
   * @alias module:overlay/overlay
   * @title vl-overlay
   * @vueProto
   */

  var script$o = {
    name: 'vl-overlay',
    mixins: [cmp, useMapCmp, projTransforms],
    props: props$z,
    computed: computed$h,
    methods: methods$I,
    watch: watch$n,
    created: function created() {
      var _this2 = this;

      defineProperties$1(this,
      /** @lends module:overlay/overlay# */
      {
        /**
         * @type {Overlay|undefined}
         */
        $overlay: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$olObject;
          }
        },
        $map: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.map;
          }
        },
        $view: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.view;
          }
        },
        $overlaysContainer: {
          enumerable: true,
          get: function get$$1() {
            return _this2.$services && _this2.$services.overlaysContainer;
          }
        }
      });
    },
    data: function data() {
      return {
        visible: false
      };
    }
  };
  /**
   * @return {void}
   * @private
   */

  function subscribeToOverlayChanges() {
    var _this3 = this;

    hasOverlay(this);
    var ft = 1000 / 60;
    var changes = merge(fromOlChangeEvent(this.$overlay, 'position', true, ft, function () {
      return _this3.pointToDataProj(_this3.$overlay.getPosition());
    }), fromOlChangeEvent(this.$overlay, ['offset', 'positioning'], true, ft));
    this.subscribeTo(changes, function (_ref) {
      var prop = _ref.prop,
          value = _ref.value;
      ++_this3.rev;

      _this3.$emit("update:".concat(prop), value);
    });
  }

  /* script */
  var __vue_script__$o = script$o;
  /* template */

  var __vue_render__$5 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: _vm.classes,
      attrs: {
        "id": [_vm.$options.name, _vm.id].join('-')
      }
    }, [_vm._t("default", null, {
      id: _vm.id,
      position: _vm.position,
      offset: _vm.offset,
      positioning: _vm.positioning
    })], 2);
  };

  var __vue_staticRenderFns__$5 = [];
  /* style */

  var __vue_inject_styles__$o = undefined;
  /* scoped */

  var __vue_scope_id__$o = undefined;
  /* module identifier */

  var __vue_module_identifier__$o = undefined;
  /* functional template */

  var __vue_is_functional_template__$o = false;
  /* component normalizer */

  function __vue_normalize__$o(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "overlay.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Overlay$1 = __vue_normalize__$o({
    render: __vue_render__$5,
    staticRenderFns: __vue_staticRenderFns__$5
  }, __vue_inject_styles__$o, __vue_script__$o, __vue_scope_id__$o, __vue_is_functional_template__$o, __vue_module_identifier__$o, undefined, undefined);

  function plugin$n(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$n.installed) {
      return;
    }

    plugin$n.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Overlay$1, options);

    Vue$$1.component(Overlay$1.name, Overlay$1);
  }

  var Overlay$2 = /*#__PURE__*/Object.freeze({
    default: plugin$n,
    Overlay: Overlay$1,
    install: plugin$n
  });

  var props$A = {
    coordinates: {
      type: Array,
      required: true,
      validator: function validator(value) {
        return value.length >= 2;
      }
    }
  };
  var computed$i = {
    type: constant(GEOMETRY_TYPE.POINT)
  };
  var methods$J = {
    /**
     * @return {Point}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new Point(this.toViewProj(this.coordinates));
    }
  };
  var script$p = {
    name: 'vl-geom-point',
    mixins: [geometry$3],
    props: props$A,
    computed: computed$i,
    methods: methods$J
  };

  /* script */
  var __vue_script__$p = script$p;
  /* template */

  /* style */

  var __vue_inject_styles__$p = undefined;
  /* scoped */

  var __vue_scope_id__$p = undefined;
  /* module identifier */

  var __vue_module_identifier__$p = undefined;
  /* functional template */

  var __vue_is_functional_template__$p = undefined;
  /* component normalizer */

  function __vue_normalize__$p(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "geom.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Geom$5 = __vue_normalize__$p({}, __vue_inject_styles__$p, __vue_script__$p, __vue_scope_id__$p, __vue_is_functional_template__$p, __vue_module_identifier__$p, undefined, undefined);

  function plugin$o(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$o.installed) {
      return;
    }

    plugin$o.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Geom$5, options);

    Vue$$1.component(Geom$5.name, Geom$5);
  }

  var PointGeom = /*#__PURE__*/Object.freeze({
    default: plugin$o,
    Geom: Geom$5,
    install: plugin$o
  });

  var props$B = {};
  var computed$j = {
    type: constant(GEOMETRY_TYPE.POLYGON)
  };
  var methods$K = {
    /**
     * @returns {Polygon}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new Polygon__default(this.toViewProj(this.coordinates));
    }
  };
  var script$q = {
    name: 'vl-geom-polygon',
    mixins: [geometry$3],
    props: props$B,
    computed: computed$j,
    methods: methods$K
  };

  /* script */
  var __vue_script__$q = script$q;
  /* template */

  /* style */

  var __vue_inject_styles__$q = undefined;
  /* scoped */

  var __vue_scope_id__$q = undefined;
  /* module identifier */

  var __vue_module_identifier__$q = undefined;
  /* functional template */

  var __vue_is_functional_template__$q = undefined;
  /* component normalizer */

  function __vue_normalize__$q(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "geom.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Geom$6 = __vue_normalize__$q({}, __vue_inject_styles__$q, __vue_script__$q, __vue_scope_id__$q, __vue_is_functional_template__$q, __vue_module_identifier__$q, undefined, undefined);

  function plugin$p(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$p.installed) {
      return;
    }

    plugin$p.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Geom$6, options);

    Vue$$1.component(Geom$6.name, Geom$6);
  }

  var PolygonGeom = /*#__PURE__*/Object.freeze({
    default: plugin$p,
    Geom: Geom$6,
    install: plugin$p
  });

  var props$C = {
    points: {
      type: Number,
      required: true
    },
    radius: Number,
    radius1: Number,
    radius2: Number,
    angle: {
      type: Number,
      default: 0
    },
    rotation: {
      type: Number,
      default: 0
    },
    rotateWithView: {
      type: Boolean,
      default: false
    }
  };
  var methods$L = {
    /**
     * @return {RegularShape}
     * @protected
     */
    createStyle: function createStyle() {
      return RegularShape({
        points: this.points,
        radius: this.radius,
        radius1: this.radius1,
        radius2: this.radius2,
        angle: this.angle,
        rotation: this.rotation,
        rotateWithView: this.rotateWithView,
        fill: this._fill,
        stroke: this._stroke
      });
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(imageStyle.methods.getServices.call(this), {
        get stylesContainer() {
          return vm;
        }

      });
    },

    /**
     * @param {Fill|Vue|undefined} fill
     * @return {void}
     */
    setFill: function setFill(fill) {
      fill = fill instanceof Vue ? fill.$style : fill;

      if (fill !== this._fill) {
        this._fill = fill;
        this.scheduleRefresh();
      }
    },

    /**
     * @param {Stroke|Vue|undefined} stroke
     * @return {void}
     */
    setStroke: function setStroke(stroke) {
      stroke = stroke instanceof Vue ? stroke.$style : stroke;

      if (stroke !== this._stroke) {
        this._stroke = stroke;
        this.scheduleRefresh();
      }
    }
  };
  var watch$o = {
    points: function points(value) {
      if (this.$style && !isEqual(value, this.$style.getPoints())) {
        this.scheduleRefresh();
      }
    },
    radius: function radius(value) {
      if (this.$style && !isEqual(value, this.$style.getRadius())) {
        this.scheduleRefresh();
      }
    },
    radius1: function radius1(value) {
      if (this.$style && !isEqual(value, this.$style.getRadius())) {
        this.scheduleRefresh();
      }
    },
    radius2: function radius2(value) {
      if (this.$style && !isEqual(value, this.$style.getRadius2())) {
        this.scheduleRefresh();
      }
    },
    angle: function angle(value) {
      if (this.$style && !isEqual(value, this.$style.getAngle())) {
        this.scheduleRefresh();
      }
    },
    rotation: function rotation(value) {
      if (this.$style && !isEqual(value, this.$style.getRotation())) {
        this.scheduleRefresh();
      }
    },
    rotateWithView: function rotateWithView(value) {
      if (this.$style && !isEqual(value, this.$style.getRotateWithView())) {
        this.scheduleRefresh();
      }
    }
  };
  var script$r = {
    name: 'vl-style-reg-shape',
    mixins: [imageStyle, withFillStrokeStyle],
    props: props$C,
    methods: methods$L,
    watch: watch$o
  };

  /* script */
  var __vue_script__$r = script$r;
  /* template */

  /* style */

  var __vue_inject_styles__$r = undefined;
  /* scoped */

  var __vue_scope_id__$r = undefined;
  /* module identifier */

  var __vue_module_identifier__$r = undefined;
  /* functional template */

  var __vue_is_functional_template__$r = undefined;
  /* component normalizer */

  function __vue_normalize__$r(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "style.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Style$4 = __vue_normalize__$r({}, __vue_inject_styles__$r, __vue_script__$r, __vue_scope_id__$r, __vue_is_functional_template__$r, __vue_module_identifier__$r, undefined, undefined);

  function plugin$q(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$q.installed) {
      return;
    }

    plugin$q.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Style$4, options);

    Vue$$1.component(Style$4.name, Style$4);
  }

  var RegShapeStyle = /*#__PURE__*/Object.freeze({
    default: plugin$q,
    Style: Style$4,
    install: plugin$q
  });

  /**
   * @vueProps
   */

  var props$D = {
    /**
     * A function that takes an `ol.Feature` and an `ol.layer.Layer` and returns `true` if the feature may be selected or `false` otherwise.
     * @type {function|undefined}
     */
    filter: {
      type: Function,
      default: constant(true)
    },

    /**
     * Hit-detection tolerance. Pixels inside the radius around the given position will be checked for features.
     * This only works for the canvas renderer and not for WebGL.
     * @type {number}
     */
    hitTolerance: {
      type: Number,
      default: 0
    },

    /**
     * A boolean that determines if the default behaviour should select only single features or all (overlapping)
     * features at the clicked map position.
     * @type {boolean}
     */
    multi: {
      type: Boolean,
      default: false
    },

    /**
     * Selected features as array of GeoJSON features with coordinates in the map view projection.
     * @type {string[]|number[]|Object[]}
     */
    features: {
      type: Array,
      default: stubArray
    },

    /**
     * Wrap the world horizontally on the selection overlay.
     * @type {boolean}
     */
    wrapX: {
      type: Boolean,
      default: true
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should
     * be handled. By default, this is `ol.events.condition.never`. Use this if you want to use different events
     * for `add` and `remove` instead of `toggle`.
     * @type {function|undefined}
     */
    addCondition: {
      type: Function,
      default: condition.never
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * This is the event for the selected features as a whole. By default, this is `ol.events.condition.singleClick`.
     * Clicking on a feature selects that feature and removes any that were in the selection. Clicking outside any feature
     * removes all from the selection.
     * @type {function|undefined}
     */
    condition: {
      type: Function,
      default: condition.singleClick
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * By default, this is `ol.events.condition.never`. Use this if you want to use different events for `add` and `remove`
     * instead of `toggle`.
     * @type {function|undefined}
     */
    removeCondition: {
      type: Function,
      default: condition.never
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * This is in addition to the `condition` event. By default, `ol.events.condition.shiftKeyOnly`, i.e. pressing `shift`
     * as well as the `condition` event, adds that feature to the current selection if it is not currently selected,
     * and removes it if it is.
     * @type {function|undefined}
     */
    toggleCondition: {
      type: Function,
      default: condition.shiftKeyOnly
    }
    /**
     * @vueComputed
     */

  };
  var computed$k = {};
  /**
   * @vueMethods
   */

  var methods$M = {
    /**
     * @return {Select}
     * @protected
     */
    createInteraction: function createInteraction() {
      return new SelectInteraction({
        multi: this.multi,
        wrapX: this.wrapX,
        filter: this.filter,
        style: this.createStyleFunc(),
        addCondition: this.addCondition,
        condition: this.condition,
        removeCondition: this.removeCondition,
        toggleCondition: this.toggleCondition
      });
    },

    /**
     * @return {function(feature: Feature): Style}
     * @protected
     */
    getDefaultStyles: function getDefaultStyles() {
      var defaultStyles = mapValues(defaultEditStyle(), function (styles) {
        return styles.map(createStyle);
      });
      return function __selectDefaultStyleFunc(feature) {
        if (feature.getGeometry()) {
          return defaultStyles[feature.getGeometry().getType()];
        }
      };
    },

    /**
     * @return {Feature[]}
     */
    getFeatures: function getFeatures() {
      return this.$interaction && this.$interaction.getFeatures().getArray() || [];
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      return multiMergeDescriptors(interaction$1.methods.getServices.call(this), stylesContainer.methods.getServices.call(this));
    },

    /**
     * @return {Interaction|undefined}
     * @protected
     */
    getStyleTarget: function getStyleTarget() {
      return this.$interaction;
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      interaction$1.methods.mount.call(this);
      this.features.forEach(this.select);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.unselectAll();
      interaction$1.methods.unmount.call(this);
    },

    /**
     * @param {Object|Vue|Feature|string|number} feature
     * @return {void}
     * @throws {Error}
     */
    select: function select(feature) {
      hasMap(this);
      hasInteraction(this);
      var id = getFeatureId(feature);

      if (!id) {
        throw new Error('Undefined feature id');
      }

      if (feature instanceof Vue) {
        feature = feature.$feature;
      }

      var selectedIds = this.$features.map(getFeatureId);
      if (selectedIds.includes(id)) return;

      if (!(feature instanceof Feature)) {
        feature = undefined;
        forEach(this.$map.getLayers().getArray(), function (layer) {
          var source = layer.getSource();

          if (source && isFunction(source.getFeatureById)) {
            feature = source.getFeatureById(id);
          }

          return !feature;
        });
      }

      feature && this.$interaction.getFeatures().push(feature);
    },

    /**
     * @param {Object|Vue|Feature|string|number} feature
     * @return {void}
     */
    unselect: function unselect(feature) {
      hasInteraction(this);
      var id = getFeatureId(feature);

      if (!id) {
        throw new Error('Undefined feature id');
      }

      if (feature instanceof Vue) {
        feature = feature.$feature;
      }

      var selectedIds = this.$features.map(getFeatureId);
      var idx = selectedIds.findIndex(function (x) {
        return x === id;
      });

      if (idx !== -1) {
        this.$interaction.getFeatures().removeAt(idx);
      }
    },

    /**
     * @param {Array<{style: Style, condition: (function|boolean|undefined)}>|function(feature: Feature): Style|Vue|undefined} styles
     * @return {void}
     * @protected
     */
    setStyle: function setStyle(styles) {
      if (styles !== this._styles) {
        this._styles = styles;
        this.scheduleRefresh();
      }
    },

    /**
     * @return {Promise}
     */
    refresh: function refresh() {
      var _this = this;

      return promise$1.all([new promise$1(function (resolve) {
        if (_this.$interaction) {
          var featuresCollection = _this.$interaction.getFeatures();

          featuresCollection.once('change', function () {
            return resolve();
          });
          featuresCollection.changed();
        } else {
          resolve();
        }
      }), interaction$1.methods.refresh.call(this)]);
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      subscribeToInteractionChanges$2.call(this);
    },

    /**
     * Removes all features from selection.
     * @return {void}
     */
    unselectAll: function unselectAll() {
      hasInteraction(this);
      this.$interaction.getFeatures().clear();
    }
  };

  var watch$p = _objectSpread({}, makeWatchers(['filter', 'hitTolerance', 'multi', 'wrapX', 'addCondition', 'condition', 'removeCondition', 'toggleCondition'], function () {
    return function () {
      this.scheduleRecreate();
    };
  }), {
    features: function features(value) {
      if (!this.$interaction) return;

      var diffById = function diffById(a, b) {
        return getFeatureId(a) === getFeatureId(b);
      };

      var forSelect = difference(value, this.$features, diffById);
      var forUnselect = difference(this.$features, value, diffById);
      forSelect.forEach(this.select);
      forUnselect.forEach(this.unselect);
    }
  });
  /**
   * @vueProto
   * @alias module:select-interaction/interaction
   * @title vl-interaction-select
   */


  var script$s = {
    name: 'vl-interaction-select',
    mixins: [interaction$1, stylesContainer, projTransforms],
    props: props$D,
    computed: computed$k,
    methods: methods$M,
    watch: watch$p,
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          class: this.$options.name
        };
      }
    },
    created: function created() {
      defineProperties$1(this, {
        $features: {
          enumerable: true,
          get: this.getFeatures
        }
      });
    }
  };
  /**
   * @return {void}
   * @private
   */

  function subscribeToInteractionChanges$2() {
    var _this2 = this;

    hasInteraction(this);
    var events = fromOlEvent(this.$interaction, 'select');
    this.subscribeTo(events, function (_ref) {
      var selected = _ref.selected,
          deselected = _ref.deselected,
          mapBrowserEvent = _ref.mapBrowserEvent;
      ++_this2.rev;
      deselected.forEach(function (feature) {
        return _this2.$emit('unselect', {
          feature: feature,
          mapBrowserEvent: mapBrowserEvent
        });
      });
      selected.forEach(function (feature) {
        return _this2.$emit('select', {
          feature: feature,
          mapBrowserEvent: mapBrowserEvent
        });
      });

      _this2.$emit('update:features', _this2.$features.map(_this2.writeFeatureInDataProj.bind(_this2)));
    });
  }

  /* script */
  var __vue_script__$s = script$s;
  /* template */

  var __vue_render__$6 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: [_vm.$options.name],
      staticStyle: {
        "display": "none !important"
      }
    }, [_vm._t("default", null, {
      features: _vm.features
    })], 2);
  };

  var __vue_staticRenderFns__$6 = [];
  /* style */

  var __vue_inject_styles__$s = undefined;
  /* scoped */

  var __vue_scope_id__$s = undefined;
  /* module identifier */

  var __vue_module_identifier__$s = undefined;
  /* functional template */

  var __vue_is_functional_template__$s = false;
  /* component normalizer */

  function __vue_normalize__$s(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "interaction.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Interaction$3 = __vue_normalize__$s({
    render: __vue_render__$6,
    staticRenderFns: __vue_staticRenderFns__$6
  }, __vue_inject_styles__$s, __vue_script__$s, __vue_scope_id__$s, __vue_is_functional_template__$s, __vue_module_identifier__$s, undefined, undefined);

  function plugin$r(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$r.installed) {
      return;
    }

    plugin$r.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Interaction$3, options);

    Vue$$1.component(Interaction$3.name, Interaction$3);
  }

  var SelectInteraction$1 = /*#__PURE__*/Object.freeze({
    default: plugin$r,
    Interaction: Interaction$3,
    install: plugin$r
  });

  /**
   * @vueProps
   */

  var props$E = {
    /**
     * Target source identifier from IdentityMap.
     * @type {string}
     */
    source: {
      type: String,
      required: true
    },

    /**
     * Snap to edges
     * @type {boolean}
     */
    edge: {
      type: Boolean,
      default: true
    },

    /**
     * Snap to vertices.
     * @type {boolean}
     */
    vertex: {
      type: Boolean,
      default: true
    },

    /**
     * Pixel tolerance for considering the pointer close enough to a segment or vertex for snapping.
     * @type {number}
     */
    pixelTolerance: {
      type: Number,
      default: 10
    }
    /**
     * @vueMethods
     */

  };
  var methods$N = {
    /**
     * @return {Promise<Snap>}
     * @protected
     */
    createInteraction: function () {
      var _createInteraction = _asyncToGenerator(
      /*#__PURE__*/
      regenerator.mark(function _callee() {
        var sourceIdent, source;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                sourceIdent = this.makeIdent(this.source);
                _context.next = 3;
                return this.$identityMap.get(sourceIdent, this.$options.INSTANCE_PROMISE_POOL);

              case 3:
                source = _context.sent;
                return _context.abrupt("return", new SnapInteraction({
                  source: source
                }));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function createInteraction() {
        return _createInteraction.apply(this, arguments);
      };
    }(),

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      interaction$1.methods.mount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      interaction$1.methods.unmount.call(this);
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {}
  };
  var watch$q = makeWatchers(['source'], function () {
    return function () {
      this.scheduleRecreate();
    };
  });
  /**
   * @alias module:snap-interaction/interaction
   * @title vl-interaction-snap
   * @vueProto
   */

  var script$t = {
    name: 'vl-interaction-snap',
    mixins: [interaction$1],
    props: props$E,
    methods: methods$N,
    watch: watch$q
  };

  /* script */
  var __vue_script__$t = script$t;
  /* template */

  /* style */

  var __vue_inject_styles__$t = undefined;
  /* scoped */

  var __vue_scope_id__$t = undefined;
  /* module identifier */

  var __vue_module_identifier__$t = undefined;
  /* functional template */

  var __vue_is_functional_template__$t = undefined;
  /* component normalizer */

  function __vue_normalize__$t(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "interaction.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Interaction$4 = __vue_normalize__$t({}, __vue_inject_styles__$t, __vue_script__$t, __vue_scope_id__$t, __vue_is_functional_template__$t, __vue_module_identifier__$t, undefined, undefined);

  function plugin$s(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$s.installed) {
      return;
    }

    plugin$s.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Interaction$4, options);

    Vue$$1.component(Interaction$4.name, Interaction$4);
  }

  var SnapInteraction$1 = /*#__PURE__*/Object.freeze({
    default: plugin$s,
    Interaction: Interaction$4,
    install: plugin$s
  });

  /**
   * Layer source to work with Sputnik.ru tile server.
   */

  var SPUTNIK_URL_TEMPLATE = 'http://tiles.maps.sputnik.ru/{z}/{x}/{y}.png?apikey={apikey}';
  var SPUTNIK_ATTRIBUTIONS = '<a href="http://maps.sputnik.ru/" target="_blank">Спутник</a> ' + '&copy; <a href="http://rt.ru/" target="_blank">Ростелеком</a>, ' + new Date().getFullYear();
  var props$F = {
    url: {
      type: String,
      default: SPUTNIK_URL_TEMPLATE
    },
    apiKey: {
      type: String
    },
    attributions: {
      type: String,
      default: SPUTNIK_ATTRIBUTIONS
    }
  };
  var computed$l = {
    /**
     * @type {string[]}
     */
    urlTokens: function urlTokens() {
      return ['apiKey'];
    }
  };
  var script$u = {
    name: 'vl-source-sputnik',
    mixins: [xyzSource],
    props: props$F,
    computed: computed$l
  };

  /* script */
  var __vue_script__$u = script$u;
  /* template */

  /* style */

  var __vue_inject_styles__$u = undefined;
  /* scoped */

  var __vue_scope_id__$u = undefined;
  /* module identifier */

  var __vue_module_identifier__$u = undefined;
  /* functional template */

  var __vue_is_functional_template__$u = undefined;
  /* component normalizer */

  function __vue_normalize__$u(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$7 = __vue_normalize__$u({}, __vue_inject_styles__$u, __vue_script__$u, __vue_scope_id__$u, __vue_is_functional_template__$u, __vue_module_identifier__$u, undefined, undefined);

  function plugin$t(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$t.installed) {
      return;
    }

    plugin$t.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$7, options);

    Vue$$1.component(Source$7.name, Source$7);
  }

  var SputnikSource = /*#__PURE__*/Object.freeze({
    default: plugin$t,
    Source: Source$7,
    install: plugin$t
  });

  var props$G = {
    /**
     * Stamen layer name
     *
     * @type {string}
     */
    layer: {
      type: String,
      required: true
    },

    /**
     * If nothing provided then default url resolved
     * with current layer params will be used.
     * @see {ol.source.Stamen}
     *
     * @type {string}
     */
    url: String
  };
  var methods$O = {
    createSource: function createSource() {
      return new StamenSource({
        cacheSize: this.cacheSize,
        layer: this.layer,
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        opaque: this.opaque,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        tileLoadFunction: this.tileLoadFunction,
        url: this.urlTmpl || undefined,
        wrapX: this.wrapX
      });
    }
  };
  var script$v = {
    name: 'vl-source-stamen',
    mixins: [xyzSource],
    props: props$G,
    methods: methods$O
  };

  /* script */
  var __vue_script__$v = script$v;
  /* template */

  /* style */

  var __vue_inject_styles__$v = undefined;
  /* scoped */

  var __vue_scope_id__$v = undefined;
  /* module identifier */

  var __vue_module_identifier__$v = undefined;
  /* functional template */

  var __vue_is_functional_template__$v = undefined;
  /* component normalizer */

  function __vue_normalize__$v(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$8 = __vue_normalize__$v({}, __vue_inject_styles__$v, __vue_script__$v, __vue_scope_id__$v, __vue_is_functional_template__$v, __vue_module_identifier__$v, undefined, undefined);

  function plugin$u(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$u.installed) {
      return;
    }

    plugin$u.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$8, options);

    Vue$$1.component(Source$8.name, Source$8);
  }

  var StamenSource$1 = /*#__PURE__*/Object.freeze({
    default: plugin$u,
    Source: Source$8,
    install: plugin$u
  });

  var props$H = {
    color: [Array, String],
    lineCap: {
      type: String,
      default: 'round' // round, butt, square

    },
    lineJoin: {
      type: String,
      default: 'round' // round, bevel, miter

    },
    lineDash: Array,
    lineDashOffset: {
      type: Number,
      default: 0
    },
    miterLimit: {
      type: Number,
      default: 10
    },
    width: {
      type: Number,
      default: 1.25
    }
  };
  var methods$P = {
    /**
     * @return {Stroke}
     * @protected
     */
    createStyle: function createStyle() {
      return new Stroke({
        color: this.color,
        lineCap: this.lineCap,
        lineJoin: this.lineJoin,
        lineDash: this.lineDash,
        lineDashOffset: this.lineDashOffset,
        miterLimit: this.miterLimit,
        width: this.width
      });
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      this.$stylesContainer && this.$stylesContainer.setStroke(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.$stylesContainer && this.$stylesContainer.setStroke(undefined);
    }
  };
  var watch$r = {
    color: function color(value) {
      if (this.$style && !isEqual(value, this.$style.getColor())) {
        this.$style.setColor(value);
        this.scheduleRefresh();
      }
    },
    lineCap: function lineCap(value) {
      if (this.$style && !isEqual(value, this.$style.getLineCap())) {
        this.$style.setLineCap(value);
        this.scheduleRefresh();
      }
    },
    lineDash: function lineDash(value) {
      if (this.$style && !isEqual(value, this.$style.getLineDash())) {
        this.$style.setLineDash(value);
        this.scheduleRefresh();
      }
    },
    lineJoin: function lineJoin(value) {
      if (this.$style && !isEqual(value, this.$style.getLineJoin())) {
        this.$style.setLineJoin(value);
        this.scheduleRefresh();
      }
    },
    width: function width(value) {
      if (this.$style && !isEqual(value, this.$style.getWidth())) {
        this.$style.setWidth(value);
        this.scheduleRefresh();
      }
    }
  };
  var script$w = {
    name: 'vl-style-stroke',
    mixins: [style],
    props: props$H,
    watch: watch$r,
    methods: methods$P
  };

  /* script */
  var __vue_script__$w = script$w;
  /* template */

  /* style */

  var __vue_inject_styles__$w = undefined;
  /* scoped */

  var __vue_scope_id__$w = undefined;
  /* module identifier */

  var __vue_module_identifier__$w = undefined;
  /* functional template */

  var __vue_is_functional_template__$w = undefined;
  /* component normalizer */

  function __vue_normalize__$w(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "style.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Style$5 = __vue_normalize__$w({}, __vue_inject_styles__$w, __vue_script__$w, __vue_scope_id__$w, __vue_is_functional_template__$w, __vue_module_identifier__$w, undefined, undefined);

  function plugin$v(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$v.installed) {
      return;
    }

    plugin$v.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Style$5, options);

    Vue$$1.component(Style$5.name, Style$5);
  }

  var StrokeStyle = /*#__PURE__*/Object.freeze({
    default: plugin$v,
    Style: Style$5,
    install: plugin$v
  });

  /**
   * Style box component.
   * Wrapper for Style class. Can be inserted into component with setStyle/getStyle methods (vl-layer-vector, vl-feature & etc.)
   * and acts as a box for inner style components (vl-style-fill, vl-style-stroke, icon ...)
   */

  var props$I = {
    zIndex: {
      type: Number,
      default: 0
    },
    condition: {
      type: [Function, Boolean],
      default: true
    }
  };
  var methods$Q = {
    /**
     * @return {Style}
     * @protected
     */
    createStyle: function createStyle() {
      return new Style({
        zIndex: this.zIndex,
        image: this._image,
        stroke: this._stroke,
        fill: this._fill,
        text: this._text,
        geometry: this._geometry
      });
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(style.methods.getServices.call(this), {
        get stylesContainer() {
          return vm;
        }

      });
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      this.$stylesContainer && this.$stylesContainer.addStyle(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.$stylesContainer && this.$stylesContainer.removeStyle(this);
    },

    /**
     * @param {Image|Vue|undefined} image
     * @return {void}
     */
    setImage: function setImage(image) {
      image = image instanceof Vue ? image.$style : image;

      if (image !== this._image) {
        this._image = image;
      }

      if (this.$style && image !== this.$style.getImage()) {
        this.$style.setImage(image);
        this.scheduleRefresh();
      }
    },

    /**
     * @param {Geometry|Vue|undefined} geom
     * @return {void}
     */
    setGeometry: function setGeometry(geom) {
      geom = geom instanceof Vue ? geom.$geometry : geom;

      if (geom !== this._geometry) {
        this._geometry = geom;
      }

      if (this.$style && geom !== this.$style.getGeometry()) {
        this.$style.setGeometry(geom);
        this.scheduleRefresh();
      }
    },

    /**
     * @param {Text|undefined} text
     * @return {void}
     */
    setText: function setText(text) {
      text = text instanceof Vue ? text.$style : text;

      if (text !== this._text) {
        this._text = text;
      }

      if (this.$style && text !== this.$style.getText()) {
        this.$style.setText(text);
        this.scheduleRefresh();
      }
    }
  };
  var watch$s = {
    zIndex: function zIndex(value) {
      if (this.$style && !isEqual(value, this.$style.getZIndex())) {
        this.$style.setZIndex(value);
        this.scheduleRefresh();
      }
    }
  };
  var script$x = {
    name: 'vl-style-box',
    mixins: [style, withFillStrokeStyle],
    props: props$I,
    methods: methods$Q,
    watch: watch$s,
    created: function created() {
      /**
       * @type {Image|undefined}
       * @private
       */
      this._image = undefined;
      /**
       * @type {Text|undefined}
       * @private
       */

      this._text = undefined;
      /**
       * @type {Geometry|undefined}
       * @private
       */

      this._geometry = undefined;
    }
  };

  /* script */
  var __vue_script__$x = script$x;
  /* template */

  /* style */

  var __vue_inject_styles__$x = undefined;
  /* scoped */

  var __vue_scope_id__$x = undefined;
  /* module identifier */

  var __vue_module_identifier__$x = undefined;
  /* functional template */

  var __vue_is_functional_template__$x = undefined;
  /* component normalizer */

  function __vue_normalize__$x(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "style.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Style$6 = __vue_normalize__$x({}, __vue_inject_styles__$x, __vue_script__$x, __vue_scope_id__$x, __vue_is_functional_template__$x, __vue_module_identifier__$x, undefined, undefined);

  function plugin$w(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$w.installed) {
      return;
    }

    plugin$w.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Style$6, options);

    Vue$$1.component(Style$6.name, Style$6);
  }

  var StyleBox = /*#__PURE__*/Object.freeze({
    default: plugin$w,
    Style: Style$6,
    install: plugin$w
  });

  /**
   * Style function component for advanced styling.
   * Plays the role of both a style that mounts itself to style target component (vl-layer-vector, vl-feature & etc.)
   * and style target for inner style containers (vl-style-box) as fallback style.
   */

  var props$J = {
    /**
     * @type {function(): function(feature: Feature): Style}
     */
    factory: {
      type: Function,
      required: true
    }
  };
  var computed$m = {
    styleFunc: function styleFunc() {
      var func = this.factory();

      if (!isFunction(func)) {

        func = noop;
      }

      return func;
    }
  };
  var methods$R = {
    /**
     * @return {function(feature: Feature): Style}
     * @protected
     */
    createStyle: function createStyle() {
      hasMap(this); // user provided style function

      var providedStyleFunc = this.styleFunc; // fallback style function made from inner style containers

      var fallbackStyleFunc = this.createStyleFunc();
      return function __styleFunc(feature, resolution) {
        var styles = providedStyleFunc(feature, resolution); // not empty or null style

        if (styles === null || isArray$1(styles) && styles.length) {
          return styles;
        }

        return fallbackStyleFunc(feature, resolution);
      };
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      this.$stylesContainer && this.$stylesContainer.addStyle(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.$stylesContainer && this.$stylesContainer.removeStyle(this);
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(style.methods.getServices.call(this), {
        get stylesContainer() {
          return vm;
        }

      });
    },

    /**
     * Overrides stylesContainer `setStyle` method
     * @param {Array<{ style: Style, condition: (function|boolean|undefined) }>|function(feature: Feature): Style|Vue|undefined} styles
     * @return {void}
     */
    setStyle: function setStyle(styles) {
      if (styles !== this._styles) {
        // simply save all inner styles and
        // use them later in style function as fallback
        this._styles = styles;
        this.scheduleRefresh();
      }
    },

    /**
     * @return {Promise}
     */
    refresh: function refresh() {
      // recreate style
      return this.recreate();
    }
  };
  var watch$t = {
    factory: function factory() {
      this.scheduleRefresh();
    }
  };
  var script$y = {
    name: 'vl-style-func',
    mixins: [style, stylesContainer],
    props: props$J,
    computed: computed$m,
    methods: methods$R,
    watch: watch$t,
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          class: this.$options.name
        };
      }
    }
  };

  /* script */
  var __vue_script__$y = script$y;
  /* template */

  /* style */

  var __vue_inject_styles__$y = undefined;
  /* scoped */

  var __vue_scope_id__$y = undefined;
  /* module identifier */

  var __vue_module_identifier__$y = undefined;
  /* functional template */

  var __vue_is_functional_template__$y = undefined;
  /* component normalizer */

  function __vue_normalize__$y(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "style.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Style$7 = __vue_normalize__$y({}, __vue_inject_styles__$y, __vue_script__$y, __vue_scope_id__$y, __vue_is_functional_template__$y, __vue_module_identifier__$y, undefined, undefined);

  function plugin$x(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$x.installed) {
      return;
    }

    plugin$x.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Style$7, options);

    Vue$$1.component(Style$7.name, Style$7);
  }

  var StyleFunc = /*#__PURE__*/Object.freeze({
    default: plugin$x,
    Style: Style$7,
    install: plugin$x
  });

  var props$K = {
    font: {
      type: String,
      default: '10px sans-serif' // css font format https://developer.mozilla.org/en-US/docs/Web/CSS/font?v=control

    },
    placement: String,
    offsetX: {
      type: Number,
      default: 0
    },
    offsetY: {
      type: Number,
      default: 0
    },
    rotateWithView: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: Number,
      default: 0
    },
    scale: {
      type: Number,
      default: 1
    },
    text: String,
    textAlign: String,
    // left, right, center, end, start
    textBaseline: String // bottom, top, middle, alphabetic, hanging, ideographic

  };
  var methods$S = {
    /**
     * @returns {Text}
     * @protected
     */
    createStyle: function createStyle() {
      return new Text({
        font: this.font,
        placement: this.placement,
        offsetX: this.offsetX,
        offsetY: this.offsetY,
        rotateWithView: this.rotateWithView,
        rotation: this.rotation,
        scale: this.scale,
        text: this.text,
        textAlign: this.textAlign,
        textBaseline: this.textBaseline,
        fill: this._fill,
        stroke: this._stroke
      });
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      this.$stylesContainer && this.$stylesContainer.setText(this);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.$stylesContainer && this.$stylesContainer.setText(undefined);
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return multiMergeDescriptors(style.methods.getServices.call(this), {
        get stylesContainer() {
          return vm;
        }

      });
    }
  };
  var watch$u = {
    font: function font(value) {
      if (this.$style && !isEqual(value, this.$style.getFont())) {
        this.$style.setFont(value);
        this.scheduleRefresh();
      }
    },
    offsetX: function offsetX(value) {
      if (this.$style && !isEqual(value, this.$style.getOffsetX())) {
        this.$style.setOffsetX(value);
        this.scheduleRefresh();
      }
    },
    offsetY: function offsetY(value) {
      if (this.$style && !isEqual(value, this.$style.getOffsetY())) {
        this.$style.setOffsetY(value);
        this.scheduleRefresh();
      }
    },
    rotation: function rotation(value) {
      if (this.$style && !isEqual(value, this.$style.getRotation())) {
        this.$style.setRotation(value);
        this.scheduleRefresh();
      }
    },
    scale: function scale(value) {
      if (this.$style && !isEqual(value, this.$style.getScale())) {
        this.$style.setScale(value);
        this.scheduleRefresh();
      }
    },
    text: function text(value) {
      if (this.$style && !isEqual(value, this.$style.getText())) {
        this.$style.setText(value);
        this.scheduleRefresh();
      }
    },
    textAlign: function textAlign(value) {
      if (this.$style && !isEqual(value, this.$style.getTextAlign())) {
        this.$style.setTextAlign(value);
        this.scheduleRefresh();
      }
    },
    textBaseline: function textBaseline(value) {
      if (this.$style && !isEqual(value, this.$style.getTextBaseline())) {
        this.$style.setTextBaseline(value);
        this.scheduleRefresh();
      }
    }
  };
  var script$z = {
    name: 'vl-style-text',
    mixins: [style, withFillStrokeStyle],
    props: props$K,
    methods: methods$S,
    watch: watch$u,
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          class: this.$options.name
        };
      }
    }
  };

  /* script */
  var __vue_script__$z = script$z;
  /* template */

  /* style */

  var __vue_inject_styles__$z = undefined;
  /* scoped */

  var __vue_scope_id__$z = undefined;
  /* module identifier */

  var __vue_module_identifier__$z = undefined;
  /* functional template */

  var __vue_is_functional_template__$z = undefined;
  /* component normalizer */

  function __vue_normalize__$z(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "style.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Style$8 = __vue_normalize__$z({}, __vue_inject_styles__$z, __vue_script__$z, __vue_scope_id__$z, __vue_is_functional_template__$z, __vue_module_identifier__$z, undefined, undefined);

  function plugin$y(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$y.installed) {
      return;
    }

    plugin$y.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Style$8, options);

    Vue$$1.component(Style$8.name, Style$8);
  }

  var TextStyle = /*#__PURE__*/Object.freeze({
    default: plugin$y,
    Style: Style$8,
    install: plugin$y
  });

  /**
   * @vueProps
   */

  var props$L =
  /** @lends module:tile-layer/layer# */
  {
    /**
     * Load low-resolution tiles up to `preload` levels.
     * @type {number}
     * @default 0
     */
    preload: {
      type: Number,
      default: 0
    }
    /**
     * @vueMethods
     */

  };
  var methods$T =
  /** @lends module:tile-layer/layer# */
  {
    /**
     * @return {Tile}
     * @protected
     */
    createLayer: function createLayer() {
      return new TileLayer({
        id: this.id,
        minResolution: this.minResolution,
        maxResolution: this.maxResolution,
        opacity: this.opacity,
        visible: this.visible,
        preload: this.preload,
        extent: this.extent,
        zIndex: this.zIndex,
        source: this._source
      });
    }
  };
  /**
   * Layer that provide pre-rendered, tiled images in grid that are organized by zoom levels for
   * specific resolutions. `vl-tile-layer` component implements a **source container** interface, so it should be
   * used together with tile-like `vl-source-*` components.
   *
   * @title vl-layer-tile
   * @alias module:tile-layer/layer
   * @vueProto
   *
   * @vueSlot default Default slot for `vl-source-*` (tile-like only) components.
   */

  var script$A = {
    name: 'vl-layer-tile',
    mixins: [layer],
    props: props$L,
    methods: methods$T
  };

  /* script */
  var __vue_script__$A = script$A;
  /* template */

  /* style */

  var __vue_inject_styles__$A = undefined;
  /* scoped */

  var __vue_scope_id__$A = undefined;
  /* module identifier */

  var __vue_module_identifier__$A = undefined;
  /* functional template */

  var __vue_is_functional_template__$A = undefined;
  /* component normalizer */

  function __vue_normalize__$A(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "layer.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Layer$2 = __vue_normalize__$A({}, __vue_inject_styles__$A, __vue_script__$A, __vue_scope_id__$A, __vue_is_functional_template__$A, __vue_module_identifier__$A, undefined, undefined);

  function plugin$z(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$z.installed) {
      return;
    }

    plugin$z.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Layer$2, options);

    Vue$$1.component(Layer$2.name, Layer$2);
  }

  var TileLayer$1 = /*#__PURE__*/Object.freeze({
    default: plugin$z,
    Layer: Layer$2,
    install: plugin$z
  });

  var RENDER_MODES = ['vector', 'image'];
  /**
   * @vueProps
   */

  var props$M = {
    /**
     * Render mode for vector layers. Available values:
     * - `image` - vector layers are rendered as images
     * - `vector` - vector layers are rendered as vectors
     * @type {string}
     * @default vector
     */
    renderMode: {
      type: String,
      default: 'vector',
      validator: function validator(val) {
        return RENDER_MODES.includes(val);
      }
    }
    /**
     * @vueMethods
     */

  };
  var methods$U = {
    /**
     * @return {Vector}
     * @protected
     */
    createLayer: function createLayer() {
      return new VectorLayer({
        id: this.id,
        minResolution: this.minResolution,
        maxResolution: this.maxResolution,
        opacity: this.opacity,
        visible: this.visible,
        extent: this.extent,
        zIndex: this.zIndex,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        source: this._source,
        renderMode: this.renderMode,
        renderBuffer: this.renderBuffer,
        renderOrder: this.renderOrder,
        declutter: this.declutter
      });
    }
  };
  /**
   * Layer for data that is rendered client-side.
   *
   * @vueProto
   * @title vl-layer-vector
   * @alias module:vector-layer/layer
   *
   * @vueSlot default Default slot for `vl-source-*` (vector-like only) components.
   */

  var script$B = {
    name: 'vl-layer-vector',
    mixins: [vectorLayer],
    props: props$M,
    methods: methods$U
  };

  /* script */
  var __vue_script__$B = script$B;
  /* template */

  /* style */

  var __vue_inject_styles__$B = undefined;
  /* scoped */

  var __vue_scope_id__$B = undefined;
  /* module identifier */

  var __vue_module_identifier__$B = undefined;
  /* functional template */

  var __vue_is_functional_template__$B = undefined;
  /* component normalizer */

  function __vue_normalize__$B(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "layer.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Layer$3 = __vue_normalize__$B({}, __vue_inject_styles__$B, __vue_script__$B, __vue_scope_id__$B, __vue_is_functional_template__$B, __vue_module_identifier__$B, undefined, undefined);

  function plugin$A(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$A.installed) {
      return;
    }

    plugin$A.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Layer$3, options);

    Vue$$1.component(Layer$3.name, Layer$3);
  }

  var VectorLayer$1 = /*#__PURE__*/Object.freeze({
    default: plugin$A,
    Layer: Layer$3,
    install: plugin$A
  });

  function _arrayWithHoles(arr) {
    if (isArray$1(arr)) return arr;
  }

  var core_getIterator = _core.getIterator = function (it) {
    var iterFn = core_getIteratorMethod(it);
    if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
    return _anObject(iterFn.call(it));
  };

  var getIterator = core_getIterator;

  var getIterator$1 = getIterator;

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = getIterator$1(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods$V = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods$V.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  var DOMException = self.DOMException;
  try {
    new DOMException();
  } catch (err) {
    DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    DOMException.prototype = Object.create(Error.prototype);
    DOMException.prototype.constructor = DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  var props$N = {
    /**
     * Array of GeoJSON features with coordinates in the map view projection.
     * @type {Object[]} features
     */
    features: {
      type: Array,
      default: stubArray
    },

    /**
     * Source loader factory.
     * Source loader should load features from some remote service, decode them and pas to `features` prop to render.
     * @type {(function(): FeatureLoader|undefined)} loaderFactory
     */
    loaderFactory: {
      type: Function,
      default: defaultLoaderFactory
    },

    /**
     * Source format factory
     * @type {(function(): Feature|undefined)} formatFactory
     */
    formatFactory: {
      type: Function,
      default: defaultFormatFactory
    },

    /**
     * String or url factory
     * @type {(string|function(): string|FeatureUrlFunction|undefined)} url
     */
    url: [String, Function],

    /**
     * Loading strategy factory.
     * Extent here in map view projection.
     * @type {(function(): LoadingStrategy|undefined)} strategyFactory
     */
    strategyFactory: {
      type: Function,
      default: defaultStrategyFactory
    },
    overlaps: {
      type: Boolean,
      default: true
    }
  };
  var computed$n = {
    featureIds: function featureIds() {
      return this.features.map(getFeatureId);
    }
  };
  var methods$W = {
    /**
     * @return {VectorSource}
     * @protected
     */
    createSource: function createSource() {
      return new VectorSource({
        attributions: this.attributions,
        projection: this.resolvedDataProjection,
        loader: this.createLoader(),
        useSpatialIndex: this.useSpatialIndex,
        wrapX: this.wrapX,
        logo: this.logo,
        strategy: this.strategyFactory.call(undefined, this),
        format: this.formatFactory.call(undefined, this),
        url: this.createUrlFunc(),
        overlaps: this.overlaps
      });
    },

    /**
     * @protected
     */
    createUrlFunc: function createUrlFunc() {
      var _this = this;

      if (!this.url) {
        return;
      }

      var url = this.url;

      if (!isFunction(url)) {
        url = constant(this.url);
      } // wrap strategy function to transform map view projection to source projection


      return function (extent$$1, resolution, projection) {
        return url(transformExtent(extent$$1, projection, _this.resolvedDataProjection), resolution, _this.resolvedDataProjection);
      };
    },

    /**
     * @protected
     */
    createLoader: function createLoader() {
      var _this2 = this;

      if (!this.url) {
        return;
      }

      var loader = this.loaderFactory.call(undefined, this); // wrap strategy function to transform map view projection to source projection

      return (
        /*#__PURE__*/
        function () {
          var _ref = _asyncToGenerator(
          /*#__PURE__*/
          regenerator.mark(function _callee(extent$$1, resolution, projection) {
            var features;
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return loader(transformExtent(extent$$1, projection, _this2.resolvedDataProjection), resolution, _this2.resolvedDataProjection);

                  case 2:
                    features = _context.sent;

                    if (isArray$1(features)) {
                      _this2.$source.addFeatures(features);
                    }

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          return function (_x, _x2, _x3) {
            return _ref.apply(this, arguments);
          };
        }()
      );
    },

    /**
     * @return {void}
     * @protected
     */
    mount: function mount() {
      vectorSource.methods.mount.call(this);
      this.addFeatures(this.features);
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      this.clear();
      vectorSource.methods.unmount.call(this);
    }
  };

  var diffById = function diffById(a, b) {
    return a.id === b.id;
  };

  var watch$v = {
    features: function features(value, oldValue) {
      if (!this.$source) return;
      var forAdd = difference(value, oldValue, diffById);
      var forRemove = difference(oldValue, value, diffById);
      this.addFeatures(forAdd);
      this.removeFeatures(forRemove);
    }
  };
  var script$C = {
    name: 'vl-source-vector',
    mixins: [vectorSource],
    props: props$N,
    computed: computed$n,
    methods: methods$W,
    watch: watch$v
    /**
     * @return {LoadingStrategy}
     */

  };

  function defaultStrategyFactory() {
    return loadingstrategy.all;
  }
  /**
   * @return {GeoJSON}
   */


  function defaultFormatFactory() {
    return createGeoJsonFmt();
  }
  /**
   * Default loader for provided URL.
   *
   * @param vm
   * @return {Function}
   */


  function defaultLoaderFactory(vm) {
    return function (extent$$1, resolution, projection) {
      var url = vm.$source.getUrl();

      if (isFunction(url)) {
        url = url(extent$$1, resolution, projection);
      }

      if (isEmpty(url)) {
        return [];
      }

      return fetch(url, {
        credentials: 'same-origin',
        mode: 'cors'
      }).then(function (response) {
        return response.text();
      }).then(function (text) {
        if (!vm.$source) {
          return [];
        }

        return vm.$source.getFormat().readFeatures(text, {
          featureProjection: vm.viewProjection,
          dataProjection: vm.resolvedDataProjection
        });
      });
    };
  }

  function transformExtent(extent$$1, sourceProj, destProj) {
    extent$$1 = extent$$1.slice();

    if (isFinite(extent$$1[0]) && isFinite(extent$$1[1])) {
      var _transform = proj.transform([extent$$1[0], extent$$1[1]], sourceProj, destProj);

      var _transform2 = _slicedToArray(_transform, 2);

      extent$$1[0] = _transform2[0];
      extent$$1[1] = _transform2[1];
    }

    if (isFinite(extent$$1[2]) && isFinite(extent$$1[3])) {
      var _transform3 = proj.transform([extent$$1[2], extent$$1[3]], sourceProj, destProj);

      var _transform4 = _slicedToArray(_transform3, 2);

      extent$$1[2] = _transform4[0];
      extent$$1[3] = _transform4[1];
    }

    return extent$$1;
  }

  /* script */
  var __vue_script__$C = script$C;
  /* template */

  /* style */

  var __vue_inject_styles__$C = undefined;
  /* scoped */

  var __vue_scope_id__$C = undefined;
  /* module identifier */

  var __vue_module_identifier__$C = undefined;
  /* functional template */

  var __vue_is_functional_template__$C = undefined;
  /* component normalizer */

  function __vue_normalize__$C(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$9 = __vue_normalize__$C({}, __vue_inject_styles__$C, __vue_script__$C, __vue_scope_id__$C, __vue_is_functional_template__$C, __vue_module_identifier__$C, undefined, undefined);

  function plugin$B(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$B.installed) {
      return;
    }

    plugin$B.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$9, options);

    Vue$$1.component(Source$9.name, Source$9);
  }

  var VectorSource$1 = /*#__PURE__*/Object.freeze({
    default: plugin$B,
    Source: Source$9,
    install: plugin$B
  });

  var RENDER_MODES$1 = ['vector', 'image', 'hybrid'];
  var props$O = {
    renderMode: {
      type: String,
      default: 'hybrid',
      validator: function validator(val) {
        return RENDER_MODES$1.includes(val);
      }
    },
    preload: {
      type: Number,
      default: 0
    }
  };
  var methods$X = {
    /**
     * @return {VectorTileLayer}
     * @protected
     */
    createLayer: function createLayer() {
      return new VectorTileLayer({
        id: this.id,
        minResolution: this.minResolution,
        maxResolution: this.maxResolution,
        opacity: this.opacity,
        visible: this.visible,
        preload: this.preload,
        extent: this.extent,
        zIndex: this.zIndex,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        source: this._source,
        renderMode: this.renderMode,
        renderBuffer: this.renderBuffer,
        renderOrder: this.renderOrder,
        declutter: this.declutter
      });
    }
  };
  var script$D = {
    name: 'vl-layer-vector-tile',
    mixins: [vectorLayer],
    props: props$O,
    methods: methods$X
  };

  /* script */
  var __vue_script__$D = script$D;
  /* template */

  /* style */

  var __vue_inject_styles__$D = undefined;
  /* scoped */

  var __vue_scope_id__$D = undefined;
  /* module identifier */

  var __vue_module_identifier__$D = undefined;
  /* functional template */

  var __vue_is_functional_template__$D = undefined;
  /* component normalizer */

  function __vue_normalize__$D(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "layer.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Layer$4 = __vue_normalize__$D({}, __vue_inject_styles__$D, __vue_script__$D, __vue_scope_id__$D, __vue_is_functional_template__$D, __vue_module_identifier__$D, undefined, undefined);

  function plugin$C(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$C.installed) {
      return;
    }

    plugin$C.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Layer$4, options);

    Vue$$1.component(Layer$4.name, Layer$4);
  }

  var VectorTileLayer$1 = /*#__PURE__*/Object.freeze({
    default: plugin$C,
    Layer: Layer$4,
    install: plugin$C
  });

  var props$P = {
    cacheSize: {
      type: Number,
      default: 128
    },

    /**
     * Source format factory
     * @type {(function(): Feature|undefined)} formatFactory
     */
    formatFactory: {
      type: Function,
      default: defaultFormatFactory$1
    },
    overlaps: {
      type: Boolean,
      default: true
    }
  };
  var methods$Y = {
    /**
     * @return {VectorTileSource}
     */
    createSource: function createSource() {
      return new VectorTileSource({
        attributions: this.attributions,
        cacheSize: this.cacheSize,
        format: this.formatFactory(),
        logo: this.logo,
        overlaps: this.overlaps,
        projection: this.projection,
        tileGrid: this._tileGrid,
        tileLoadFunction: this.tileLoadFunction,
        tileUrlFunction: this.createUrlFunc(),
        wrapX: this.wrapX,
        transition: this.transition
      });
    }
  };
  var script$E = {
    name: 'vl-source-vector-tile',
    mixins: [tileSource],
    props: props$P,
    methods: methods$Y
    /**
     * @return {TopoJSON}
     */

  };

  function defaultFormatFactory$1() {
    return createMvtFmt();
  }

  /* script */
  var __vue_script__$E = script$E;
  /* template */

  /* style */

  var __vue_inject_styles__$E = undefined;
  /* scoped */

  var __vue_scope_id__$E = undefined;
  /* module identifier */

  var __vue_module_identifier__$E = undefined;
  /* functional template */

  var __vue_is_functional_template__$E = undefined;
  /* component normalizer */

  function __vue_normalize__$E(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$a = __vue_normalize__$E({}, __vue_inject_styles__$E, __vue_script__$E, __vue_scope_id__$E, __vue_is_functional_template__$E, __vue_module_identifier__$E, undefined, undefined);

  function plugin$D(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$D.installed) {
      return;
    }

    plugin$D.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$a, options);

    Vue$$1.component(Source$a.name, Source$a);
  }

  var VectorTileSource$1 = /*#__PURE__*/Object.freeze({
    default: plugin$D,
    Source: Source$a,
    install: plugin$D
  });

  var props$Q = {
    gutter: Number,
    hidpi: {
      type: Boolean,
      default: true
    },
    serverType: {
      type: String,
      validator: function validator(value) {
        return !value | values$1(WMSServerType).includes(value);
      }
    },
    url: {
      type: String,
      required: true,
      validator: function validator(value) {
        return !!value.length;
      }
    }
  };
  var methods$Z = {
    /**
     * @returns {TileWMS}
     * @protected
     */
    createSource: function createSource() {
      return new TileWMSSource({
        attributions: this.attributions,
        cacheSize: this.cacheSize,
        params: this.allParams,
        crossOrigin: this.crossOrigin,
        gutter: this.gutter,
        hidpi: this.hidpi,
        logo: this.logo,
        tileGrid: this._tileGrid,
        projection: this.projection,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        serverType: this.serverType,
        wrapX: this.wrapX,
        url: this.urlTmpl,
        transition: this.transition,
        tileLoadFunction: this.tileLoadFunction
      });
    }
  };
  var script$F = {
    name: 'vl-source-wms',
    mixins: [tileSource, wmsSource],
    props: props$Q,
    methods: methods$Z
  };

  /* script */
  var __vue_script__$F = script$F;
  /* template */

  /* style */

  var __vue_inject_styles__$F = undefined;
  /* scoped */

  var __vue_scope_id__$F = undefined;
  /* module identifier */

  var __vue_module_identifier__$F = undefined;
  /* functional template */

  var __vue_is_functional_template__$F = undefined;
  /* component normalizer */

  function __vue_normalize__$F(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$b = __vue_normalize__$F({}, __vue_inject_styles__$F, __vue_script__$F, __vue_scope_id__$F, __vue_is_functional_template__$F, __vue_module_identifier__$F, undefined, undefined);

  function plugin$E(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$E.installed) {
      return;
    }

    plugin$E.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$b, options);

    Vue$$1.component(Source$b.name, Source$b);
  }

  var WmsSource = /*#__PURE__*/Object.freeze({
    default: plugin$E,
    Source: Source$b,
    install: plugin$E
  });

  var props$R = {
    dimensions: Object,
    format: {
      type: String,
      default: WMTS_FORMAT
    },
    layerName: {
      type: String,
      required: true
    },
    matrixSet: {
      type: String,
      required: true
    },
    requestEncoding: {
      type: String,
      default: WMTS_REQUEST_ENCODING
    },
    styleName: {
      type: String,
      required: true
    },
    version: {
      type: String,
      default: WMTS_VERSION
    },
    url: {
      type: String,
      required: true
    },
    origin: {
      type: Array
    },
    resolutions: {
      type: Array
    }
  };
  var methods$_ = {
    /**
     * @returns {WMTS}
     * @protected
     */
    createSource: function createSource() {
      return new WMTSSource({
        attributions: this.attributions,
        cacheSize: this.cacheSize,
        crossOrigin: this.crossOrigin,
        dimensions: this.dimensions,
        format: this.format,
        layer: this.layerName,
        logo: this.logo,
        matrixSet: this.matrixSet,
        origin: this.origin,
        projection: this.projection,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        requestEncoding: this.requestEncoding,
        resolutions: this.resolutions,
        tileGrid: this._tileGrid,
        tilePixelRatio: this.tilePixelRatio,
        style: this.styleName,
        version: this.version,
        url: this.urlTmpl,
        wrapX: this.wrapX,
        transition: this.transition,
        tileLoadFunction: this.tileLoadFunction
      });
    },

    /**
     * @return {WMTS}
     * @protected
     */
    createTileGrid: function createTileGrid() {
      hasView(this);
      var extent$$1 = createExtentFromProjection(this.$view.getProjection());
      var resolutions = this.resolutions ? this.resolutions : resolutionsFromExtent(extent$$1, this.maxZoom, this.tileSize);
      var origin = this.origin ? this.origin : getExtentCorner(extent$$1, EXTENT_CORNER.TOP_LEFT);
      return new WMTSTileGrid({
        extent: extent$$1,
        origin: origin,
        resolutions: resolutions,
        tileSize: this.tileSize,
        minZoom: this.minZoom,
        matrixIds: from_1$1(range(this.minZoom, resolutions.length))
      });
    }
  };
  var script$G = {
    name: 'vl-source-wmts',
    mixins: [tileSource],
    props: props$R,
    methods: methods$_
  };

  /* script */
  var __vue_script__$G = script$G;
  /* template */

  /* style */

  var __vue_inject_styles__$G = undefined;
  /* scoped */

  var __vue_scope_id__$G = undefined;
  /* module identifier */

  var __vue_module_identifier__$G = undefined;
  /* functional template */

  var __vue_is_functional_template__$G = undefined;
  /* component normalizer */

  function __vue_normalize__$G(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$c = __vue_normalize__$G({}, __vue_inject_styles__$G, __vue_script__$G, __vue_scope_id__$G, __vue_is_functional_template__$G, __vue_module_identifier__$G, undefined, undefined);

  function plugin$F(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$F.installed) {
      return;
    }

    plugin$F.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$c, options);

    Vue$$1.component(Source$c.name, Source$c);
  }

  var WmtsSource = /*#__PURE__*/Object.freeze({
    default: plugin$F,
    Source: Source$c,
    install: plugin$F
  });

  var props$S = {};
  var script$H = {
    name: 'vl-source-xyz',
    mixins: [xyzSource],
    props: props$S
  };

  /* script */
  var __vue_script__$H = script$H;
  /* template */

  /* style */

  var __vue_inject_styles__$H = undefined;
  /* scoped */

  var __vue_scope_id__$H = undefined;
  /* module identifier */

  var __vue_module_identifier__$H = undefined;
  /* functional template */

  var __vue_is_functional_template__$H = undefined;
  /* component normalizer */

  function __vue_normalize__$H(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
    var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

    component.__file = "source.vue";

    if (!component.render) {
      component.render = template.render;
      component.staticRenderFns = template.staticRenderFns;
      component._compiled = true;
      if (functional) component.functional = true;
    }

    component._scopeId = scope;

    return component;
  }
  /* style inject */

  /* style inject SSR */


  var Source$d = __vue_normalize__$H({}, __vue_inject_styles__$H, __vue_script__$H, __vue_scope_id__$H, __vue_is_functional_template__$H, __vue_module_identifier__$H, undefined, undefined);

  function plugin$G(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$G.installed) {
      return;
    }

    plugin$G.installed = true;
    options = pick(options, 'dataProjection');

    assign$1(Source$d, options);

    Vue$$1.component(Source$d.name, Source$d);
  }

  var XyzSource = /*#__PURE__*/Object.freeze({
    default: plugin$G,
    Source: Source$d,
    install: plugin$G
  });

  /**
   * @const {string} VueLayers version.
   */

  var VERSION = '0.11.4';
  /**
   * Registers all VueLayers components.
   * @param {Vue|VueConstructor} Vue
   * @param {VueLayersOptions} [options]
   */

  function plugin$H(Vue$$1) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$H.installed) {
      return;
    }

    plugin$H.installed = true; // install components

    Vue$$1.use(ArcgisRestSource, options);
    Vue$$1.use(BingmapsSource, options);
    Vue$$1.use(CircleGeom, options);
    Vue$$1.use(CircleStyle, options);
    Vue$$1.use(ClusterSource, options);
    Vue$$1.use(DrawInteraction$1, options);
    Vue$$1.use(Feature$2, options);
    Vue$$1.use(FillStyle, options);
    Vue$$1.use(Geoloc$1, options);
    Vue$$1.use(Graticule$2, options);
    Vue$$1.use(GroupLayer$1, options);
    Vue$$1.use(IconStyle, options);
    Vue$$1.use(ImageLayer$1, options);
    Vue$$1.use(ImageStaticSource$1, options);
    Vue$$1.use(ImageWmsSource, options);
    Vue$$1.use(LineStringGeom, options);
    Vue$$1.use(Map$2, options);
    Vue$$1.use(MapboxSource, options);
    Vue$$1.use(ModifyInteraction$1, options);
    Vue$$1.use(MultiLineStringGeom, options);
    Vue$$1.use(MultiPointGeom, options);
    Vue$$1.use(MultiPolygonGeom, options);
    Vue$$1.use(OsmSource, options);
    Vue$$1.use(Overlay$2, options);
    Vue$$1.use(PointGeom, options);
    Vue$$1.use(PolygonGeom, options);
    Vue$$1.use(RegShapeStyle, options);
    Vue$$1.use(SelectInteraction$1, options);
    Vue$$1.use(SnapInteraction$1, options);
    Vue$$1.use(SputnikSource, options);
    Vue$$1.use(StamenSource$1, options);
    Vue$$1.use(StrokeStyle, options);
    Vue$$1.use(StyleBox, options);
    Vue$$1.use(StyleFunc, options);
    Vue$$1.use(TextStyle, options);
    Vue$$1.use(TileLayer$1, options);
    Vue$$1.use(VectorLayer$1, options);
    Vue$$1.use(VectorSource$1, options);
    Vue$$1.use(VectorTileLayer$1, options);
    Vue$$1.use(VectorTileSource$1, options);
    Vue$$1.use(WmsSource, options);
    Vue$$1.use(WmtsSource, options);
    Vue$$1.use(XyzSource, options);
  }
  /**
   * @typedef {Object} VueLayersOptions
   * @property {string} [dataProjection] Projection for all properties, events and other plain values.
   */

  var VueLayers = /*#__PURE__*/Object.freeze({
    default: plugin$H,
    VERSION: VERSION,
    install: plugin$H,
    ArcgisRestSource: ArcgisRestSource,
    BingmapsSource: BingmapsSource,
    CircleGeom: CircleGeom,
    CircleStyle: CircleStyle,
    ClusterSource: ClusterSource,
    DrawInteraction: DrawInteraction$1,
    Feature: Feature$2,
    FillStyle: FillStyle,
    Geoloc: Geoloc$1,
    Graticule: Graticule$2,
    GroupLayer: GroupLayer$1,
    IconStyle: IconStyle,
    ImageLayer: ImageLayer$1,
    ImageStaticSource: ImageStaticSource$1,
    ImageWmsSource: ImageWmsSource,
    LineStringGeom: LineStringGeom,
    Map: Map$2,
    MapboxSource: MapboxSource,
    ModifyInteraction: ModifyInteraction$1,
    MultiLineStringGeom: MultiLineStringGeom,
    MultiPointGeom: MultiPointGeom,
    MultiPolygonGeom: MultiPolygonGeom,
    OsmSource: OsmSource,
    Overlay: Overlay$2,
    PointGeom: PointGeom,
    PolygonGeom: PolygonGeom,
    RegShapeStyle: RegShapeStyle,
    SelectInteraction: SelectInteraction$1,
    SnapInteraction: SnapInteraction$1,
    SputnikSource: SputnikSource,
    StamenSource: StamenSource$1,
    StrokeStyle: StrokeStyle,
    StyleBox: StyleBox,
    StyleFunc: StyleFunc,
    TextStyle: TextStyle,
    TileLayer: TileLayer$1,
    VectorLayer: VectorLayer$1,
    VectorSource: VectorSource$1,
    VectorTileLayer: VectorTileLayer$1,
    VectorTileSource: VectorTileSource$1,
    WmsSource: WmsSource,
    WmtsSource: WmtsSource,
    XyzSource: XyzSource
  });

  var index_umd = _objectSpread({}, VueLayers, {
    olExt: olExt,
    rxExt: rxExt
  });

  if (typeof window.Vue !== 'undefined') {
    window.Vue.use(VueLayers);
  }

  return index_umd;

})));
