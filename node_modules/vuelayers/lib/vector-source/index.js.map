{"version":3,"file":"index.js","sources":["src/component/vector-source/source.vue?rollup-plugin-vue=script.js","src/component/vector-source/source.vue","src/component/vector-source/index.js"],"sourcesContent":["\nimport VectorSource from 'ol/source/Vector'\nimport { fetch } from 'whatwg-fetch'\nimport vectorSource from '../../mixin/vector-source'\nimport { getFeatureId } from '../../ol-ext/feature'\nimport { createGeoJsonFmt } from '../../ol-ext/format'\nimport { loadingAll } from '../../ol-ext/load-strategy'\nimport { transform } from '../../ol-ext/proj'\nimport { constant, difference, isEmpty, isFinite, isFunction, stubArray } from '../../util/minilo'\n\nconst props = {\n  /**\n   * Array of GeoJSON features with coordinates in the map view projection.\n   * @type {Object[]} features\n   */\n  features: {\n    type: Array,\n    default: stubArray,\n  },\n  /**\n   * Source loader factory.\n   * Source loader should load features from some remote service, decode them and pas to `features` prop to render.\n   * @type {(function(): FeatureLoader|undefined)} loaderFactory\n   */\n  loaderFactory: {\n    type: Function,\n    default: defaultLoaderFactory,\n  },\n  /**\n   * Source format factory\n   * @type {(function(): Feature|undefined)} formatFactory\n   */\n  formatFactory: {\n    type: Function,\n    default: defaultFormatFactory,\n  },\n  /**\n   * String or url factory\n   * @type {(string|function(): string|FeatureUrlFunction|undefined)} url\n   */\n  url: [String, Function],\n  /**\n   * Loading strategy factory.\n   * Extent here in map view projection.\n   * @type {(function(): LoadingStrategy|undefined)} strategyFactory\n   */\n  strategyFactory: {\n    type: Function,\n    default: defaultStrategyFactory,\n  },\n  overlaps: {\n    type: Boolean,\n    default: true,\n  },\n}\n\nconst computed = {\n  featureIds () {\n    return this.features.map(getFeatureId)\n  },\n}\n\nconst methods = {\n  /**\n   * @return {VectorSource}\n   * @protected\n   */\n  createSource () {\n    return new VectorSource({\n      attributions: this.attributions,\n      projection: this.resolvedDataProjection,\n      loader: this.createLoader(),\n      useSpatialIndex: this.useSpatialIndex,\n      wrapX: this.wrapX,\n      logo: this.logo,\n      strategy: this.strategyFactory.call(undefined, this),\n      format: this.formatFactory.call(undefined, this),\n      url: this.createUrlFunc(),\n      overlaps: this.overlaps,\n    })\n  },\n  /**\n   * @protected\n   */\n  createUrlFunc () {\n    if (!this.url) {\n      return\n    }\n\n    let url = this.url\n    if (!isFunction(url)) {\n      url = constant(this.url)\n    }\n    // wrap strategy function to transform map view projection to source projection\n    return (extent, resolution, projection) => url(\n      transformExtent(extent, projection, this.resolvedDataProjection),\n      resolution,\n      this.resolvedDataProjection,\n    )\n  },\n  /**\n   * @protected\n   */\n  createLoader () {\n    if (!this.url) {\n      return\n    }\n\n    const loader = this.loaderFactory.call(undefined, this)\n    // wrap strategy function to transform map view projection to source projection\n    return async (extent, resolution, projection) => {\n      const features = await loader(\n        transformExtent(extent, projection, this.resolvedDataProjection),\n        resolution,\n        this.resolvedDataProjection,\n      )\n\n      if (Array.isArray(features)) {\n        this.$source.addFeatures(features)\n      }\n    }\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  mount () {\n    this::vectorSource.methods.mount()\n    this.addFeatures(this.features)\n  },\n  /**\n   * @return {void}\n   * @protected\n   */\n  unmount () {\n    this.clear()\n    this::vectorSource.methods.unmount()\n  },\n}\n\nconst diffById = (a, b) => a.id === b.id\nconst watch = {\n  features (value, oldValue) {\n    if (!this.$source) return\n\n    let forAdd = difference(value, oldValue, diffById)\n    let forRemove = difference(oldValue, value, diffById)\n\n    this.addFeatures(forAdd)\n    this.removeFeatures(forRemove)\n  },\n}\n\nexport default {\n  name: 'vl-source-vector',\n  mixins: [vectorSource],\n  props,\n  computed,\n  methods,\n  watch,\n}\n\n/**\n * @return {LoadingStrategy}\n */\nfunction defaultStrategyFactory () {\n  return loadingAll\n}\n\n/**\n * @return {GeoJSON}\n */\nfunction defaultFormatFactory () {\n  return createGeoJsonFmt()\n}\n\n/**\n * Default loader for provided URL.\n *\n * @param vm\n * @return {Function}\n */\nfunction defaultLoaderFactory (vm) {\n  return (extent, resolution, projection) => {\n    let url = vm.$source.getUrl()\n    if (isFunction(url)) {\n      url = url(extent, resolution, projection)\n    }\n\n    if (isEmpty(url)) {\n      return []\n    }\n\n    return fetch(url, {\n      credentials: 'same-origin',\n      mode: 'cors',\n    }).then(response => response.text())\n      .then(text => {\n        if (!vm.$source) {\n          return []\n        }\n\n        return vm.$source.getFormat().readFeatures(text, {\n          featureProjection: vm.viewProjection,\n          dataProjection: vm.resolvedDataProjection,\n        })\n      })\n  }\n}\n\nfunction transformExtent (extent, sourceProj, destProj) {\n  extent = extent.slice()\n  if (isFinite(extent[0]) && isFinite(extent[1])) {\n    [extent[0], extent[1]] = transform([extent[0], extent[1]], sourceProj, destProj)\n  }\n  if (isFinite(extent[2]) && isFinite(extent[3])) {\n    [extent[2], extent[3]] = transform([extent[2], extent[3]], sourceProj, destProj)\n  }\n  return extent\n}\n","<script>\n  import VectorSource from 'ol/source/Vector'\n  import { fetch } from 'whatwg-fetch'\n  import vectorSource from '../../mixin/vector-source'\n  import { getFeatureId } from '../../ol-ext/feature'\n  import { createGeoJsonFmt } from '../../ol-ext/format'\n  import { loadingAll } from '../../ol-ext/load-strategy'\n  import { transform } from '../../ol-ext/proj'\n  import { constant, difference, isEmpty, isFinite, isFunction, stubArray } from '../../util/minilo'\n\n  const props = {\n    /**\n     * Array of GeoJSON features with coordinates in the map view projection.\n     * @type {Object[]} features\n     */\n    features: {\n      type: Array,\n      default: stubArray,\n    },\n    /**\n     * Source loader factory.\n     * Source loader should load features from some remote service, decode them and pas to `features` prop to render.\n     * @type {(function(): FeatureLoader|undefined)} loaderFactory\n     */\n    loaderFactory: {\n      type: Function,\n      default: defaultLoaderFactory,\n    },\n    /**\n     * Source format factory\n     * @type {(function(): Feature|undefined)} formatFactory\n     */\n    formatFactory: {\n      type: Function,\n      default: defaultFormatFactory,\n    },\n    /**\n     * String or url factory\n     * @type {(string|function(): string|FeatureUrlFunction|undefined)} url\n     */\n    url: [String, Function],\n    /**\n     * Loading strategy factory.\n     * Extent here in map view projection.\n     * @type {(function(): LoadingStrategy|undefined)} strategyFactory\n     */\n    strategyFactory: {\n      type: Function,\n      default: defaultStrategyFactory,\n    },\n    overlaps: {\n      type: Boolean,\n      default: true,\n    },\n  }\n\n  const computed = {\n    featureIds () {\n      return this.features.map(getFeatureId)\n    },\n  }\n\n  const methods = {\n    /**\n     * @return {VectorSource}\n     * @protected\n     */\n    createSource () {\n      return new VectorSource({\n        attributions: this.attributions,\n        projection: this.resolvedDataProjection,\n        loader: this.createLoader(),\n        useSpatialIndex: this.useSpatialIndex,\n        wrapX: this.wrapX,\n        logo: this.logo,\n        strategy: this.strategyFactory.call(undefined, this),\n        format: this.formatFactory.call(undefined, this),\n        url: this.createUrlFunc(),\n        overlaps: this.overlaps,\n      })\n    },\n    /**\n     * @protected\n     */\n    createUrlFunc () {\n      if (!this.url) {\n        return\n      }\n\n      let url = this.url\n      if (!isFunction(url)) {\n        url = constant(this.url)\n      }\n      // wrap strategy function to transform map view projection to source projection\n      return (extent, resolution, projection) => url(\n        transformExtent(extent, projection, this.resolvedDataProjection),\n        resolution,\n        this.resolvedDataProjection,\n      )\n    },\n    /**\n     * @protected\n     */\n    createLoader () {\n      if (!this.url) {\n        return\n      }\n\n      const loader = this.loaderFactory.call(undefined, this)\n      // wrap strategy function to transform map view projection to source projection\n      return async (extent, resolution, projection) => {\n        const features = await loader(\n          transformExtent(extent, projection, this.resolvedDataProjection),\n          resolution,\n          this.resolvedDataProjection,\n        )\n\n        if (Array.isArray(features)) {\n          this.$source.addFeatures(features)\n        }\n      }\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    mount () {\n      this::vectorSource.methods.mount()\n      this.addFeatures(this.features)\n    },\n    /**\n     * @return {void}\n     * @protected\n     */\n    unmount () {\n      this.clear()\n      this::vectorSource.methods.unmount()\n    },\n  }\n\n  const diffById = (a, b) => a.id === b.id\n  const watch = {\n    features (value, oldValue) {\n      if (!this.$source) return\n\n      let forAdd = difference(value, oldValue, diffById)\n      let forRemove = difference(oldValue, value, diffById)\n\n      this.addFeatures(forAdd)\n      this.removeFeatures(forRemove)\n    },\n  }\n\n  export default {\n    name: 'vl-source-vector',\n    mixins: [vectorSource],\n    props,\n    computed,\n    methods,\n    watch,\n  }\n\n  /**\n   * @return {LoadingStrategy}\n   */\n  function defaultStrategyFactory () {\n    return loadingAll\n  }\n\n  /**\n   * @return {GeoJSON}\n   */\n  function defaultFormatFactory () {\n    return createGeoJsonFmt()\n  }\n\n  /**\n   * Default loader for provided URL.\n   *\n   * @param vm\n   * @return {Function}\n   */\n  function defaultLoaderFactory (vm) {\n    return (extent, resolution, projection) => {\n      let url = vm.$source.getUrl()\n      if (isFunction(url)) {\n        url = url(extent, resolution, projection)\n      }\n\n      if (isEmpty(url)) {\n        return []\n      }\n\n      return fetch(url, {\n        credentials: 'same-origin',\n        mode: 'cors',\n      }).then(response => response.text())\n        .then(text => {\n          if (!vm.$source) {\n            return []\n          }\n\n          return vm.$source.getFormat().readFeatures(text, {\n            featureProjection: vm.viewProjection,\n            dataProjection: vm.resolvedDataProjection,\n          })\n        })\n    }\n  }\n\n  function transformExtent (extent, sourceProj, destProj) {\n    extent = extent.slice()\n    if (isFinite(extent[0]) && isFinite(extent[1])) {\n      [extent[0], extent[1]] = transform([extent[0], extent[1]], sourceProj, destProj)\n    }\n    if (isFinite(extent[2]) && isFinite(extent[3])) {\n      [extent[2], extent[3]] = transform([extent[2], extent[3]], sourceProj, destProj)\n    }\n    return extent\n  }\n</script>\n","import { pick } from '../../util/minilo'\nimport Source from './source.vue'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  options = pick(options, 'dataProjection')\n  Object.assign(Source, options)\n\n  Vue.component(Source.name, Source)\n}\n\nexport default plugin\n\nexport {\n  Source,\n  plugin as install,\n}\n"],"names":["props","features","type","Array","default","stubArray","loaderFactory","Function","defaultLoaderFactory","formatFactory","defaultFormatFactory","url","String","strategyFactory","defaultStrategyFactory","overlaps","Boolean","computed","featureIds","map","getFeatureId","methods","createSource","VectorSource","attributions","projection","resolvedDataProjection","loader","createLoader","useSpatialIndex","wrapX","logo","strategy","call","undefined","format","createUrlFunc","isFunction","constant","extent","resolution","transformExtent","$source","addFeatures","mount","vectorSource","unmount","clear","diffById","a","b","id","watch","value","oldValue","forAdd","difference","forRemove","removeFeatures","name","mixins","loadingAll","createGeoJsonFmt","vm","getUrl","isEmpty","fetch","credentials","mode","then","response","text","getFormat","readFeatures","featureProjection","viewProjection","dataProjection","sourceProj","destProj","slice","isFinite","transform","plugin","Vue","options","installed","pick","Source","component"],"mappings":"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"}